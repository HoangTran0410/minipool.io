var MiniBillar;
(function(MiniBillar) {
    class AudioManager {
        static init(game) {
            AudioManager.game = game;
            AudioManager.loopPlayingKey = null;
            AudioManager.audioSprite = AudioManager.game.add.audioSprite("audio-sprite");
            AudioManager.ballHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.cushionHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.pocketHitEffectPlayedTime = AudioManager.game.time.time;
            AudioManager.runningTime = false;
            AudioManager.game.sound.mute = MiniBillar.GameVars.gameData.musicMuted;
        }
        static switchAudio() {
            MiniBillar.GameVars.gameData.musicMuted = !MiniBillar.GameVars.gameData.musicMuted;
            AudioManager.game.sound.mute = MiniBillar.GameVars.gameData.musicMuted;
            MiniBillar.GameManager.writeGameData();
        }
        static playEffect(key, volume) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (key === AudioManager.TIME_RUNNING_OUT) {
                if (AudioManager.runningTime) {
                    return;
                } else {
                    AudioManager.runningTime = true;
                }
            }
            let omitEffect = false;
            if (key === AudioManager.BALL_HIT) {
                if (AudioManager.game.time.time - AudioManager.ballHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                } else {
                    AudioManager.ballHitEffectPlayedTime = AudioManager.game.time.time;
                }
            } else if (key === AudioManager.CUSHION_HIT) {
                if (AudioManager.game.time.time - AudioManager.cushionHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                } else {
                    AudioManager.cushionHitEffectPlayedTime = AudioManager.game.time.time;
                }
            } else if (key === AudioManager.POCKET) {
                if (AudioManager.game.time.time - AudioManager.pocketHitEffectPlayedTime < AudioManager.MIN_TIME) {
                    omitEffect = true;
                } else {
                    AudioManager.pocketHitEffectPlayedTime = AudioManager.game.time.time;
                }
            }
            if (!omitEffect) {
                AudioManager.audioSprite.play(key, volume);
            }
        }
        static stopEffect(key, fade) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (key === AudioManager.TIME_RUNNING_OUT) {
                AudioManager.runningTime = false;
            }
            if (fade) {
                const sound = AudioManager.audioSprite.get(key);
                sound.fadeOut(850);
            } else {
                AudioManager.audioSprite.stop(key);
            }
        }
        static playMusic(key, loop, volume) {
            loop = loop || false;
            volume = volume || 1;
            if (loop) {
                if (AudioManager.loopPlayingKey && (AudioManager.loopPlayingKey !== key)) {
                    AudioManager.stopMusic(AudioManager.loopPlayingKey, true, true);
                }
            }
            if (key !== this.loopPlayingKey) {
                AudioManager.audioSprite.play(key, volume);
                AudioManager.loopPlayingKey = key;
            }
        }
        static stopMusic(key, fade, loop) {
            if (key === null || typeof key === "undefined") {
                return;
            }
            if (fade) {
                const sound = this.audioSprite.get(key);
                sound.fadeOut(850);
            } else {
                AudioManager.audioSprite.stop(key);
            }
            if (loop) {
                AudioManager.loopPlayingKey = null;
            }
        }
    }
    AudioManager.BALL_HIT = "ball_hit";
    AudioManager.POCKET = "pocket";
    AudioManager.CUSHION_HIT = "cushion_hit";
    AudioManager.LOSE_POINTS = "lose_points";
    AudioManager.CUE_HIT = "cue_hit";
    AudioManager.POCKET_ADD_TIME = "pocket_add_time";
    AudioManager.BTN_NORMAL = "click_btn";
    AudioManager.GIFT_CARD_SWISH = "gift_card_swish";
    AudioManager.GIFT_OPENS = "gift_opens";
    AudioManager.LOSE = "lose";
    AudioManager.WIN = "win";
    AudioManager.MUSIC_MATCH_MINIBILLARD = "music_match_minibilliard";
    AudioManager.MUSIC_MINIBILLARD = "music_minibilliard";
    AudioManager.TIME_RUNNING_OUT = null;
    AudioManager.MIN_TIME = 75;
    MiniBillar.AudioManager = AudioManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class Game extends Phaser.Game {
        constructor() {
            let renderer;
            if (navigator.userAgent.match(/iPhone/i) || navigator.userAgent.match(/iPad/i) || navigator.userAgent.match(/iPod/i)) {
                renderer = Phaser.CANVAS;
            } else {
                renderer = Phaser.AUTO;
            }
            super(MiniBillar.GameConstants.GAME_WIDTH, MiniBillar.GameConstants.GAME_HEIGHT, renderer, "content", null, false, true);
            Game.currentInstance = this;
            this.state.add("Boot", MiniBillar.Boot, true);
            this.state.add("PreLoader", MiniBillar.PreLoader, false);
            this.state.add("SplashState", MiniBillar.SplashState, false);
            this.state.add("LobbyState", MiniBillar.LobbyState, false);
            this.state.add("PoolState", MiniBillar.PoolState, false);
            this.state.add("EquipmentState", MiniBillar.EquipmentState, false);
            this.state.add("PlayerRegisteringState", MiniBillar.PlayerRegisteringState, false);
            this.state.start("Boot");
        }
    }
    MiniBillar.Game = Game;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GameConstants {}
    GameConstants.VERSION = "1.0.2";
    GameConstants.DEVELOPMENT = false;
    GameConstants.DEBUG = false;
    GameConstants.VERBOSE = false;
    GameConstants.SHOW_DEV_BUTTONS_ON_SOLO = false;
    GameConstants.SHOW_PVBOT_CHEAT_BUTTONS = false;
    GameConstants.LOG_SERVER_INFO = false;
    GameConstants.LOG_BOT_SERVER_INFO = false;
    GameConstants.GAME_WIDTH = 1024;
    GameConstants.GAME_HEIGHT = 640;
    GameConstants.ASSETS_PATH = gameConfig.GAME_ASSETS_PATH || "assets";
    GameConstants.APPLE = "apple";
    GameConstants.ANDROID = "android";
    GameConstants.TIME_SOLO_MATCH = 120;
    GameConstants.PHYS_SCALE = .01;
    GameConstants.BALL_RADIUS = 1400;
    GameConstants.FRICTION = 1;
    GameConstants.POCKET_RADIUS = 2300;
    GameConstants.MIN_VELOCITY = 2;
    GameConstants.CUSHION_RESTITUTION = .6;
    GameConstants.BALL_RESTITUTION = .91;
    GameConstants.MIN_SWIPE_CHANGE_DISTANCE = 320;
    GameConstants.BITMAP_SIZE = 64;
    GameConstants.BLACK_SQUARE = "black-square";
    GameConstants.BLUE_SQUARE = "blue_square";
    GameConstants.WHITE_SQUARE = "white-square";
    GameConstants.RED_SQUARE = "red-square";
    GameConstants.ORANGE_SQUARE = "orange-square";
    GameConstants.YELLOW_SQUARE = "yellow-square";
    GameConstants.GREEN_SQUARE = "green-square";
    GameConstants.GREY_SQUARE = "grey-square";
    GameConstants.BALL_TYPE_SOLID = "ball solid";
    GameConstants.BALL_TYPE_STRIPED = "ball striped";
    GameConstants.BALL_TYPE_BLACK = "ball black";
    GameConstants.BALL_TYPE_NONE = "ball none";
    GameConstants.LEFT = "left";
    GameConstants.RIGHT = "right";
    GameConstants.UP = "up";
    GameConstants.DOWN = "down";
    GameConstants.NO_GAME = "no_game";
    GameConstants.SOLO_MODE = "solo";
    GameConstants.PVP_MODE = "pvp";
    GameConstants.PVBOT_MODE = "pvbot";
    GameConstants.NOTIFICATION_NONE = "notification none";
    GameConstants.NOTIFICATION_CUE_BALL_POTTED = "notification cue ball potted";
    GameConstants.NOTIFICATION_WRONG_BALL_POTTED = "notification wrong ball potted";
    GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED = "notification wrong ball touched";
    GameConstants.NOTIFICATION_NO_BALL_TOUCHED = "notification no ball touched";
    GameConstants.NOTIFICATION_NO_WALL_COLLISION = "notification no wall collision";
    GameConstants.NOTIFICATION_TIMEOUT = "notification timeout";
    GameConstants.NOTIFICATION_ILEGAL_BREAK = "notification ilegal";
    GameConstants.NOTIFICATION_YOUR_TURN = "notification your turn";
    GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS = "first time instructions";
    GameConstants.GAME_UNDECIDED = "game_undecided";
    GameConstants.PLAYER_WIN = "player_win";
    GameConstants.PLAYER_LOSE = "player_lose";
    GameConstants.PLAYER_RESIGNS = "player_resigns";
    GameConstants.ADVERSARY_LEFT_ROOM = "adversary_left_room";
    GameConstants.MIN_PTS_TO_GET_REWARD = 2500;
    GameConstants.MIN_PTS_UNLOCK_TABLE = 200;
    GameConstants.MIN_PTS_UNLOCK_CUE = 100;
    GameConstants.MIN_CARDS_WON_AT_A_TIME = 6;
    GameConstants.MAX_CARDS_WON_AT_A_TIME = 15;
    GameConstants.RULES_TEXT = "Pocket all coloured balls before the clock runs out.\n" +
        "Coloured balls add 50 pts and 10s. The cue ball deducts 20 pts.\n" +
        "Score at least " + GameConstants.MIN_PTS_TO_GET_REWARD.toString() + " pts to unlock new cues and tables!";
    GameConstants.PLAYER = "player";
    GameConstants.ADVERSARY = "adversary";
    GameConstants.MESSAGE_TYPE_PLAYER_SET = "PLAYER SET";
    GameConstants.MESSAGE_TYPE_SHOT = "SHOT";
    GameConstants.MESSAGE_TYPE_BALLS_STOPPED = "BALLS_STOPPED";
    GameConstants.MESSAGE_TYPE_CUE_ROTATION = "CUE_ROTATION";
    GameConstants.MESSAGE_TYPE_POCKET_SELECTED = "POCKET_SELECTED";
    GameConstants.MESSAGE_TYPE_CUE_BALL = "CUE_BALL";
    GameConstants.MESSAGE_TYPE_RESIGN = "RESIGN";
    GameConstants.MESSAGE_TYPE_PLAYER_QUIT_LOBBY = "PLAYER_QUIT_LOBBY";
    GameConstants.MESSAGE_TYPE_EMOTICON_SELECTED = "EMOTICON_SELECTED";
    GameConstants.MESSAGE_TYPE_CUE_BALL_SPIN_SET = "CUE_BALL_SPIN_SET";
    GameConstants.MESSAGE_TYPE_BALL_8_POCKETED = "BALL_8_POCKETED";
    GameConstants.BALLS_INITIAL_POSITIONS = [
        [-21000, 0],
        [21000, 0],
        [23424.8, 1400],
        [30699.2, -5600],
        [28274.4, 4200],
        [25849.6, 2800],
        [28274.4, -4200],
        [28274.4, 1400],
        [25849.6, 0],
        [28274.4, -1400],
        [25849.6, -2800],
        [30699.2, 0],
        [30699.2, 2800],
        [30699.2, -2800],
        [30699.2, 5600],
        [23424.8, -1400]
    ];
    GameConstants.BALLS_INITIAL_POSITIONS_SOLO = [
        [-21000, 0],
        [21000, 0],
        [23424.8, 1400],
        [30699.2, -5600 - 4000],
        [28274.4, 4200 + 4000],
        [25849.6, 2800],
        [28274.4, -4200 - 4000],
        [28274.4, 1400],
        [25849.6, 0],
        [28274.4, -1400],
        [25849.6, -2800],
        [30699.2, 0],
        [30699.2, 2800 + 4000],
        [30699.2, -2800 - 4000],
        [30699.2, 5600 + 4000],
        [23424.8, -1400]
    ];
    GameConstants.SAVED_GAME_DATA_KEY = "minibillar-data-key-1";
    MiniBillar.GameConstants = GameConstants;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GameManager {
        static init(game) {
            GameManager.game = game;
            Communication.CommunicationManager.init();
            GameManager.communicationFunctionsPVP();
            GameManager.setBilliardConstants();
            GameManager.readGameData();
        }
        static resetNonSOLOVars() {
            if (MiniBillar.GameConstants.LOG_SERVER_INFO || MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("resetNonSOLOVars");
            }
            MiniBillar.LobbyState.currentInstance = null;
            MiniBillar.GameVars.adversaryData = null;
            MiniBillar.GameVars.gameData.playerData.ballsMoving = false;
            MiniBillar.GameVars.gameData.playerData.canPocketBlackBall = false;
            MiniBillar.GameVars.gameData.playerData.id = "";
            MiniBillar.GameVars.gameData.playerData.sessionId = "";
            MiniBillar.GameVars.gameData.playerData.set = false;
            MiniBillar.GameVars.gameData.playerData.typeBalls = MiniBillar.GameConstants.BALL_TYPE_NONE;
            MiniBillar.GameVars.playersSetForPVP = false;
            MiniBillar.GameVars.playersSetForPVBot = false;
        }
        static communicationFunctionsPVP() {
            Communication.CommunicationManager.onPlayerJoined = (players, isPlayerA) => GameManager.onPlayerJoinedPVP(players, isPlayerA);
            Communication.CommunicationManager.startMatch = () => GameManager.startPVPMatch();
            Communication.CommunicationManager.onTurnChange = (state) => GameManager.onPVPTurnChange(state);
            Communication.CommunicationManager.matchFinished = (winnerSessionId) => MiniBillar.MatchManagerPVP.matchFinished(winnerSessionId);
            Communication.CommunicationManager.adversaryLeftRoom = () => MiniBillar.MatchManagerPVP.adversaryLeftRoomPVP();
            Communication.CommunicationManager.matchOverDueToResignation = (data) => MiniBillar.MatchManagerPVP.matchOverDueToResignation(data);
            Communication.CommunicationManager.showPocketSelected = (data) => MiniBillar.MatchManagerPVP.showPocketSelected(data);
            Communication.CommunicationManager.adversaryRotatedCue = (data) => MiniBillar.MatchManagerPVP.adversaryRotatedCue(data);
            Communication.CommunicationManager.adversaryCueBallPosition = (data) => MiniBillar.MatchManagerPVP.adversaryCueBallPosition(data);
            Communication.CommunicationManager.shotDataReceived = (data) => MiniBillar.MatchManagerPVP.shotDataReceived(data);
            Communication.CommunicationManager.waitingPlayerEnd = () => GameManager.waitingPlayerEndPVP();
            Communication.CommunicationManager.showEmoticon = (data) => MiniBillar.MatchManager.showAdversaryEmoticon(data);
            Communication.CommunicationManager.cueBallSpinSet = (data) => MiniBillar.MatchManager.cueBallSpinSet(data);
        }
        static readGameData() {
            GameManager.getGameStorageData(MiniBillar.GameConstants.SAVED_GAME_DATA_KEY, function(gameData) {
                if (gameData) {
                    MiniBillar.GameVars.gameData = JSON.parse(gameData);
                } else {
                    GameManager.resetGameVars();
                }
                GameManager.startGame();
            }, function(error) {
                GameManager.log("error retriving saved game data.", error);
            });
        }
        static onGameAssetsLoaded() {
            MiniBillar.AudioManager.init(GameManager.game);
            MiniBillar.RewardsManager.init(GameManager.game);
            MiniBillar.RewardsManager.loadAndVerifyCards();
            MiniBillar.GameVars.goDirectlyToLobby = false;
            let cache = this.game.cache;
            let frameNames = cache._cache.image.texture_atlas_5.frameData._frameNames;
            let i = 0;
            while (typeof frameNames["emoticon_" + (i + 1) + ".png"] !== "undefined") {
                i++;
            }
            MiniBillar.GameVars.emoticonsAmount = i;
            GameManager.enterSplash();
        }
        static exitLobby() {
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_PLAYER_QUIT_LOBBY,
                data: null
            });
            GameManager.enterSplash();
        }
        static enterSoloGame(enteringFromSplash) {
            enteringFromSplash = enteringFromSplash || false;
            if (enteringFromSplash) {
                lechuck.ads.showInterlevelAd("https://ext.minijuegos.com/video/tags.php?id=mini-pool-io&type=desktop", function() {
                    GameManager.game.paused = true;
                }, function() {
                    GameManager.game.paused = false;
                    GameManager.fullscreenFilter(function() {
                        GameManager.resetMatchVars();
                        MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.SOLO_MODE;
                        GameManager.game.state.start("PoolState", true, false);
                    });
                }, function() {
                    GameManager.game.paused = false;
                    GameManager.fullscreenFilter(function() {
                        GameManager.resetMatchVars();
                        MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.SOLO_MODE;
                        GameManager.game.state.start("PoolState", true, false);
                    });
                });
            } else {
                GameManager.resetMatchVars();
                MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.SOLO_MODE;
                GameManager.game.state.start("PoolState", true, false);
            }
        }
        static enterPVBotGame() {
            GameManager.fullscreenFilter(function() {
                GameManager.resetMatchVars();
                MiniBillar.RulesManager.init(MiniBillar.GameVars.gameData.playerData, MiniBillar.GameVars.adversaryData);
                GameManager.onPVBotTurnChange(null);
            });
        }
        static enterPVPGame() {
            lechuck.ads.showInterlevelAd("https://ext.minijuegos.com/video/tags.php?id=mini-pool-io&type=desktop", function() {
                GameManager.game.paused = true;
            }, function() {
                GameManager.game.paused = false;
                GameManager.fullscreenFilter(function() {
                    GameManager.resetMatchVars();
                    const roomCreated = Communication.CommunicationManager.joinRoom(MiniBillar.GameVars.gameData.playerData);
                    if (roomCreated) {
                        GameManager.game.state.start("LobbyState", true, false);
                    }
                });
            }, function() {
                GameManager.game.paused = false;
                GameManager.fullscreenFilter(function() {
                    GameManager.resetMatchVars();
                    const roomCreated = Communication.CommunicationManager.joinRoom(MiniBillar.GameVars.gameData.playerData);
                    if (roomCreated) {
                        GameManager.game.state.start("LobbyState", true, false);
                    }
                });
            });
        }
        static enterEquipment() {
            GameManager.game.state.start("EquipmentState", true, false);
        }
        static enterSplash() {
            GameManager.resetNonSOLOVars();
            GameManager.game.state.start("SplashState", true, false);
        }
        static enterPortraitSelectionScreen() {
            GameManager.fullscreenFilter(function() {
                GameManager.game.state.start("PlayerRegisteringState", true, false);
            });
        }
        static writeGameData() {
            GameManager.setGameStorageData(MiniBillar.GameConstants.SAVED_GAME_DATA_KEY, MiniBillar.GameVars.gameData, function() {
                GameManager.log("game data successfully saved");
            }, function(error) {
                GameManager.log("error saving game data", error);
            });
        }
        static log(text, error, color) {
            if (!MiniBillar.GameConstants.VERBOSE) {
                return;
            }
            if (error) {
                console.error(text + ":", error);
            } else {
                console.log("%c " + text, "color:" + color);
            }
        }
        static changePowerBar() {
            if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT) {
                MiniBillar.GameVars.gameData.powerBarSide = MiniBillar.GameConstants.RIGHT;
            } else {
                MiniBillar.GameVars.gameData.powerBarSide = MiniBillar.GameConstants.LEFT;
            }
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.changePowerBar();
            }
            GameManager.writeGameData();
        }
        static validatePocketedBalls() {
            let ballsToRemoveFromPocketedBalls = [];
            for (let i = 0; i < MiniBillar.GameVars.pocketedBalls.length; i++) {
                let ballId = MiniBillar.GameVars.pocketedBalls[i];
                for (let j = 0; j < MiniBillar.GameVars.ballsData.length; j++) {
                    let ballData = MiniBillar.GameVars.ballsData[j];
                    if (ballData.id === ballId && ballData.active) {
                        ballsToRemoveFromPocketedBalls.push(ballId);
                    }
                }
            }
            if (ballsToRemoveFromPocketedBalls.length > 0) {
                for (let i = ballsToRemoveFromPocketedBalls.length - 1; i >= 0; i--) {
                    let index = MiniBillar.GameVars.pocketedBalls.indexOf(ballsToRemoveFromPocketedBalls[i]);
                    MiniBillar.GameVars.pocketedBalls.splice(index, 1);
                }
            }
            let ballsToAddToPocketedBalls = [];
            for (let i = 0; i < MiniBillar.GameVars.ballsData.length; i++) {
                let ballData = MiniBillar.GameVars.ballsData[i];
                if (!ballData.active) {
                    let needAdd = false;
                    for (let j = 0; j < MiniBillar.GameVars.pocketedBalls.length; j++) {
                        let ballId = MiniBillar.GameVars.pocketedBalls[j];
                        if (ballId === ballData.id) {
                            needAdd = true;
                            break;
                        }
                    }
                    if (needAdd) {
                        ballsToAddToPocketedBalls.push(ballData.id);
                    }
                }
            }
            if (ballsToAddToPocketedBalls.length > 0) {
                for (let i = ballsToAddToPocketedBalls.length - 1; i >= 0; i--) {
                    MiniBillar.GameVars.pocketedBalls.push(ballsToAddToPocketedBalls[i]);
                }
            }
        }
        static exitFullscreen() {
            if (GameManager.game.device.touch && GameManager.game.scale.compatibility.supportsFullScreen) {
                GameManager.game.scale.stopFullScreen();
            }
        }
        static fullscreenFilter(onSuccess) {
            const isYabrowser = navigator.userAgent.indexOf("YaBrowser") > -1;
            const isIosOrSafari = GameManager.game.device.iOS && GameManager.game.device.mobileSafari;
            const goAheadWithFullscreen = isYabrowser || (!isYabrowser && !isIosOrSafari);
            if (GameManager.game.device.touch && GameManager.game.scale.compatibility.supportsFullScreen && goAheadWithFullscreen) {
                const root = document.documentElement;
                GameManager.game.scale.fullScreenTarget = root;
                GameManager.game.scale.startFullScreen();
                GameManager.game.time.events.add(0.15 * Phaser.Timer.SECOND, function() {
                    GameManager.game.scale.setMinMax(window.innerWidth, window.innerHeight);
                    MiniBillar.Boot.onFullScreenChange();
                    onSuccess();
                }, this);
            } else {
                onSuccess();
            }
        }
        static waitingPlayerEndPVP() {
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("waitingPlayerEndPVP()");
            }
            if (MiniBillar.LobbyState.currentInstance) {
                GameManager.setupBotMatchData();
                MiniBillar.LobbyState.currentInstance.fakePlayerFound();
            }
        }
        static onPVPTurnChange(state) {
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("onPVPTurnChange()");
            }
            if (MiniBillar.GameVars.playersSetForPVP) {
                MiniBillar.MatchManagerPVP.newTurn(state);
                MiniBillar.PoolState.currentInstance.hud.newTurn();
            } else {
                GameManager.setPlayer(state.currentTurn);
            }
        }
        static setupBotMatchData() {
            MiniBillar.GameVars.adversaryData = {
                nick: this.game.rnd.pick(MiniBillar.Utils.getRandomUsernameList()),
                avatar: this.game.rnd.pick(MiniBillar.Utils.getRandomAvatarImageList()),
                equipedCue: this.game.rnd.pick(MiniBillar.RewardsManager.getCuesList()),
                sessionId: "bot",
                id: "",
                set: false,
                ballsMoving: false,
                typeBalls: MiniBillar.GameConstants.BALL_TYPE_NONE,
                canPocketBlackBall: false
            };
            MiniBillar.GameVars.gameData.playerData.sessionId = "player";
        }
        static onPVBotTurnChange(state) {
            if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("onPVBotTurnChange()");
            }
            if (MiniBillar.GameVars.playersSetForPVBot) {
                MiniBillar.MatchManagerPVBot.newTurn(state);
                MiniBillar.PoolState.currentInstance.hud.newTurn();
            } else {
                MiniBillar.GameVars.playersSetForPVBot = true;
                MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.PVBOT_MODE;
                MiniBillar.MatchManagerPVBot.init(GameManager.game);
            }
        }
        static setPlayer(currentTurn) {
            MiniBillar.GameVars.playersSetForPVP = true;
            GameManager.game.time.events.add(Phaser.Timer.SECOND, function() {
                if (MiniBillar.LobbyState.currentInstance) {
                    MiniBillar.LobbyState.currentInstance.setPlayers();
                }
            }, GameManager);
            GameManager.game.time.events.add(2 * Phaser.Timer.SECOND, function() {
                MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.PVP_MODE;
                MiniBillar.MatchManagerPVP.init(GameManager.game, currentTurn);
            }, GameManager);
        }
        static onPlayerJoinedPVP(players, isPlayerA) {
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("onPlayerJoinedPVP()");
            }
            if (!players.playerB) {
                if (isPlayerA) {
                    MiniBillar.GameVars.gameData.playerData.sessionId = players.playerA.sessionId;
                    MiniBillar.GameVars.gameData.playerData.id = players.playerA.id;
                } else {
                    MiniBillar.GameVars.adversaryData = players.playerA;
                }
            } else {
                if (isPlayerA) {
                    MiniBillar.GameVars.adversaryData = players.playerB;
                } else {
                    MiniBillar.GameVars.gameData.playerData.sessionId = players.playerB.sessionId;
                    MiniBillar.GameVars.gameData.playerData.id = players.playerB.id;
                }
            }
            if (MiniBillar.LobbyState.currentInstance) {
                GameManager.game.time.events.add(150, MiniBillar.LobbyState.currentInstance.onPlayerJoined, MiniBillar.LobbyState.currentInstance);
            } else {
                if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                    console.error("Lobby not ready");
                }
            }
        }
        static avatarSelected(avatarName) {
            MiniBillar.GameVars.gameData.playerData.avatar = avatarName;
            MiniBillar.PlayerRegisteringState.currentInstance.avatarSelected();
            GameManager.writeGameData();
        }
        static onItemEquiChange(cardType, cardId) {
            if (cardType === "cue") {
                MiniBillar.GameVars.gameData.playerData.equipedCue = cardId;
                miniplaySend2API("cues", parseInt(cardId[cardId.length - 1]));
            } else {
                MiniBillar.GameVars.gameData.equippedTable = cardId;
                miniplaySend2API("tables", parseInt(cardId[cardId.length - 1]));
            }
            GameManager.writeGameData();
        }
        static startPVPMatch() {
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("startPVPMatch()");
            }
        }
        static startGame() {
            GameManager.game.state.start("PreLoader", true, false);
        }
        static resetGameVars() {
            let nonSolo = {
                gamesPlayed: 0,
                gamesWon: 0,
                gamesLost: 0
            };
            let solo = {
                highScore: 0
            };
            let rewards = {
                starProgress: 0,
                cards: [],
                allUnlocked: false
            };
            let statistics = {
                nonSolo: nonSolo,
                solo: solo,
                rewards: rewards
            };
            MiniBillar.GameVars.gameData = {
                playerData: {
                    nick: "Player",
                    avatar: GameManager.game.rnd.pick(MiniBillar.Utils.getRandomAvatarImageList()),
                    equipedCue: "NO_CUE_SELECTED",
                    sessionId: "player",
                    id: "",
                    set: false,
                    ballsMoving: false,
                    typeBalls: MiniBillar.GameConstants.BALL_TYPE_NONE,
                    canPocketBlackBall: false
                },
                equippedTable: "NO_TABLE_SELECTED",
                musicMuted: false,
                effectsMuted: false,
                powerBarSide: MiniBillar.GameConstants.LEFT,
                statistics: statistics,
                soloTutorial: true,
                multiplayerTutorial: true,
            };
            if (MiniBillar.GameConstants.DEVELOPMENT) {
                MiniBillar.GameVars.gameData = {
                    playerData: {
                        nick: "Player",
                        avatar: GameManager.game.rnd.pick(MiniBillar.Utils.getRandomAvatarImageList()),
                        equipedCue: "NO_CUE_SELECTED",
                        sessionId: "player",
                        id: "",
                        set: false,
                        ballsMoving: false,
                        typeBalls: MiniBillar.GameConstants.BALL_TYPE_NONE,
                        canPocketBlackBall: false
                    },
                    equippedTable: "NO_TABLE_SELECTED",
                    musicMuted: false,
                    effectsMuted: false,
                    powerBarSide: MiniBillar.GameConstants.RIGHT,
                    statistics: statistics,
                    soloTutorial: true,
                    multiplayerTutorial: true,
                };
            }
        }
        static resetMatchVars() {
            MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.NO_GAME;
            MiniBillar.GameVars.pocketedBalls = [];
            MiniBillar.GameVars.ballsData = [];
            this.resetSoloMatchScoreAndTime();
            MiniBillar.GameVars.shotCount = 0;
            MiniBillar.GameVars.timerPVP = 30;
            MiniBillar.GameVars.startMatch = false;
            MiniBillar.GameVars.gameEnded = MiniBillar.GameConstants.GAME_UNDECIDED;
            MiniBillar.GameVars.currentTurn = null;
            MiniBillar.GameVars.firstShot = true;
            MiniBillar.GameVars.rematch = false;
            MiniBillar.GameVars.timeMatch = 0;
            MiniBillar.GameVars.paused = false;
            MiniBillar.GameVars.shotRunning = false;
            MiniBillar.GameVars.turnSet = true;
            MiniBillar.GameVars.wallCollisions = [];
            MiniBillar.GameVars.english = 0;
            MiniBillar.GameVars.verticalSpin = 0;
            MiniBillar.GameVars.GUIButtonDown = false;
            MiniBillar.GameVars.draggingCueBall = false;
            MiniBillar.GameVars.skipShowingPocketAndCue = false;
            MiniBillar.GameVars.pocketIdWhereBlackFell = -1;
            MiniBillar.GameVars.canStart = false;
            if (MiniBillar.GameConstants.DEVELOPMENT) {
                MiniBillar.GameVars.gameMode = MiniBillar.GameConstants.NO_GAME;
                MiniBillar.GameVars.pocketedBalls = [];
                MiniBillar.GameVars.ballsData = [];
                MiniBillar.GameVars.startMatch = false;
                MiniBillar.GameVars.gameEnded = MiniBillar.GameConstants.GAME_UNDECIDED;
                MiniBillar.GameVars.currentTurn = null;
                MiniBillar.GameVars.firstShot = true;
                MiniBillar.GameVars.rematch = false;
                MiniBillar.GameVars.timeMatch = 0;
            }
        }
        static resetSoloMatchScoreAndTime() {
            if (MiniBillar.GameVars.resetScoreAndTime || (!MiniBillar.GameVars.playerPoints && !MiniBillar.GameVars.timerSolo)) {
                if (MiniBillar.GameConstants.DEVELOPMENT) {
                    MiniBillar.GameVars.playerPoints = 0;
                    MiniBillar.GameVars.timerSolo = 50;
                } else {
                    MiniBillar.GameVars.playerPoints = 0;
                    MiniBillar.GameVars.timerSolo = MiniBillar.GameConstants.TIME_SOLO_MATCH;
                }
            }
            MiniBillar.GameVars.resetScoreAndTime = true;
        }
        static setBilliardConstants() {
            MiniBillar.GameVars.pocketArray = [];
            let pocket = {
                id: 0,
                position: new Billiard.Vector2D(-42e3 - MiniBillar.GameConstants.POCKET_RADIUS / 4, -21e3 - MiniBillar.GameConstants.POCKET_RADIUS / 4),
                dropPosition: new Billiard.Vector2D(-42840 - MiniBillar.GameConstants.POCKET_RADIUS / 2, -21840 - MiniBillar.GameConstants.POCKET_RADIUS / 4)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            pocket = {
                id: 1,
                position: new Billiard.Vector2D(0, -21e3 - MiniBillar.GameConstants.POCKET_RADIUS),
                dropPosition: new Billiard.Vector2D(0, -21420 - MiniBillar.GameConstants.POCKET_RADIUS)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            pocket = {
                id: 2,
                position: new Billiard.Vector2D(42e3 + MiniBillar.GameConstants.POCKET_RADIUS / 4, -21e3 - MiniBillar.GameConstants.POCKET_RADIUS / 4),
                dropPosition: new Billiard.Vector2D(42840 + MiniBillar.GameConstants.POCKET_RADIUS / 2, -21840 - MiniBillar.GameConstants.POCKET_RADIUS / 4)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            pocket = {
                id: 3,
                position: new Billiard.Vector2D(-42e3 - MiniBillar.GameConstants.POCKET_RADIUS / 4, 21e3 + MiniBillar.GameConstants.POCKET_RADIUS / 4),
                dropPosition: new Billiard.Vector2D(-42840 - MiniBillar.GameConstants.POCKET_RADIUS / 2, 21840 + MiniBillar.GameConstants.POCKET_RADIUS / 4)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            pocket = {
                id: 4,
                position: new Billiard.Vector2D(0, 21e3 + MiniBillar.GameConstants.POCKET_RADIUS),
                dropPosition: new Billiard.Vector2D(0, 21420 + MiniBillar.GameConstants.POCKET_RADIUS)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            pocket = {
                id: 5,
                position: new Billiard.Vector2D(42e3 + MiniBillar.GameConstants.POCKET_RADIUS / 4, 21e3 + MiniBillar.GameConstants.POCKET_RADIUS / 4),
                dropPosition: new Billiard.Vector2D(42840 + MiniBillar.GameConstants.POCKET_RADIUS / 2, 21840 + MiniBillar.GameConstants.POCKET_RADIUS / 4)
            };
            MiniBillar.GameVars.pocketArray.push(pocket);
            MiniBillar.GameVars.lineArray = [];
            MiniBillar.GameVars.vertexArray = [];
            let line = {
                name: "AB",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-42e3, -24360),
                p2: new Billiard.Vector2D(-38640, -21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            let vertex = {
                name: "B",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "BC",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-38640, -21e3),
                p2: new Billiard.Vector2D(-3360, -21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "C",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "CD",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-3360, -21e3),
                p2: new Billiard.Vector2D(-1680, -24360),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            line = {
                name: "EF",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(1680, -24360),
                p2: new Billiard.Vector2D(3360, -21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "F",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "FG",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(3360, -21e3),
                p2: new Billiard.Vector2D(38640, -21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "G",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "GH",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(38640, -21e3),
                p2: new Billiard.Vector2D(42e3, -24360),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            line = {
                name: "IJ",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(45360, -21e3),
                p2: new Billiard.Vector2D(42e3, -17640),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "J",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "JK",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(42e3, -17640),
                p2: new Billiard.Vector2D(42e3, 17640),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "K",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "KL",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(42e3, 17640),
                p2: new Billiard.Vector2D(45360, 21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            line = {
                name: "MN",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(42e3, 24360),
                p2: new Billiard.Vector2D(38640, 21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "N",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "NO",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(38640, 21e3),
                p2: new Billiard.Vector2D(3360, 21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "O",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "OP",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(3360, 21e3),
                p2: new Billiard.Vector2D(1680, 24360),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            line = {
                name: "QR",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-1680, 24360),
                p2: new Billiard.Vector2D(-3360, 21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "R",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "RS",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-3360, 21e3),
                p2: new Billiard.Vector2D(-38640, 21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "S",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "ST",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-38640, 21e3),
                p2: new Billiard.Vector2D(-42e3, 24360),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            line = {
                name: "UV",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-45360, 21e3),
                p2: new Billiard.Vector2D(-42e3, 17640),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "V",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "VW",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-42e3, 17640),
                p2: new Billiard.Vector2D(-42e3, -17640),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            vertex = {
                name: "W",
                position: new Billiard.Vector2D(line.p2.x, line.p2.y)
            };
            MiniBillar.GameVars.vertexArray.push(vertex);
            line = {
                name: "WX",
                direction: null,
                normal: null,
                p1: new Billiard.Vector2D(-42e3, -17640),
                p2: new Billiard.Vector2D(-45360, -21e3),
                p3: null,
                p4: null,
                p5: null,
                p6: null
            };
            MiniBillar.GameVars.lineArray.push(line);
            for (let i = 0; i < MiniBillar.GameVars.lineArray.length; i++) {
                let line = MiniBillar.GameVars.lineArray[i];
                line.direction = new Billiard.Vector2D(line.p2.x - line.p1.x, line.p2.y - line.p1.y).normalize();
                line.normal = line.direction.getLeftNormal();
                let r = line.normal.times(MiniBillar.GameConstants.BALL_RADIUS);
                line.p3 = line.p1.plus(r);
                line.p4 = line.p2.plus(r);
                let s = line.normal.times(.525 * MiniBillar.GameConstants.BALL_RADIUS);
                line.p5 = line.p1.plus(s);
                line.p6 = line.p2.plus(s);
            }
        }
        static getGameStorageData(key, successCb, failureCb) {
            const gameDataStr = localStorage.getItem(key);
            successCb(gameDataStr);
        }
        static setGameStorageData(key, value, successCb, failureCb) {
            localStorage.setItem(key, JSON.stringify(value));
            successCb();
        }
    }
    MiniBillar.GameManager = GameManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GameVars {
        static extractLineArrayString() {
            const lineArray = [];
            for (let i = 0; i < GameVars.lineArray.length; i++) {
                lineArray.push({
                    name: GameVars.lineArray[i].name,
                    direction: {
                        x: GameVars.lineArray[i].direction.x,
                        y: GameVars.lineArray[i].direction.y
                    },
                    normal: {
                        x: GameVars.lineArray[i].normal.x,
                        y: GameVars.lineArray[i].normal.y
                    },
                    p1: {
                        x: GameVars.lineArray[i].p1.x,
                        y: GameVars.lineArray[i].p1.y
                    },
                    p2: {
                        x: GameVars.lineArray[i].p2.x,
                        y: GameVars.lineArray[i].p2.y
                    },
                    p3: {
                        x: GameVars.lineArray[i].p3.x,
                        y: GameVars.lineArray[i].p3.y
                    },
                    p4: {
                        x: GameVars.lineArray[i].p4.x,
                        y: GameVars.lineArray[i].p4.y
                    },
                    p5: {
                        x: GameVars.lineArray[i].p5.x,
                        y: GameVars.lineArray[i].p5.y
                    },
                    p6: {
                        x: GameVars.lineArray[i].p6.x,
                        y: GameVars.lineArray[i].p6.y
                    }
                });
            }
            return JSON.stringify(lineArray);
        }
        static extractVertexArrayString() {
            const vertexArray = [];
            for (let i = 0; i < GameVars.vertexArray.length; i++) {
                vertexArray.push({
                    name: GameVars.vertexArray[i].name,
                    position: {
                        x: GameVars.vertexArray[i].position.x,
                        y: GameVars.vertexArray[i].position.y
                    }
                });
            }
            return JSON.stringify(vertexArray);
        }
        static extractPocketArrayString() {
            const pocketArray = [];
            for (let i = 0; i < GameVars.pocketArray.length; i++) {
                pocketArray.push({
                    id: GameVars.pocketArray[i].id,
                    position: {
                        x: GameVars.pocketArray[i].position.x,
                        y: GameVars.pocketArray[i].position.y
                    },
                    dropPosition: {
                        x: GameVars.pocketArray[i].dropPosition.x,
                        y: GameVars.pocketArray[i].dropPosition.y
                    },
                });
            }
            return JSON.stringify(pocketArray);
        }
        static extractBallsArrayString() {
            const ballsArray = [];
            for (let i = 0; i < GameVars.ballArray.length; i++) {
                ballsArray.push({
                    id: GameVars.ballArray[i].id,
                    active: GameVars.ballArray[i].active,
                    position: {
                        x: GameVars.ballArray[i].position.x,
                        y: GameVars.ballArray[i].position.y
                    },
                });
            }
            return JSON.stringify(ballsArray);
        }
    }
    GameVars.gameWidth = MiniBillar.GameConstants.GAME_WIDTH;
    GameVars.gameHeight = MiniBillar.GameConstants.GAME_HEIGHT;
    MiniBillar.GameVars = GameVars;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class RewardsManager {
        static init(game) {
            RewardsManager.game = game;
            this.unlockedCards = [];
        }
        static loadAndVerifyCards() {
            const cardsData = this.game.cache.getJSON("card-data");
            this.cardsJSONData = cardsData;
            const loadCardsForFirstTime = MiniBillar.GameVars.gameData.statistics.rewards.cards.length === 0;
            if (loadCardsForFirstTime) {
                RewardsManager.populateCardDatabase();
                RewardsManager.initialEquip();
            } else {
                RewardsManager.updateCardDatabase();
            }
            for (let card of MiniBillar.GameVars.gameData.statistics.rewards.cards) {
                let cardTypeMax = this.getMaxForCardType(this.getCardType(card.cardName));
                if (card.cardPoints === cardTypeMax) {
                    this.updateUnlockedCardsArray(card.cardName);
                }
            }
            MiniBillar.GameManager.writeGameData();
        }
        static getCuesList() {
            let answer = [];
            for (let i = 0; i < this.cardsJSONData.length; i++) {
                if (this.cardsJSONData[i].type === "cue") {
                    answer.push(this.cardsJSONData[i].id);
                } else {
                    continue;
                }
            }
            if (answer.length === 0) {
                throw "No cues found";
            }
            return answer;
        }
        static getMaxForCardType(type) {
            return (type === "cue") ? MiniBillar.GameConstants.MIN_PTS_UNLOCK_CUE : MiniBillar.GameConstants.MIN_PTS_UNLOCK_TABLE;
        }
        static getCurrentStarProgress() {
            return MiniBillar.GameVars.gameData.statistics.rewards.starProgress;
        }
        static getCueSpriteFrames(cardId) {
            let cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase.type !== "cue") {
                throw "Cannot request sprite data from table card. Check card_data.json";
            }
            if (cardOnDatabase.spriteFrames) {
                return cardOnDatabase.spriteFrames;
            } else {
                return 1;
            }
        }
        static getCueSpriteIntermittent(cardId) {
            let cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase.type !== "cue") {
                throw "Cannot request animation data from table card. Check card_data.json";
            }
            return cardOnDatabase.intermittentAnimation;
        }
        static getTableTunnelColour(cardId) {
            let cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase.type !== "table") {
                throw "Cannot request tunnel colour data from cue card. Check card_data.json";
            }
            if (cardOnDatabase.customTunnelColour) {
                return parseInt(cardOnDatabase.customTunnelColour);
            } else {
                return 0x3A2A3A;
            }
        }
        static getMostLikelyNextCard() {
            let highestCardId = "";
            let highestCardPoints = 0;
            for (let card of MiniBillar.GameVars.gameData.statistics.rewards.cards) {
                if (highestCardPoints <= card.cardPoints) {
                    const cardType = this.getCardType(card.cardName);
                    const typeMax = this.getMaxForCardType(cardType);
                    if (card.cardPoints >= typeMax) {
                        continue;
                    }
                    highestCardId = card.cardName;
                    highestCardPoints = card.cardPoints;
                }
            }
            return {
                cardId: highestCardId,
                cardPoints: highestCardPoints
            };
        }
        static getCardPoints(cardId) {
            const cardOnDatabase = MiniBillar.GameVars.gameData.statistics.rewards.cards.filter(obj => obj.cardName === cardId)[0];
            if (cardOnDatabase) {
                return cardOnDatabase.cardPoints;
            } else {
                throw cardId.toString() + " not found in gameData";
            }
        }
        static getCardType(cardId) {
            const cardOnDatabase = this.cardsJSONData.filter(obj => obj.id === cardId)[0];
            if (cardOnDatabase) {
                return cardOnDatabase.type;
            } else {
                throw cardId + " not found in gameData";
            }
        }
        static getRandomCardIds(requestedCardsCount = 3) {
            let cuesAvailable = [];
            let tablesAvailable = [];
            MiniBillar.GameVars.gameData.statistics.rewards.cards.forEach(cardData => {
                if (RewardsManager.unlockedCards.indexOf(cardData.cardName) < 0) {
                    if (RewardsManager.getCardType(cardData.cardName) === "cue") {
                        if (cardData.cardName !== MiniBillar.GameVars.gameData.playerData.equipedCue) {
                            cuesAvailable.push(cardData.cardName);
                        }
                    } else {
                        if (cardData.cardName !== MiniBillar.GameVars.gameData.equippedTable) {
                            tablesAvailable.push(cardData.cardName);
                        }
                    }
                }
            });
            let selectedCues = new Set();
            while (selectedCues.size < 2 && cuesAvailable.length > 0) {
                const randomIndex = this.game.rnd.integerInRange(0, cuesAvailable.length - 1);
                selectedCues.add(cuesAvailable[randomIndex]);
                cuesAvailable.splice(randomIndex, 1);
            }
            let selectedTables = new Set();
            while (selectedTables.size < 1 && tablesAvailable.length > 0) {
                const randomIndex = this.game.rnd.integerInRange(0, tablesAvailable.length - 1);
                selectedTables.add(tablesAvailable[randomIndex]);
                tablesAvailable.splice(randomIndex, 1);
            }
            return Array.from(selectedCues.values()).concat(Array.from(selectedTables.values()));
        }
        static resetStarCount() {
            MiniBillar.GameVars.gameData.statistics.rewards.starProgress = 0;
        }
        static unlockAllCards() {
            let cardArray = MiniBillar.GameVars.gameData.statistics.rewards.cards;
            cardArray.forEach(card => {
                if (RewardsManager.unlockedCards.indexOf(card.cardName) < 0 &&
                    card.cardName !== MiniBillar.GameVars.gameData.playerData.equipedCue &&
                    card.cardName !== MiniBillar.GameVars.gameData.equippedTable) {
                    const cardType = RewardsManager.getCardType(card.cardName);
                    const progMaxValue = (cardType === "cue") ? MiniBillar.GameConstants.MIN_PTS_UNLOCK_CUE : MiniBillar.GameConstants.MIN_PTS_UNLOCK_TABLE;
                    card.cardPoints = progMaxValue;
                    this.updateUnlockedCardsArray(card.cardName);
                }
            });
            MiniBillar.GameManager.writeGameData();
        }
        static equipTable(cardId) {
            if (RewardsManager.getCardType(cardId) !== "table") {
                throw "Cannot equip cue as table";
            } else {
                MiniBillar.GameVars.gameData.equippedTable = cardId;
            }
        }
        static equipCue(cardId) {
            if (RewardsManager.getCardType(cardId) !== "cue") {
                throw "Cannot equip table as cue";
            } else {
                MiniBillar.GameVars.gameData.playerData.equipedCue = cardId;
            }
        }
        static prepareRewardStats() {
            let victoryData = {
                starUnlocked: 0,
                recentlyUnlockedCardIds: [],
                numberOfCardsUnlocked: []
            };
            if (!MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked) {
                MiniBillar.GameVars.gameData.statistics.rewards.starProgress++;
                const numberOfCardsToUnlock = 3;
                const potentialUnlockableCards = RewardsManager.getRandomCardIds(numberOfCardsToUnlock);
                if (potentialUnlockableCards.length < 1) {
                    MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked = true;
                    MiniBillar.GameManager.enterSplash();
                } else {
                    victoryData.starUnlocked = 1;
                    if (MiniBillar.GameVars.gameData.statistics.rewards.starProgress === 2) {
                        victoryData.starUnlocked = 2;
                    } else if (MiniBillar.GameVars.gameData.statistics.rewards.starProgress === 3) {
                        victoryData.starUnlocked = 3;
                        RewardsManager.resetStarCount();
                        victoryData.recentlyUnlockedCardIds = potentialUnlockableCards;
                        victoryData.numberOfCardsUnlocked = RewardsManager.fillNumberArrayWithIntRange(victoryData.recentlyUnlockedCardIds.length, MiniBillar.GameConstants.MIN_CARDS_WON_AT_A_TIME, MiniBillar.GameConstants.MAX_CARDS_WON_AT_A_TIME);
                        for (let i = 0; i < victoryData.recentlyUnlockedCardIds.length; i++) {
                            RewardsManager.incrementCardPoint(victoryData.recentlyUnlockedCardIds[i], victoryData.numberOfCardsUnlocked[i]);
                        }
                    }
                }
            }
            return victoryData;
        }
        static incrementCardPoint(cardId, incrementValue) {
            let currentPoints = this.getCardPoints(cardId);
            currentPoints += incrementValue;
            const cardType = RewardsManager.getCardType(cardId);
            const progMaxValue = (cardType === "cue") ? MiniBillar.GameConstants.MIN_PTS_UNLOCK_CUE : MiniBillar.GameConstants.MIN_PTS_UNLOCK_TABLE;
            const finalPoints = Math.min(progMaxValue, currentPoints);
            for (let i = 0; i < MiniBillar.GameVars.gameData.statistics.rewards.cards.length; i++) {
                if (MiniBillar.GameVars.gameData.statistics.rewards.cards[i].cardName === cardId) {
                    RewardsManager.setCardPoints(cardId, finalPoints, cardType);
                }
            }
        }
        static initialEquip() {
            let cueFound = false;
            let tableFound = false;
            for (let i = 0; i < this.cardsJSONData.length; i++) {
                if (!cueFound) {
                    if (this.cardsJSONData[i].type === "cue") {
                        RewardsManager.setCardPoints(this.cardsJSONData[i].id, MiniBillar.GameConstants.MIN_PTS_UNLOCK_CUE, "cue");
                        RewardsManager.equipCue(this.cardsJSONData[i].id);
                        cueFound = true;
                    } else {
                        continue;
                    }
                }
                if (!tableFound) {
                    if (this.cardsJSONData[i].type === "table") {
                        RewardsManager.setCardPoints(this.cardsJSONData[i].id, MiniBillar.GameConstants.MIN_PTS_UNLOCK_TABLE, "table");
                        RewardsManager.equipTable(this.cardsJSONData[i].id);
                        tableFound = true;
                    } else {
                        continue;
                    }
                }
            }
            if (!cueFound) {
                throw "No cues present";
            }
            if (!tableFound) {
                throw "No tables present";
            }
        }
        static updateUnlockedCardsArray(cardId) {
            if (RewardsManager.unlockedCards.indexOf(cardId) < 0) {
                RewardsManager.unlockedCards.push(cardId);
            }
        }
        static setCardPoints(cardId, points, cardType) {
            for (let i = 0; i < MiniBillar.GameVars.gameData.statistics.rewards.cards.length; i++) {
                if (MiniBillar.GameVars.gameData.statistics.rewards.cards[i].cardName === cardId) {
                    const cardTypeMax = RewardsManager.getMaxForCardType(cardType);
                    if (points >= cardTypeMax) {
                        MiniBillar.GameVars.gameData.statistics.rewards.cards[i].cardPoints = cardTypeMax;
                        this.updateUnlockedCardsArray(cardId);
                    } else {
                        MiniBillar.GameVars.gameData.statistics.rewards.cards[i].cardPoints = points;
                    }
                    return;
                }
            }
            MiniBillar.GameManager.log("Failed to find " + cardId);
        }
        static updateCardDatabase() {
            let pruneList = [];
            for (let preexistingCards of MiniBillar.GameVars.gameData.statistics.rewards.cards) {
                if (!MiniBillar.Game.currentInstance.cache.getFrameByName("texture_atlas_5", preexistingCards.cardName + ".png")) {
                    MiniBillar.GameManager.log("No art for " + preexistingCards.cardName + ". Removing card from gameData");
                    pruneList.push(preexistingCards);
                }
            }
            for (let ri of pruneList) {
                MiniBillar.GameVars.gameData.statistics.rewards.cards = MiniBillar.GameVars.gameData.statistics.rewards.cards.filter(obj => obj !== ri);
            }
            for (let c of this.cardsJSONData) {
                if (MiniBillar.GameVars.gameData.statistics.rewards.cards.filter(x => x.cardName === (c.id)).length < 1) {
                    if (MiniBillar.Game.currentInstance.cache.getFrameByName("texture_atlas_5", c.id + ".png")) {
                        MiniBillar.GameManager.log("Adding card_" + c.id);
                        MiniBillar.GameVars.gameData.statistics.rewards.cards.push({
                            cardName: c.id,
                            cardPoints: 0
                        });
                    }
                }
            }
        }
        static populateCardDatabase() {
            for (let c of this.cardsJSONData) {
                const cardIdFromJSON = c.id;
                if (MiniBillar.Game.currentInstance.cache.getFrameByName("texture_atlas_5", cardIdFromJSON + ".png")) {
                    MiniBillar.GameManager.log("First time adding card " + c.id);
                    MiniBillar.GameVars.gameData.statistics.rewards.cards.push({
                        cardName: cardIdFromJSON,
                        cardPoints: 0
                    });
                } else {
                    MiniBillar.GameManager.log("No art for card " + cardIdFromJSON);
                }
            }
        }
        static fillNumberArrayWithIntRange(count, min, max) {
            let answer = [];
            for (let i = 0; i < count; i++) {
                answer.push(RewardsManager.game.rnd.integerInRange(min, max));
            }
            return answer;
        }
    }
    MiniBillar.RewardsManager = RewardsManager;
})(MiniBillar || (MiniBillar = {}));
window.onload = () => {
    const game = new MiniBillar.Game();
};
var MiniBillar;
(function(MiniBillar) {
    class Boot extends Phaser.State {
        static onYandexFullscreenChanged() {
            if (!gameConfig) {
                return;
            } else {
                if (gameConfig.GameVersion !== "yandex") {
                    return;
                }
            }
            MiniBillar.Game.currentInstance.scale.setGameSize(screen.width, screen.height);
            MiniBillar.GameVars.gameWidth = screen.width;
            MiniBillar.GameVars.gameHeight = screen.height;
            Boot.onFullScreenChange();
            if (MiniBillar.Game.currentInstance.state.current === "SplashState") {
                MiniBillar.Game.currentInstance.state.restart(false);
            }
        }
        static onFullScreenChange() {
            const aspectRatio = screen.width / screen.height;
            MiniBillar.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = (MiniBillar.GameVars.gameWidth / MiniBillar.GameVars.gameHeight) / aspectRatio;
            if (aspectRatio <= 1.35) {
                MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .75;
            } else if (aspectRatio <= 1.55) {
                MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .8;
            } else if (aspectRatio <= 1.65) {
                MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .9;
            } else {
                MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
            }
            Boot.setScaleMultipliers();
            MiniBillar.Game.currentInstance.scale.refresh();
        }
        static onOrientationChange() {
            if (!Boot.currentInstance) {
                return;
            }
            Boot.currentInstance.game.time.events.add(300, function() {
                if (Boot.currentInstance.bootedInWrongOrientation && window.innerHeight < window.innerWidth) {
                    Boot.currentInstance.game.state.restart(true, false);
                }
            }, this);
        }
        static enterIncorrectOrientation() {
            document.getElementById("orientation").style.display = "block";
            document.getElementById("content").style.display = "none";
        }
        static leaveIncorrectOrientation() {
            document.getElementById("orientation").style.display = "none";
            document.getElementById("content").style.display = "block";
        }
        static onBlur() {
            MiniBillar.Game.currentInstance.sound.mute = true;
        }
        static onFocus() {
            if (!MiniBillar.GameVars.gameData.musicMuted) {
                MiniBillar.Game.currentInstance.sound.mute = false;
            }
        }
        static setScaleMultipliers() {
            MiniBillar.GameVars.scaleXMult = MiniBillar.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT * MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT;
            MiniBillar.GameVars.scaleYMult = MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT;
            MiniBillar.GameVars.scaleXMultInverse = 1 / MiniBillar.GameVars.scaleXMult;
            MiniBillar.GameVars.scaleYMultInverse = 1 / MiniBillar.GameVars.scaleYMult;
            MiniBillar.GameManager.log("scaleX:" + MiniBillar.GameVars.scaleXMult + ", " +
                "scaleY:" + MiniBillar.GameVars.scaleYMult);
        }
        init() {
            Boot.currentInstance = this;
            this.input.maxPointers = 1;
            this.game.stage.backgroundColor = "#05060a";
            this.game.stage.disableVisibilityChange = true;
            this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
            this.game.scale.pageAlignHorizontally = true;
            if (this.game.device.desktop) {
                this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;
                MiniBillar.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = 1;
                MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
                this.game.scale.pageAlignHorizontally = true;
                if (!gameConfig) {
                    return;
                } else {
                    if (gameConfig.GameVersion === "yandex") {
                        window.onresize = Boot.onYandexFullscreenChanged;
                        Boot.onYandexFullscreenChanged();
                    }
                }
            } else {
                this.game.scale.scaleMode = Phaser.ScaleManager.EXACT_FIT;
                if (this.game.scale.compatibility.supportsFullScreen) {
                    this.game.scale.fullScreenScaleMode = Phaser.ScaleManager.EXACT_FIT;
                    this.game.scale.onFullScreenChange.add(Boot.onFullScreenChange, this);
                } else {
                    console.log("Device does not support fullscreen");
                }
                let aspectRatio = window.innerWidth / window.innerHeight;
                this.scale.setMinMax(window.innerWidth, window.innerHeight);
                MiniBillar.GameVars.scaleX_DO_NOT_USE_OUTSIDE_BOOT = (MiniBillar.GameVars.gameWidth / MiniBillar.GameVars.gameHeight) / aspectRatio;
                if (aspectRatio <= 1.35) {
                    MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .75;
                } else if (aspectRatio <= 1.55) {
                    MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .8;
                } else if (aspectRatio <= 1.65) {
                    MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = .9;
                } else {
                    MiniBillar.GameVars.correctionScale_DO_NOT_USE_OUTSIDE_BOOT = 1;
                }
                this.game.scale.pageAlignVertically = true;
                this.game.scale.forceOrientation(true, false);
                this.game.scale.onOrientationChange.add(Boot.onOrientationChange, this);
                this.game.scale.enterIncorrectOrientation.add(Boot.enterIncorrectOrientation, Boot);
                this.game.scale.leaveIncorrectOrientation.add(Boot.leaveIncorrectOrientation, Boot);
                this.bootedInWrongOrientation = window.innerHeight > window.innerWidth ? true : false;
                document.getElementById("ti").onblur = () => {
                    if (MiniBillar.NameInputLayer.currentInstance) {
                        MiniBillar.NameInputLayer.currentInstance.onExitInputFieldMobile();
                        document.getElementById("ti").style.display = "none";
                    }
                };
                document.getElementById("ti").onfocus = () => {
                    if (MiniBillar.NameInputLayer.currentInstance) {
                        const tiElement = document.getElementById("ti");
                        tiElement.value = MiniBillar.NameInputLayer.currentInstance.onEnterInputFieldMobile();
                    }
                };
            }
            ifvisible.on("blur", Boot.onBlur);
            ifvisible.on("focus", Boot.onFocus);
            Boot.setScaleMultipliers();
            if (MiniBillar.GameConstants.DEVELOPMENT) {
                this.game.time.advancedTiming = true;
            }
        }
        preload() {
            this.load.path = MiniBillar.GameConstants.ASSETS_PATH;
            this.load.crossOrigin = "anonymous";
            this.load.image("preload_background", "/preload_background.jpg");
            this.load.image("preload_cue", "/preload-cue.png");
            this.load.image("preload_cue_ball", "/preload-cue-ball.png");
        }
        create() {
            if (!this.game.device.desktop && this.bootedInWrongOrientation) {
                return;
            }
            MiniBillar.GameManager.init(this.game);
            this.game.add.plugin(new PhaserInput.Plugin(this.game, this.game.plugins));
        }
        shutdown() {
            Boot.currentInstance = null;
            super.shutdown();
        }
    }
    MiniBillar.Boot = Boot;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class SwitchButton extends Phaser.Group {
        constructor(game, isOn, typeSwitch) {
            super(game, null, "switch-button");
            this.isOn = isOn;
            this.typeSwitch = typeSwitch;
            const button = new Phaser.Button(this.game, 0, 0, "texture_atlas_1", this.onDown, this);
            button.anchor.set(.5);
            this.add(button);
            if (this.isOn) {
                button.setFrames("btn_switch_on_on.png", "btn_switch_on_off.png", "btn_switch_on_on.png", "btn_switch_on_off.png");
            } else {
                button.setFrames("btn_switch_off_on.png", "btn_switch_off_off.png", "btn_switch_off_on.png", "btn_switch_off_off.png");
            }
        }
        onDown(button) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            this.isOn = !this.isOn;
            if (this.isOn) {
                button.setFrames("btn_switch_on_on.png", "btn_switch_on_off.png", "btn_switch_on_on.png", "btn_switch_on_off.png");
            } else {
                button.setFrames("btn_switch_off_on.png", "btn_switch_off_off.png", "btn_switch_off_on.png", "btn_switch_off_off.png");
            }
            if (this.typeSwitch === SwitchButton.MUSIC) {
                MiniBillar.AudioManager.switchAudio();
            } else if (this.typeSwitch === SwitchButton.POWER) {
                MiniBillar.GameManager.changePowerBar();
            }
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
    }
    SwitchButton.MUSIC = "music";
    SwitchButton.POWER = "power";
    MiniBillar.SwitchButton = SwitchButton;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class EquipmentState extends Phaser.State {
        init() {
            EquipmentState.currentInstance = this;
        }
        create() {
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "texture_atlas_2", "lobby.png");
            background.anchor.set(.5);
            background.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / background.height);
            this.railContainer = this.add.group();
            const tablesLabel = this.add.image(MiniBillar.GameVars.gameWidth * 0.5 + 4 * MiniBillar.GameVars.scaleXMult, 16, "texture_atlas_1", "tables_cues_text.png");
            tablesLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            tablesLabel.anchor.set(.5, 0);
            const buttonBack = this.add.button(38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickBack, this);
            buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
            buttonBack.forceOut = true;
            if (this.game.device.touch) {
                buttonBack.onInputDown.add(function() {
                    buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
                }, this);
            }
            buttonBack.onInputOver.add(function() {
                buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
            }, this);
            buttonBack.onInputOut.add(function() {
                buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonBack.anchor.set(0.5);
            buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            if (MiniBillar.GameConstants.DEVELOPMENT && !MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked) {
                const buttonUnlock = this.add.button(MiniBillar.GameVars.gameWidth - 10 * MiniBillar.GameVars.scaleXMult, 10 * MiniBillar.GameVars.scaleYMult, "texture_atlas_0", this.onClickUnlock, this);
                buttonUnlock.forceOut = true;
                buttonUnlock.anchor.set(1, 0);
                buttonUnlock.setFrames("btn_unlock_on.png", "btn_unlock_off.png", "btn_unlock_on.png");
                buttonUnlock.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }
            const cardsData = this.game.cache.getJSON("card-data");
            let cardsInJSON = cardsData;
            this.cueRail = this.createRail(505, cardsInJSON, "cue");
            this.tableRail = this.createRail(236, cardsInJSON, "table");
            if (!this.cueRail || !this.tableRail) {
                throw "Error creating rails";
            }
            this.scrollToEquippedCards();
            this.game.input.onDown.add(this.startSwipe, this);
            this.game.input.onUp.add(this.endSwipe, this);
            this.clearSwipe();
            this.game.camera.flash(0x000000, 350, false);
        }
        update() {
            if (this.swiping) {
                const currentPointerPos = this.game.input.activePointer.position;
                let xDelta = this.swipeStartPosX - currentPointerPos.x;
                let swipeProgress = xDelta / MiniBillar.GameConstants.MIN_SWIPE_CHANGE_DISTANCE;
                swipeProgress = Phaser.Math.clamp(swipeProgress, -.999, .999);
                if (this.swipingCueRail) {
                    this.cueRail.scrollPreview(swipeProgress);
                } else {
                    this.tableRail.scrollPreview(swipeProgress);
                }
            }
            super.update();
        }
        shutdown() {
            EquipmentState.currentInstance = null;
            super.shutdown();
        }
        scrollToEquippedCards() {
            let stepsToScrollTable = 0;
            for (let i = 0; i < this.tableRail.cardArray.length; i++) {
                const card = this.tableRail.cardArray[i];
                if (card.cardType !== "table") {
                    continue;
                }
                if (card.cardId === MiniBillar.GameVars.gameData.equippedTable) {
                    stepsToScrollTable = i;
                    break;
                }
            }
            this.tableRail.scrollStepped(stepsToScrollTable - 2, false);
            let stepsToScrollCard = 0;
            for (let i = 0; i < this.cueRail.cardArray.length; i++) {
                const card = this.cueRail.cardArray[i];
                if (card.cardType !== "cue") {
                    continue;
                }
                if (card.cardId === MiniBillar.GameVars.gameData.playerData.equipedCue) {
                    stepsToScrollCard = i;
                    break;
                }
            }
            this.cueRail.scrollStepped(stepsToScrollCard - 2, false);
        }
        createRail(y, cardsInJSON, type) {
            const cueCards = cardsInJSON.filter(obj => obj.type === type);
            let railObject;
            if (type === "cue") {
                railObject = new MiniBillar.Rail(this.game, cueCards, type);
            } else {
                railObject = new MiniBillar.Rail(this.game, cueCards, type);
            }
            railObject.y = y;
            this.railContainer.add(railObject);
            return railObject;
        }
        onClickBack() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.enterSplash();
        }
        onClickUnlock(b) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked = true;
            MiniBillar.RewardsManager.unlockAllCards();
            MiniBillar.GameManager.enterEquipment();
            b.visible = false;
        }
        startSwipe() {
            this.clearSwipe();
            if (this.game.input.activePointer.position.y > 110) {
                this.swipingCueRail = this.game.input.activePointer.position.y > 370;
                if (this.swipingCueRail && this.cueRail.tweening) {
                    return;
                } else if (!this.swipingCueRail && this.tableRail.tweening) {
                    return;
                }
                this.swipeStartPosX = this.game.input.activePointer.position.x;
                this.swiping = true;
            }
        }
        endSwipe() {
            if (!this.swiping) {
                return;
            }
            const currentPointerPos = this.game.input.activePointer.position;
            let xDelta = this.swipeStartPosX - currentPointerPos.x;
            let swipeProgress = xDelta / MiniBillar.GameConstants.MIN_SWIPE_CHANGE_DISTANCE;
            swipeProgress = Phaser.Math.clamp(swipeProgress, -1, 1);
            swipeProgress = Math.round(swipeProgress);
            if (this.swipingCueRail) {
                this.cueRail.scrollStepped(swipeProgress);
            } else {
                this.tableRail.scrollStepped(swipeProgress);
            }
            this.clearSwipe();
        }
        clearSwipe() {
            this.swipingCueRail = true;
            this.swiping = false;
            this.swipeStartPosX = null;
        }
    }
    MiniBillar.EquipmentState = EquipmentState;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class Rail extends Phaser.Group {
        constructor(game, cards, railType) {
            super(game, null, "rail");
            this.railSocketWidth = 0;
            this.tweening = false;
            this.cardArray = [];
            const cardsScale = 0.8;
            this.railWidth = 0;
            this.borderWidth = 25;
            this.x = this.borderWidth;
            this.originalPreviewXPos = null;
            this.lastPreviewXProgress = 0;
            let i = 0;
            for (let card of cards) {
                let rewardCard = new MiniBillar.RewardCard(this.game, 0, 0, card.id, MiniBillar.RewardsManager.getCardPoints(card.id), false, true);
                rewardCard.setParentRail(this);
                rewardCard.scale.x *= cardsScale;
                rewardCard.scale.y *= cardsScale;
                this.railSocketWidth = rewardCard.width;
                rewardCard.x = i * this.railSocketWidth + (this.railSocketWidth * 0.5);
                this.railWidth += this.railSocketWidth;
                this.add(rewardCard);
                this.cardArray.push(rewardCard);
                this.bringToTop(rewardCard);
                i++;
            }
        }
        scrollStepped(steps, useTween = true) {
            if (this.tweening) {
                return;
            }
            this.tweening = true;
            const diff = steps - this.lastPreviewXProgress;
            steps = diff;
            let px = this.x - (this.railSocketWidth * steps);
            this.originalPreviewXPos = null;
            const maxX = this.borderWidth;
            const minX = -(this.railWidth - (MiniBillar.GameVars.gameWidth - this.borderWidth));
            let reachedEdge = false;
            if (steps < 0) {
                if (px >= maxX) {
                    reachedEdge = true;
                    px = maxX;
                }
            } else {
                if (px <= minX) {
                    reachedEdge = true;
                    px = minX;
                }
            }
            if (useTween) {
                this.game.add.tween(this)
                    .to({
                        x: px
                    }, Math.abs(diff) < 0.1 ? reachedEdge ? 650 : 10 : 650, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        this.tweening = false;
                    }, this);
            } else {
                this.x = px;
                this.tweening = false;
            }
            this.lastPreviewXProgress = 0;
        }
        scrollPreview(distance) {
            if (this.tweening) {
                return;
            }
            if (!this.originalPreviewXPos) {
                this.originalPreviewXPos = this.x;
            }
            let px = this.originalPreviewXPos - (this.railSocketWidth * distance);
            this.lastPreviewXProgress = distance;
            this.x = px;
        }
    }
    MiniBillar.Rail = Rail;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class LobbyState extends Phaser.State {
        init() {
            LobbyState.currentInstance = this;
            this.f = 0;
            this.leavingScene = false;
        }
        create() {
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "texture_atlas_2", "lobby.png");
            background.anchor.set(.5);
            background.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / background.height);
            this.lookingForPlayerContainer = this.game.add.group();
            this.buttonBack = new Phaser.Button(this.game, 38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickExitLobby, this);
            this.buttonBack.anchor.set(.5);
            if (this.game.device.touch) {
                this.buttonBack.onInputDown.add(function() {
                    this.buttonBack.scale.set(this.buttonBack.scale.x * 1.1, this.buttonBack.scale.y * 1.1);
                }, this);
            }
            this.buttonBack.onInputOver.add(function() {
                this.buttonBack.scale.set(this.buttonBack.scale.x * 1.1, this.buttonBack.scale.y * 1.1);
            }, this);
            this.buttonBack.onInputOut.add(function() {
                this.buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            this.buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
            this.buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(this.buttonBack);
            this.titleLabel = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth / 2, 420, "WAITING FOR A RIVAL", {
                font: "30px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8",
                align: "center"
            });
            this.titleLabel.anchor.x = .5;
            this.titleLabel.stroke = "#2f3237";
            this.titleLabel.strokeThickness = 5;
            this.titleLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(this.titleLabel);
            this.waitingAnimContainer = this.game.add.group();
            this.waitingAnimContainer.position.set(MiniBillar.GameVars.gameWidth / 2, 360);
            this.waitingAnimContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(this.waitingAnimContainer);
            this.waitingAnim = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "loading_circle.png");
            this.waitingAnim.anchor.set(.5);
            this.waitingAnimContainer.add(this.waitingAnim);
            this.playerAvatar = new MiniBillar.AvatarBubble(this.game, MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameWidth / 2 - 150, 250, false);
            this.playerAvatar.visible = false;
            this.playerAvatar.scale.x *= 2 * MiniBillar.GameVars.scaleXMult;
            this.playerAvatar.scale.y *= 2 * MiniBillar.GameVars.scaleYMult;
            this.add.existing(this.playerAvatar);
            this.lookingForPlayerContainer.add(this.playerAvatar);
            this.adversaryAvatar = new MiniBillar.AvatarBubble(this.game, MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameWidth / 2 + 150, 250, false);
            this.adversaryAvatar.visible = false;
            this.adversaryAvatar.scale.x *= 2 * MiniBillar.GameVars.scaleXMult;
            this.adversaryAvatar.scale.y *= 2 * MiniBillar.GameVars.scaleYMult;
            this.add.existing(this.adversaryAvatar);
            this.lookingForPlayerContainer.add(this.adversaryAvatar);
            this.playerNick = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth / 2 - 150, 340, "", {
                font: "26px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8",
                align: "center"
            });
            this.playerNick.anchor.x = .5;
            this.playerNick.visible = false;
            this.playerNick.stroke = "#2f3237";
            this.playerNick.strokeThickness = 5;
            this.playerNick.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(this.playerNick);
            this.adversaryNick = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth / 2 + 150, 340, "", {
                font: "26px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8",
                align: "center"
            });
            this.adversaryNick.anchor.x = .5;
            this.adversaryNick.visible = false;
            this.adversaryNick.stroke = "#2f3237";
            this.adversaryNick.strokeThickness = 5;
            this.adversaryNick.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(this.adversaryNick);
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                this.roomIdLabel = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth / 2, 120, "", {
                    font: "20px Oswald-DemiBold",
                    fontWeight: "600",
                    fill: "#e7f6f8",
                    align: "center"
                });
                this.roomIdLabel.anchor.x = .5;
                this.roomIdLabel.stroke = "#2f3237";
                this.roomIdLabel.strokeThickness = 5;
                this.roomIdLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.lookingForPlayerContainer.add(this.roomIdLabel);
            }
        }
        update() {
            super.update();
            if (this.waitingAnim) {
                this.waitingAnim.angle += 5;
            }
            this.f++;
            if (this.f === 120 && !this.playerAvatar.visible) {
                MiniBillar.GameManager.setupBotMatchData();
                this.fakePlayerFound();
            }
        }
        shutdown() {
            LobbyState.currentInstance = null;
            super.shutdown();
        }
        onPlayerJoined() {
            if (this.roomIdLabel) {
                this.roomIdLabel.text = "ROOM ID: " + Communication.CommunicationManager.room.id;
            }
            this.playerAvatar.visible = true;
            this.playerAvatar.setFrameName(MiniBillar.GameVars.gameData.playerData.avatar + ".png");
            this.playerNick.text = MiniBillar.GameVars.gameData.playerData.nick;
            this.playerNick.visible = true;
            if (MiniBillar.GameVars.adversaryData) {
                this.adversaryAvatar.visible = true;
                const avatarFileName = MiniBillar.GameVars.adversaryData.avatar + ".png";
                this.adversaryAvatar.setFrameName(avatarFileName);
                this.adversaryNick.text = MiniBillar.GameVars.adversaryData.nick;
                this.adversaryNick.visible = true;
            }
            if (this.playerAvatar.visible && this.adversaryAvatar.visible) {
                this.adversaryFound();
            }
        }
        setPlayers() {
            const darkLayer = this.add.sprite(0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLACK_SQUARE));
            darkLayer.scale.set(MiniBillar.GameVars.gameWidth / MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameVars.gameHeight / MiniBillar.GameConstants.BITMAP_SIZE);
            darkLayer.alpha = .7;
            const matchedLabel = this.add.text(MiniBillar.GameVars.gameWidth / 2, 400, "MATCHED, GAME STARTS!", {
                font: "50px Oswald-DemiBold",
                fill: "#E5FFFF"
            });
            matchedLabel.anchor.set(.5);
        }
        fakePlayerFound() {
            if (this.leavingScene) {
                return;
            }
            this.leavingScene = true;
            this.adversaryAvatar.visible = true;
            const avatarFileName = MiniBillar.GameVars.adversaryData.avatar + ".png";
            this.adversaryAvatar.setFrameName(avatarFileName);
            this.adversaryNick.text = MiniBillar.GameVars.adversaryData.nick;
            this.adversaryNick.visible = true;
            if (!this.playerAvatar.visible) {
                this.playerAvatar.visible = true;
                this.playerAvatar.setFrameName(MiniBillar.GameVars.gameData.playerData.avatar + ".png");
                this.playerNick.text = MiniBillar.GameVars.gameData.playerData.nick;
                this.playerNick.visible = true;
            }
            if (this.playerAvatar.visible && this.adversaryAvatar.visible) {
                this.adversaryFound();
            }
            this.game.time.events.add(Phaser.Timer.SECOND, function() {
                MiniBillar.GameManager.enterPVBotGame();
            }, MiniBillar.GameManager);
        }
        onClickExitLobby(b) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.exitLobby();
        }
        adversaryFound() {
            this.buttonBack.visible = false;
            this.waitingAnim.visible = false;
            this.titleLabel.visible = false;
            const vs = new Phaser.Image(this.game, MiniBillar.GameVars.gameWidth / 2, 250, "texture_atlas_1", "vs.png");
            vs.anchor.set(.5);
            vs.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.lookingForPlayerContainer.add(vs);
            this.game.add.tween(vs.scale)
                .from({
                    x: .01,
                    y: .01
                }, 400, Phaser.Easing.Elastic.Out, true);
        }
    }
    MiniBillar.LobbyState = LobbyState;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class Avatar extends Phaser.Group {
        constructor(game, avatarName) {
            super(game, null, "avatar");
            avatarName = avatarName || "billar_m01";
            this.name = avatarName;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.button = new Phaser.Button(this.game, 0, 0, "texture_atlas_1", this.onDown, this);
            this.button.input.pixelPerfectClick = true;
            this.button.input.pixelPerfectOver = true;
            this.button.input.pixelPerfectAlpha = 0.5;
            this.button.anchor.set(.5);
            this.button.setFrames("btn_avatar_unselected_on.png", "btn_avatar_unselected_off.png", "btn_avatar_unselected_on.png", "btn_avatar_unselected_off.png");
            this.add(this.button);
            this.selectionRing = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "avatar_unselected_frame.png");
            this.selectionRing.anchor.set(.5);
            this.add(this.selectionRing);
            const avatar = new Phaser.Image(this.game, 0, 0, "texture_atlas_5", avatarName + ".png");
            avatar.anchor.set(.5, .325);
            avatar.scale.set(.7);
            this.add(avatar);
            const mask = new Phaser.Graphics(this.game);
            mask.beginFill(0xFFFFFF);
            mask.drawCircle(0, 0, 130);
            this.add(mask);
            avatar.mask = mask;
        }
        deselect() {
            this.button.setFrames("btn_avatar_unselected_on.png", "btn_avatar_unselected_off.png", "btn_avatar_unselected_on.png", "btn_avatar_unselected_off.png");
            this.selectionRing.frameName = "avatar_unselected_frame.png";
        }
        select() {
            MiniBillar.PlayerRegisteringState.currentInstance.currentlySelectedAvatar = this;
            MiniBillar.GameManager.avatarSelected(this.name);
            this.button.setFrames("btn_avatar_selected.png", "btn_avatar_selected.png", "btn_avatar_selected.png", "btn_avatar_selected.png");
            this.selectionRing.frameName = "avatar_selected_frame.png";
        }
        onDown() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            if (MiniBillar.PlayerRegisteringState.currentInstance.currentlySelectedAvatar) {
                if (MiniBillar.PlayerRegisteringState.currentInstance.currentlySelectedAvatar !== this) {
                    MiniBillar.PlayerRegisteringState.currentInstance.currentlySelectedAvatar.deselect();
                    this.select();
                }
            }
        }
    }
    MiniBillar.Avatar = Avatar;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class AvatarFullBodyContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "avatar-full-body-container");
            this.x = Math.min(MiniBillar.GameVars.gameWidth / 4, (MiniBillar.GameVars.gameWidth / 2 - 380 * MiniBillar.GameVars.scaleXMult));
            this.y = 600;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.fullBodyAvatar = new Phaser.Image(this.game, 0, 0, "texture_atlas_5", MiniBillar.GameVars.gameData.playerData.avatar + ".png");
            this.fullBodyAvatar.anchor.set(.5, 1);
            this.add(this.fullBodyAvatar);
            this.lastValidPlayerName = MiniBillar.GameVars.gameData.playerData.nick;
            const nameEditButton = new Phaser.Button(this.game, 0, 0, "texture_atlas_1");
            nameEditButton.setFrames("btn_edit_avatar_on.png", "btn_edit_avatar_off.png", "btn_edit_avatar_on.png", "btn_edit_avatar_off.png");
            nameEditButton.anchor.set(.5);
            if (this.game.device.touch) {
                nameEditButton.onInputDown.add(function() {
                    nameEditButton.scale.set(nameEditButton.scale.x * 1.1, nameEditButton.scale.y * 1.1);
                }, this);
            }
            nameEditButton.onInputOver.add(function() {
                nameEditButton.scale.set(nameEditButton.scale.x * 1.1, nameEditButton.scale.y * 1.1);
            }, this);
            nameEditButton.onInputOut.add(function() {
                nameEditButton.scale.set(1);
            }, this);
            this.add(nameEditButton);
            const nameInputLine = new Phaser.Graphics(this.game, 0, 0);
            nameInputLine.lineStyle(4, 0xE5FFFF, 1);
            this.add(nameInputLine);
            let nameInputLinePos;
            if (this.game.device.touch) {
                this.fakeNameInput = new Phaser.Text(this.game, -105, -this.fullBodyAvatar.height - 45, this.lastValidPlayerName, {
                    font: "30px Oswald-Medium",
                    fill: "#E5FFFF"
                });
                this.fakeNameInput.inputEnabled = true;
                this.fakeNameInput.events.onInputUp.add(function() {
                    MiniBillar.PlayerRegisteringState.currentInstance.showNameInputLayer();
                }, this);
                this.fakeNameInput.setText(MiniBillar.Utils.truncateName(this.lastValidPlayerName, 12));
                this.add(this.fakeNameInput);
                nameInputLinePos = this.fakeNameInput.position;
                nameEditButton.events.onInputUp.add(function() {
                    MiniBillar.PlayerRegisteringState.currentInstance.showNameInputLayer();
                    nameEditButton.scale.set(1);
                }, this);
            } else {
                this.nameInput = new PhaserInput.InputField(this.game, -105, -this.fullBodyAvatar.height - 45, {
                    font: "30px Oswald-Medium",
                    fill: "#E5FFFF",
                    cursorColor: "#E5FFFF",
                    fillAlpha: 0,
                    width: 180,
                    max: "20",
                });
                this.nameInput.setText(MiniBillar.GameVars.gameData.playerData.nick);
                this.nameInput.focusIn.add(this.onEnterInputField, this);
                this.nameInput.focusOut.add(this.onExitInputField, this);
                this.add(this.nameInput);
                nameInputLinePos = this.nameInput.position;
                nameEditButton.events.onInputUp.add(function() {
                    this.nameInput.startFocus();
                    nameEditButton.scale.set(1);
                }, this);
            }
            nameInputLine.moveTo(nameInputLinePos.x - 15, nameInputLinePos.y + 40);
            nameInputLine.lineTo(nameInputLinePos.x + 180, nameInputLinePos.y + 40);
            nameEditButton.position.set(nameInputLinePos.x + 200, nameInputLinePos.y + 25);
        }
        avatarSelected() {
            this.fullBodyAvatar.frameName = MiniBillar.GameVars.gameData.playerData.avatar + ".png";
        }
        updateDisplayedName() {
            this.fakeNameInput.text = MiniBillar.Utils.truncateName(MiniBillar.GameVars.gameData.playerData.nick, 12);
        }
        onEnterInputField(inputField) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            this.lastValidPlayerName = MiniBillar.GameVars.gameData.playerData.nick;
        }
        onExitInputField() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            if (this.nameInput.value.length > 0) {
                MiniBillar.GameVars.gameData.playerData.nick = this.nameInput.value;
                MiniBillar.GameManager.writeGameData();
            } else {
                this.nameInput.setText(this.lastValidPlayerName);
            }
        }
    }
    MiniBillar.AvatarFullBodyContainer = AvatarFullBodyContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class NameInputLayer extends Phaser.Group {
        constructor(game, lastValidPlayerName) {
            super(game, null, "name-input-layer-container");
            NameInputLayer.currentInstance = this;
            this.lastValidPlayerName = lastValidPlayerName;
            let transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .8;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputUp.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            document.getElementById("ti").style.display = "block";
            const tiElement = document.getElementById("ti");
            this.game.time.events.add(0.15 * Phaser.Timer.SECOND, function() {
                tiElement.focus();
            }, this);
        }
        onExitInputFieldMobile() {
            const tiElement = document.getElementById("ti");
            const newNick = tiElement.value;
            if (newNick.length > 0 && newNick.length < 25) {
                MiniBillar.GameVars.gameData.playerData.nick = newNick;
                MiniBillar.GameManager.writeGameData();
            }
            MiniBillar.PlayerRegisteringState.currentInstance.updateDisplayedName();
            MiniBillar.PlayerRegisteringState.currentInstance.hideNameInputLayer();
        }
        onEnterInputFieldMobile() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            this.lastValidPlayerName = MiniBillar.GameVars.gameData.playerData.nick;
            return this.lastValidPlayerName;
        }
        onDownTransparentLayer() {
            const tiElement = document.getElementById("ti");
            this.game.time.events.add(0.15 * Phaser.Timer.SECOND, function() {
                tiElement.blur();
            }, this);
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.PlayerRegisteringState.currentInstance.updateDisplayedName();
            MiniBillar.PlayerRegisteringState.currentInstance.hideNameInputLayer();
        }
    }
    MiniBillar.NameInputLayer = NameInputLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PlayerRegisteringState extends Phaser.State {
        init() {
            PlayerRegisteringState.currentInstance = this;
            this.tweening = false;
        }
        create() {
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "texture_atlas_2", "lobby.png");
            background.anchor.set(.5);
            background.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / background.height);
            this.avatarsContainer = this.add.group();
            this.avatarsContainer.x = MiniBillar.GameVars.gameWidth / 2 - 160 * MiniBillar.GameVars.scaleXMult;
            this.avatarsContainer.y = 190;
            let startScrolledDown = false;
            let selectedAvatar;
            for (let i = 0; i < 4; i++) {
                for (let j = 0; j < 4; j++) {
                    let avatarName;
                    let index = (i + 1) + 4 * j;
                    if (index % 2 === 0) {
                        avatarName = "billar_w0" + Math.round(index / 2);
                    } else {
                        avatarName = "billar_m0" + Math.round(index / 2);
                    }
                    let avatar = new MiniBillar.Avatar(this.game, avatarName);
                    avatar.x = 170 * i * MiniBillar.GameVars.scaleXMult;
                    avatar.y = 170 * j;
                    if (MiniBillar.GameVars.gameData.playerData.avatar === avatarName) {
                        if (j > 2) {
                            startScrolledDown = true;
                        }
                        selectedAvatar = avatar;
                    }
                    this.avatarsContainer.add(avatar);
                }
            }
            const titleMask = this.add.image(MiniBillar.GameVars.gameWidth / 2, 0, "texture_atlas_1", "title_mask.png");
            titleMask.anchor.set(.5, 0);
            titleMask.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / background.height);
            const avatarSettingTitle = this.add.image(MiniBillar.GameVars.gameWidth / 2, 0, "texture_atlas_1", "avatar_settings_title.png");
            avatarSettingTitle.anchor.set(.5, 0);
            avatarSettingTitle.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            const buttonBack = new Phaser.Button(this.game, 38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickBack, this);
            buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            buttonBack.anchor.set(.5);
            if (this.game.device.touch) {
                buttonBack.onInputDown.add(function() {
                    buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
                }, this);
            }
            buttonBack.onInputOver.add(function() {
                buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
            }, this);
            buttonBack.onInputOut.add(function() {
                buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
            buttonBack.forceOut = true;
            this.add.existing(buttonBack);
            if (startScrolledDown) {
                this.avatarsContainer.y = PlayerRegisteringState.AVATARS_CONTAINER_PY_2;
            }
            this.avatarFullBodyContainer = new MiniBillar.AvatarFullBodyContainer(this.game);
            this.add.existing(this.avatarFullBodyContainer);
            selectedAvatar.select();
            this.originalPreviewYPos = this.avatarsContainer.y;
            this.game.input.onDown.add(this.startSwipe, this);
            this.game.input.onUp.add(this.endSwipe, this);
            this.originalPreviewYPos = null;
            this.lastPreviewYProgress = 0;
            this.clearSwipe();
            this.game.camera.flash(0x000000, 350, false);
        }
        update() {
            if (this.swiping) {
                const currentPointerPos = this.game.input.activePointer.position;
                let yDelta = this.swipeStartPosY - currentPointerPos.y;
                let swipeProgress = yDelta / MiniBillar.GameConstants.MIN_SWIPE_CHANGE_DISTANCE;
                swipeProgress = Phaser.Math.clamp(swipeProgress, -.999, .999);
                this.scrollPreview(swipeProgress);
            }
            super.update();
        }
        shutdown() {
            PlayerRegisteringState.currentInstance = null;
            super.shutdown();
        }
        avatarSelected() {
            this.avatarFullBodyContainer.avatarSelected();
        }
        updateDisplayedName() {
            this.avatarFullBodyContainer.updateDisplayedName();
        }
        showNameInputLayer() {
            this.nameInputLayer = new MiniBillar.NameInputLayer(this.game, MiniBillar.GameVars.gameData.playerData.nick);
            this.add.existing(this.nameInputLayer);
        }
        hideNameInputLayer() {
            if (this.nameInputLayer) {
                this.nameInputLayer.destroy();
                this.nameInputLayer = null;
            }
        }
        onClickBack() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.fullscreenFilter(MiniBillar.GameManager.enterSplash);
        }
        startSwipe() {
            this.clearSwipe();
            if (this.game.input.activePointer.position.x > 120) {
                if (this.tweening) {
                    return;
                }
                this.swipeStartPosY = this.game.input.activePointer.position.y;
                this.swiping = true;
            }
        }
        endSwipe() {
            if (!this.swiping) {
                return;
            }
            const currentPointerPos = this.game.input.activePointer.position;
            let yDelta = this.swipeStartPosY - currentPointerPos.y;
            let swipeProgress = yDelta / MiniBillar.GameConstants.MIN_SWIPE_CHANGE_DISTANCE;
            swipeProgress = Phaser.Math.clamp(swipeProgress, -1, 1);
            swipeProgress = Math.round(swipeProgress);
            this.scrollStepped(swipeProgress);
            this.clearSwipe();
        }
        clearSwipe() {
            this.swiping = false;
            this.swipeStartPosY = null;
            this.originalPreviewYPos = null;
        }
        scrollStepped(steps) {
            if (this.tweening) {
                return;
            }
            this.tweening = true;
            const diff = steps;
            steps = -Math.round(this.lastPreviewYProgress);
            if (steps > 0) {
                this.game.add.tween(this.avatarsContainer)
                    .to({
                        y: 190
                    }, Math.abs(diff) < 0.1 ? 50 : 650, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        this.tweening = false;
                    }, this);
            } else if (steps < 0) {
                this.game.add.tween(this.avatarsContainer)
                    .to({
                        y: 0
                    }, Math.abs(diff) < 0.1 ? 50 : 650, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        this.tweening = false;
                    }, this);
            } else {
                this.game.add.tween(this.avatarsContainer)
                    .to({
                        y: this.originalPreviewYPos
                    }, Math.abs(diff) < 0.1 ? 50 : 650, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        this.tweening = false;
                    }, this);
            }
            this.lastPreviewYProgress = 0;
            return;
        }
        scrollPreview(distance) {
            if (this.tweening) {
                return;
            }
            if (!this.originalPreviewYPos) {
                this.originalPreviewYPos = this.avatarsContainer.y;
            }
            let py = this.originalPreviewYPos - (PlayerRegisteringState.STEP_DISTANCE * distance);
            this.lastPreviewYProgress = distance;
            this.avatarsContainer.y = py;
        }
    }
    PlayerRegisteringState.STEP_DISTANCE = 190;
    PlayerRegisteringState.AVATARS_CONTAINER_PY_2 = 0;
    MiniBillar.PlayerRegisteringState = PlayerRegisteringState;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class AnimatedStarBox extends Phaser.Group {
        constructor(game, useFixedTexture) {
            super(game, null, "animated-star-box");
            this.starsDistBetween = 60;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.boxContainerImage = new Phaser.Image(game, 0, 0, "texture_atlas_1", useFixedTexture ? "box_stars_fixed.png" : "box_stars.png");
            this.boxContainerImage.anchor.set(.5);
            this.add(this.boxContainerImage);
            this.starImages = [];
            if (useFixedTexture) {
                this.createStarsSmallVersion(-26, 0, "star_void.png");
            } else {
                this.createStars(-15, 0, "star_void.png");
            }
            if (!useFixedTexture) {
                this.giftBox = new MiniBillar.GiftBox(game, 120, 25);
                this.add(this.giftBox);
            }
        }
        setStarActive(star) {
            this.starImages[star].frameName = "star_full.png";
            this.starImages[star].visible = true;
        }
        animateStarToFullScale(index) {
            this.starImages[index].frameName = "star_full.png";
            this.starImages[index].scale.set(0);
            this.game.add.tween(this.starImages[index].scale)
                .to({
                    x: 1,
                    y: 1
                }, 500, Phaser.Easing.Elastic.Out, true, 500);
            this.game.time.events.add(Phaser.Timer.SECOND * .75, function() {
                const sparkleSprite = new Phaser.Sprite(this.game, this.starImages[index].x, this.starImages[index].y, "texture_atlas_1");
                sparkleSprite.anchor.set(0.5);
                const sparkleFrames = MiniBillar.Utils.createAnimFramesArr("sparkle_effect", 14, false, 0, 15);
                sparkleSprite.animations.add("sparkle", sparkleFrames).play(24, false, true);
                this.add(sparkleSprite);
                this.swapChildren(sparkleSprite, this.starImages[index]);
            }, this);
        }
        animateGiftBox() {
            let rattleFrame = 0;
            const rattleFPS = 0.6;
            this.game.add.tween(this.giftBox)
                .to({
                    angle: 0
                }, 750, Phaser.Easing.Elastic.Out, true)
                .onUpdateCallback(function() {
                    rattleFrame += rattleFPS;
                    let s = Math.sin(rattleFrame);
                    const rattleAngle = 10;
                    this.giftBox.angle = s * rattleAngle;
                }, this)
                .onComplete.add(function() {
                    this.game.add.tween(this.giftBox.scale)
                        .to({
                            x: 1,
                            y: 1
                        }, 750, Phaser.Easing.Cubic.Out, true);
                    this.fadeOutStarsBox();
                    this.game.add.tween(this.giftBox)
                        .to({
                            x: this.giftBox.x - 120,
                            y: this.giftBox.y - 120
                        }, 750, Phaser.Easing.Cubic.Out, true)
                        .onComplete.add(function() {
                            this.giftBox.openGiftBox();
                        }, this);
                }, this);
        }
        createStars(x, y, imageName) {
            for (let i = 0; i < 3; i++) {
                const boxContainerImage = new Phaser.Image(this.game, x + this.starsDistBetween * (i - 1), y, "texture_atlas_1", imageName);
                boxContainerImage.anchor.set(0.5);
                this.starImages.push(boxContainerImage);
                this.add(this.starImages[i]);
            }
        }
        fadeOutStarsBox() {
            for (let i = 0; i < this.starImages.length; i++) {
                this.game.add.tween(this.starImages[i])
                    .to({
                        alpha: 0
                    }, 750, Phaser.Easing.Cubic.Out, true);
            }
            this.game.add.tween(this.boxContainerImage)
                .to({
                    alpha: 0
                }, 750, Phaser.Easing.Cubic.Out, true);
        }
        createStarsSmallVersion(x, y, imageName) {
            this.starsDistBetween = 34;
            for (let i = 0; i < 3; i++) {
                const boxContainerImage = new Phaser.Image(this.game, x + this.starsDistBetween * (i - 1), y, "texture_atlas_1", imageName);
                boxContainerImage.anchor.set(0.5);
                boxContainerImage.scale.set(0.6);
                boxContainerImage.visible = false;
                this.starImages.push(boxContainerImage);
                this.add(this.starImages[i]);
            }
        }
    }
    MiniBillar.AnimatedStarBox = AnimatedStarBox;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class CueContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "cue-container");
            CueContainer.currentInstance = this;
            this.settingPower = false;
            this.angle = 180;
            this.lastRotationTransmitted = this.rotation;
            this.timeRotationTransmitted = this.game.time.time;
            this.shooting = false;
            this.down_px = 0;
            this.down_py = 0;
            this.impulseFactor = 0;
            this.aimDirectionVector = new Billiard.Vector2D(1, 0);
            this.startAim = false;
            this.downTimer = -0.1;
            this.doIntermittentCueAnim = false;
            this.doIntermittentCueAnimCounter = 1.0;
            this.createCue();
            if (this.game.device.touch) {
                this.game.input.onUp.add(this.onUp, this);
                this.game.input.onDown.add(this.onDownTouch, this);
            } else {
                this.game.input.onDown.add(this.onDownDesktop, this);
                this.game.input.onUp.add(this.shoot, this);
            }
            this.cue.visible = false;
        }
        update() {
            super.update();
            if (this.downTimer >= 0) {
                this.downTimer -= this.game.time.physicsElapsed;
            }
            if (!this.cue.visible || this.shooting || MiniBillar.SpinCircleLayer.currentInstance.visible ||
                MiniBillar.GameVars.paused || MiniBillar.GameVars.GUIButtonDown) {
                return;
            }
            this.animateCue();
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.StageContainer.currentInstance.selectPockets.canSelect ||
                    MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.PLAYER) {
                    return;
                }
            }
            const cueBall = MiniBillar.GameVars.ballArray[0];
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            if (this.game.device.touch) {
                if (this.settingPower) {
                    this.cue.x = this.impulseFactor * CueContainer.MAX_DELTA_CUE;
                } else {
                    if (this.game.input.activePointer.isDown && !this.settingPower) {
                        if (this.startAim) {
                            const dx = (this.game.input.activePointer.x - this.parent.x) / MiniBillar.GameVars.scaleXMult - cueBall.mc.x;
                            const dy = this.game.input.activePointer.y - this.parent.y - cueBall.mc.y;
                            let pointerAngle = 180 / Math.PI * Math.atan2(dy, dx);
                            let deltaAngle = Billiard.Maths.angleDiff(pointerAngle, this.startAng);
                            this.angle = this.startCue + deltaAngle;
                            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                            this.transmitCueRotation();
                        } else {
                            this.startCue = this.angle;
                            const dx = (this.game.input.activePointer.x - this.parent.x) / MiniBillar.GameVars.scaleXMult - cueBall.mc.x;
                            const dy = this.game.input.activePointer.y - this.parent.y - cueBall.mc.y;
                            this.startAng = 180 / Math.PI * Math.atan2(dy, dx);
                            this.startAim = true;
                        }
                    } else {
                        this.startAim = false;
                    }
                }
            } else {
                if (this.settingPower) {
                    if (cueBall.handIcon) {
                        cueBall.handIcon.visible = false;
                    }
                    const x = this.down_px - this.game.input.activePointer.x;
                    const y = this.down_py - this.game.input.activePointer.y;
                    const transf_x = x * Math.cos(this.rotation) + y * Math.sin(this.rotation);
                    this.impulseFactor = Billiard.Maths.fixNumber(-Phaser.Math.clamp(transf_x, -CueContainer.MAX_DELTA_CUE, 0) / CueContainer.MAX_DELTA_CUE);
                    this.cue.x = this.impulseFactor * CueContainer.MAX_DELTA_CUE;
                } else if (!MiniBillar.SpinCircleLayer.discardClick) {
                    let cueBall = MiniBillar.GameVars.ballArray[0];
                    const dx = cueBall.mc.x - this.game.input.activePointer.x + this.parent.x;
                    const dy = cueBall.mc.y - this.game.input.activePointer.y + this.parent.y;
                    this.rotation = Math.atan2(dy, dx);
                    this.transmitCueRotation();
                    this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                }
            }
        }
        showCueAndUpdatePos() {
            this.cue.visible = true;
            this.cue.x = 0;
            this.cue.alpha = 0;
            this.game.add.tween(this.cue)
                .to({
                    alpha: 1
                }, 300, Phaser.Easing.Cubic.Out, true);
            let cueBall = MiniBillar.GameVars.ballArray[0];
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
        }
        moveCue(rotation) {
            let difference = this.rotation - rotation;
            let times = Math.floor((difference - (-Math.PI)) / (Math.PI * 2));
            let shortAngle = (difference - (times * (Math.PI * 2))) * -1;
            let newAngle = this.rotation + shortAngle;
            let cueBall = MiniBillar.GameVars.ballArray[0];
            let randTime = Math.random() * 600 + 300;
            this.position.x = cueBall.mc.x;
            this.position.y = cueBall.mc.y;
            this.game.add.tween(this)
                .to({
                    rotation: newAngle
                }, randTime, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function() {
                    this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                }, this);
        }
        moveCueTo(x, y) {
            this.game.add.tween(this.position)
                .to({
                    x: x,
                    y: y
                }, 200, Phaser.Easing.Linear.None, true);
        }
        hideCue() {
            this.cue.visible = false;
            this.cue.x = 0;
            this.shooting = false;
        }
        shoot(p) {
            if (p && !p.withinGame) {
                return;
            }
            this.settingPower = false;
            if (this.shooting || !this.cue.visible || MiniBillar.SpinCircleLayer.currentInstance.visible || MiniBillar.GameVars.shotRunning ||
                MiniBillar.StageContainer.currentInstance.selectPockets.canSelect) {
                return;
            }
            if (this.downTimer > 0) {
                this.cancelShot();
                this.downTimer = -0.1;
                return;
            }
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                MiniBillar.MatchManagerPVP.cueRotated(this.rotation);
            }
            if (this.impulseFactor > 0) {
                this.shooting = true;
                this.game.add.tween(this.cue)
                    .to({
                        x: -5
                    }, 75, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(this.applyImpulse, this);
            } else {
                this.impulseFactor = 0;
                const cueBall = MiniBillar.GameVars.ballArray[0];
                if (cueBall.handIcon) {
                    cueBall.handIcon.visible = true;
                }
            }
        }
        shootReceived(vector, deltaScrew, english) {
            this.shooting = true;
            this.game.add.tween(this.cue)
                .to({
                    x: 100
                }, 400, Phaser.Easing.Cubic.Out, true, 500);
            this.game.add.tween(this.cue)
                .to({
                    x: -5
                }, 200, Phaser.Easing.Cubic.Out, true, 1000)
                .onComplete.add(function() {
                    this.applyReceivedImpulse(vector, deltaScrew, english);
                }, this);
        }
        applyReceivedImpulse(velocity, deltaScrew, english, impulseFactor) {
            let cueBall = MiniBillar.GameVars.ballArray[0];
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                cueBall.hideHandIcon();
            }
            cueBall.velocity = velocity;
            cueBall.deltaScrew = deltaScrew;
            cueBall.english = english;
            let shotData = {
                cueSpeed: {
                    vx: cueBall.velocity.x,
                    vy: cueBall.velocity.y
                },
                deltaScrew: {
                    x: cueBall.deltaScrew.x,
                    y: cueBall.deltaScrew.y
                },
                english: cueBall.english
            };
            MiniBillar.MatchManager.ballHasBeenShot(shotData);
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.CUE_HIT, cueBall.velocity.magnitude / 1.9e3);
        }
        onUpTimeOut() {
            if (!this.settingPower) {
                return;
            }
            this.cancelShot();
        }
        updateCueSprite() {
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                return;
            } else {
                let playerCue = MiniBillar.GameVars.gameData.playerData.equipedCue;
                let adversaryCue = MiniBillar.GameVars.adversaryData.equipedCue;
                const playerCueHasIntermittentAnim = MiniBillar.RewardsManager.getCueSpriteIntermittent(playerCue);
                const adversaryCueHasIntermittentAnim = MiniBillar.RewardsManager.getCueSpriteIntermittent(adversaryCue);
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    if (!playerCueHasIntermittentAnim) {
                        this.doIntermittentCueAnim = false;
                    } else {
                        this.doIntermittentCueAnim = true;
                    }
                    this.cue.play("playerCueLoop");
                } else {
                    if (!adversaryCueHasIntermittentAnim) {
                        this.doIntermittentCueAnim = false;
                    } else {
                        this.doIntermittentCueAnim = true;
                    }
                    this.cue.play("adversaryCueLoop");
                }
            }
        }
        aimHelper() {
            if (this.game.device.desktop || (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE && MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY)) {
                return;
            }
            let cueBall = MiniBillar.GameVars.ballArray[0];
            let viableBalls = [];
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                const ball = MiniBillar.GameVars.ballArray[i];
                if (ball.id === 0 || !ball.active) {
                    continue;
                }
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (MiniBillar.GuideContainer.currentInstance.isBallProhibited(ball.id)) {
                        continue;
                    }
                }
                if (!this.clearLineOfSight(cueBall.position, ball.position)) {
                    continue;
                }
                viableBalls.push(ball);
            }
            if (viableBalls.length < 1) {
                return;
            }
            viableBalls = this.sortAndPruneViableBalls(viableBalls);
            const dxFinal = viableBalls[0].position.x - cueBall.position.x;
            const dyFinal = viableBalls[0].position.y - cueBall.position.y;
            let angle = Math.atan2(dyFinal, dxFinal) * 180 / Math.PI + 180;
            if (Math.abs(this.angle - angle) > 180) {
                angle -= 360;
            }
            this.angle = angle + -.15 + .3 * Math.random();
            this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
        }
        sortAndPruneViableBalls(viableBalls) {
            let list = [];
            for (let i = 0; i < viableBalls.length; i++) {
                let ball = viableBalls[i];
                let b1Closest = Number.MAX_VALUE;
                let pocketIndex = -1;
                for (let j = 0; j < MiniBillar.GameVars.pocketArray.length; j++) {
                    const b1XDiff = ball.position.x - MiniBillar.GameVars.pocketArray[j].position.x;
                    const b1YDiff = ball.position.y - MiniBillar.GameVars.pocketArray[j].position.y;
                    const b1Dist = b1XDiff * b1XDiff + b1YDiff * b1YDiff;
                    if (b1Dist < b1Closest) {
                        b1Closest = b1Dist;
                        pocketIndex = j;
                    }
                }
                list.push({
                    index: i,
                    distance: b1Closest,
                    pocketIndex: pocketIndex
                });
            }
            list = list.sort((n1, n2) => n1.distance - n2.distance);
            let answer = [];
            let culledBalls = [];
            for (let i = 0; i < list.length; i++) {
                const ballIndex = list[i].index;
                const pocketIndex = list[i].pocketIndex;
                const ball = viableBalls[ballIndex];
                const pocket = MiniBillar.GameVars.pocketArray[pocketIndex];
                if (!this.clearLineOfSight(ball.position, pocket.position, ball.position)) {
                    culledBalls.push(viableBalls[ballIndex]);
                    continue;
                } else {
                    answer.push(viableBalls[ballIndex]);
                }
            }
            return answer.length > 0 ? answer : culledBalls;
        }
        clearLineOfSight(start, target, excludeBallPos) {
            if (!excludeBallPos) {
                excludeBallPos = target;
            }
            let c = new Billiard.Point(start.x, start.y);
            let p = new Billiard.Point(target.x, target.y);
            let g = 2 * MiniBillar.GameConstants.BALL_RADIUS;
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                const ball = MiniBillar.GameVars.ballArray[i];
                if (ball.id === 0 || ball.position === excludeBallPos || !ball.active) {
                    continue;
                }
                let u = new Billiard.Point(ball.position.x, ball.position.y);
                var h = Billiard.Maths.lineIntersectCircle(c, p, u, g);
                if (h.intersects) {
                    return false;
                }
            }
            return true;
        }
        createCue() {
            this.cue = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_5");
            this.cue.anchor.y = .5;
            this.cue.anchor.x = -.027;
            this.add(this.cue);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                let frames = MiniBillar.Utils.createAnimFramesArr(MiniBillar.GameVars.gameData.playerData.equipedCue + "_sprite", MiniBillar.RewardsManager.getCueSpriteFrames(MiniBillar.GameVars.gameData.playerData.equipedCue));
                this.cue.frameName = frames[0];
                const intermittentAnim = MiniBillar.RewardsManager.getCueSpriteIntermittent(MiniBillar.GameVars.gameData.playerData.equipedCue);
                let anim = this.cue.animations.add("cueLoop", frames, 12, !intermittentAnim);
                if (!intermittentAnim) {
                    anim.play();
                } else {
                    this.doIntermittentCueAnim = true;
                }
            } else if (MiniBillar.GameVars.adversaryData.equipedCue) {
                let playerCue = MiniBillar.GameVars.gameData.playerData.equipedCue;
                let adversaryCue = MiniBillar.GameVars.adversaryData.equipedCue;
                const playerCueHasIntermittentAnim = MiniBillar.RewardsManager.getCueSpriteIntermittent(playerCue);
                const playerCueframes = MiniBillar.Utils.createAnimFramesArr(playerCue + "_sprite", MiniBillar.RewardsManager.getCueSpriteFrames(playerCue));
                this.cue.animations.add("playerCueLoop", playerCueframes, 12, !playerCueHasIntermittentAnim);
                const adversaryCueHasIntermittentAnim = MiniBillar.RewardsManager.getCueSpriteIntermittent(adversaryCue);
                const adversaryCueframes = MiniBillar.Utils.createAnimFramesArr(adversaryCue + "_sprite", MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE ? 1 : MiniBillar.RewardsManager.getCueSpriteFrames(adversaryCue));
                this.cue.animations.add("adversaryCueLoop", adversaryCueframes, 12, !adversaryCueHasIntermittentAnim);
                this.updateCueSprite();
            }
        }
        applyImpulse() {
            let cueBall = MiniBillar.GameVars.ballArray[0];
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                cueBall.hideHandIcon();
            }
            cueBall.velocity = this.aimDirectionVector.times(this.impulseFactor * CueContainer.MAX_IMPULSE);
            this.impulseFactor = 0;
            let screw;
            if (MiniBillar.GameVars.verticalSpin > 0) {
                screw = .035;
            } else if (MiniBillar.GameVars.verticalSpin < 0) {
                screw = .0425;
            } else {
                screw = 0;
            }
            cueBall.deltaScrew = this.aimDirectionVector.times(cueBall.velocity.magnitude * screw * MiniBillar.GameVars.verticalSpin);
            cueBall.english = MiniBillar.GameVars.english;
            let shotData = {
                cueSpeed: {
                    vx: cueBall.velocity.x,
                    vy: cueBall.velocity.y
                },
                deltaScrew: {
                    x: cueBall.deltaScrew.x,
                    y: cueBall.deltaScrew.y
                },
                english: cueBall.english
            };
            MiniBillar.MatchManager.ballHasBeenShot(shotData);
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.CUE_HIT, cueBall.velocity.magnitude / 1.9e3);
        }
        animateCue() {
            if (this.doIntermittentCueAnim) {
                if (this.doIntermittentCueAnimCounter < 0) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                        this.cue.play("cueLoop", 24, false);
                    } else {
                        if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                            this.cue.play("playerCueLoop", 24, false);
                        } else {
                            this.cue.play("adversaryCueLoop", 24, false);
                        }
                    }
                    this.doIntermittentCueAnimCounter = this.game.rnd.realInRange(2, 8);
                } else {
                    this.doIntermittentCueAnimCounter -= this.game.time.physicsElapsed;
                }
            }
        }
        onDownDesktop() {
            if (!this.cue.visible || MiniBillar.GameVars.shotRunning || MiniBillar.SpinCircleLayer.currentInstance.visible ||
                MiniBillar.StageContainer.currentInstance.selectPockets.canSelect) {
                return;
            }
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    if (MiniBillar.SpinCircleLayer.discardClick) {
                        MiniBillar.SpinCircleLayer.discardClick = false;
                    }
                }
            } else {
                if (MiniBillar.SpinCircleLayer.discardClick) {
                    MiniBillar.SpinCircleLayer.discardClick = false;
                }
            }
            if (this.downTimer < 0) {
                this.downTimer = 0.15;
            }
            this.settingPower = true;
            this.down_px = this.game.input.activePointer.x;
            this.down_py = this.game.input.activePointer.y;
        }
        cancelShot() {
            this.cue.x = 0;
            this.impulseFactor = 0;
            this.settingPower = false;
            const cueBall = MiniBillar.GameVars.ballArray[0];
            if (cueBall.handIcon) {
                cueBall.handIcon.visible = true;
            }
        }
        onDownTouch() {
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    if (MiniBillar.SpinCircleLayer.discardClick) {
                        MiniBillar.SpinCircleLayer.discardClick = false;
                    }
                }
            } else {
                if (MiniBillar.SpinCircleLayer.discardClick) {
                    MiniBillar.SpinCircleLayer.discardClick = false;
                }
            }
        }
        onUp(pointer) {
            if (MiniBillar.GameVars.shotRunning || MiniBillar.SpinCircleLayer.currentInstance.visible || MiniBillar.SpinCircleLayer.discardClick ||
                this.settingPower || MiniBillar.GameVars.paused || MiniBillar.StageContainer.currentInstance.selectPockets.canSelect ||
                MiniBillar.GameVars.GUIButtonDown) {
                if (MiniBillar.GameVars.GUIButtonDown) {
                    MiniBillar.GameVars.GUIButtonDown = false;
                }
                return;
            }
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE && MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.PLAYER) {
                return;
            }
            if (pointer.timeUp - pointer.timeDown < 300) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                let px = (pointer.x - this.parent.x) / MiniBillar.GameConstants.PHYS_SCALE * MiniBillar.GameVars.scaleXMultInverse;
                let py = (pointer.y - this.parent.y) / MiniBillar.GameConstants.PHYS_SCALE * MiniBillar.GameVars.scaleYMultInverse;
                let dx;
                let dy;
                for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                    let ball = MiniBillar.GameVars.ballArray[i];
                    if (ball.id !== 0) {
                        dx = ball.position.x - px;
                        dy = ball.position.y - py;
                        let d = Math.sqrt(dx * dx + dy * dy);
                        if (d < 2.5 * MiniBillar.GameConstants.BALL_RADIUS) {
                            px = ball.position.x;
                            py = ball.position.y;
                            break;
                        }
                    }
                }
                dx = px - cueBall.position.x;
                dy = py - cueBall.position.y;
                let angle = Math.atan2(dy, dx) * 180 / Math.PI + 180;
                angle += -.15 + .3 * Math.random();
                if (Math.abs(this.angle - angle) > 180) {
                    angle -= 360;
                }
                this.game.add.tween(this)
                    .to({
                        angle: angle
                    }, 180, Phaser.Easing.Cubic.Out, true)
                    .onUpdateCallback(function() {
                        this.aimDirectionVector = new Billiard.Vector2D(-Math.cos(this.rotation), -Math.sin(this.rotation));
                    }, this)
                    .onComplete.add(this.transmitCueRotation, this);
            }
        }
        transmitCueRotation() {
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE && MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                if (Math.abs(this.rotation - this.lastRotationTransmitted) > CueContainer.DELTA_ROTATIION && this.game.time.time - this.timeRotationTransmitted > CueContainer.DELTA_TIME) {
                    this.timeRotationTransmitted = this.game.time.time;
                    this.lastRotationTransmitted = this.rotation;
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                        MiniBillar.MatchManagerPVP.cueRotated(this.rotation);
                    }
                }
            }
        }
    }
    CueContainer.MAX_IMPULSE = 2200;
    CueContainer.MAX_DELTA_CUE = 150;
    CueContainer.DELTA_ROTATIION = 5 / 180 * Math.PI;
    CueContainer.DELTA_TIME = 1250;
    MiniBillar.CueContainer = CueContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class DebugObjectsContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "debug-objects-container");
            this.graphics = new Phaser.Graphics(this.game);
            this.add(this.graphics);
            this.cueBallGraphics = new Phaser.Graphics(this.game);
            this.add(this.cueBallGraphics);
        }
        drawCircle(p, radius, color) {
            this.graphics.lineStyle(1, color);
            this.graphics.drawCircle(p.x * MiniBillar.GameConstants.PHYS_SCALE, p.y * MiniBillar.GameConstants.PHYS_SCALE, 2 * radius * MiniBillar.GameConstants.PHYS_SCALE);
        }
        clearCueBallGraphics() {
            this.cueBallGraphics.clear();
        }
        drawCueBallTrajectoryPoint(p, color) {
            this.cueBallGraphics.lineStyle(1, color, 1);
            this.cueBallGraphics.beginFill(color, 1);
            this.cueBallGraphics.drawCircle(p.x * MiniBillar.GameConstants.PHYS_SCALE, p.y * MiniBillar.GameConstants.PHYS_SCALE, 5);
            this.cueBallGraphics.endFill();
        }
        drawPoint(p, color) {
            this.graphics.lineStyle(1, color, 1);
            this.graphics.beginFill(color, 1);
            this.graphics.drawCircle(p.x * MiniBillar.GameConstants.PHYS_SCALE, p.y * MiniBillar.GameConstants.PHYS_SCALE, 5);
            this.graphics.endFill();
        }
        drawLine(p1, p2, color) {
            this.graphics.lineStyle(1, color, 1);
            this.graphics.moveTo(p1.x * MiniBillar.GameConstants.PHYS_SCALE, p1.y * MiniBillar.GameConstants.PHYS_SCALE);
            this.graphics.lineTo(p2.x * MiniBillar.GameConstants.PHYS_SCALE, p2.y * MiniBillar.GameConstants.PHYS_SCALE);
        }
    }
    DebugObjectsContainer.WHITE = 0xFFFFFF;
    DebugObjectsContainer.RED = 0xFF0000;
    DebugObjectsContainer.GREEN = 0x00FF00;
    DebugObjectsContainer.BLUE = 0x0000FF;
    DebugObjectsContainer.YELLOW = 0xFFFF00;
    MiniBillar.DebugObjectsContainer = DebugObjectsContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GiftBox extends Phaser.Group {
        constructor(game, x, y) {
            super(game, null, "giftbox");
            this.scale.set(.5);
            this.position.set(x, y);
            const sparkleFrames = MiniBillar.Utils.createAnimFramesArr("sparkle_effect", 14, false, 0, 15);
            const sparkleUpscale = 1.5;
            this.sparkleSprite1 = new Phaser.Sprite(this.game, -50, -100, "texture_atlas_1");
            this.sparkleSprite1.anchor.set(0.5);
            this.sparkleSprite1.animations.add("sparkle", sparkleFrames);
            this.sparkleSprite1.visible = false;
            this.sparkleSprite1.scale.x *= sparkleUpscale;
            this.sparkleSprite1.scale.y *= sparkleUpscale;
            this.add(this.sparkleSprite1);
            this.sparkleSprite2 = new Phaser.Sprite(this.game, 50, -100, "texture_atlas_1");
            this.sparkleSprite2.anchor.set(0.5);
            this.sparkleSprite2.animations.add("sparkle", sparkleFrames);
            this.sparkleSprite2.visible = false;
            this.sparkleSprite2.scale.x *= sparkleUpscale;
            this.sparkleSprite2.scale.y *= sparkleUpscale;
            this.add(this.sparkleSprite2);
            this.boxImage = new Phaser.Image(game, 0, -50, "texture_atlas_1", "gift_box.png");
            this.boxImage.anchor.set(.5);
            this.add(this.boxImage);
            this.lidImage = new Phaser.Image(game, 0, -50, "texture_atlas_1", "gift_lid.png");
            this.lidImage.anchor.set(.5);
            this.add(this.lidImage);
            this.boxOpeningTween = this.boxOpeningTween = this.game.add.tween(this.lidImage)
                .to({
                    x: this.lidImage.x - 160
                }, GiftBox.GIFTBOX_OPENING_DURATION, Phaser.Easing.Cubic.InOut);
        }
        openGiftBox() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.GIFT_OPENS);
            this.boxOpeningTween.start();
            this.sparkleSprite1.visible = true;
            this.sparkleSprite2.visible = true;
            this.sparkleSprite1.play("sparkle", 24, false, true);
            this.sparkleSprite2.play("sparkle", 24, false, true);
            this.game.add.tween(this.lidImage)
                .to({
                    y: this.lidImage.y - 62
                }, GiftBox.GIFTBOX_OPENING_DURATION * .4, Phaser.Easing.Linear.None, true)
                .onComplete.add(function() {
                    this.sendToBack(this.lidImage);
                    this.game.add.tween(this.lidImage)
                        .to({
                            y: this.lidImage.y + 124,
                            alpha: .5
                        }, GiftBox.GIFTBOX_OPENING_DURATION * .4, Phaser.Easing.Linear.None, true);
                }, this);
        }
    }
    GiftBox.GIFTBOX_OPENING_DURATION = 700;
    MiniBillar.GiftBox = GiftBox;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GuideContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "guide-container");
            GuideContainer.currentInstance = this;
            this.guide = new Phaser.Graphics(this.game);
            this.add(this.guide);
            this.prohibitedBalls = [];
            this.guideWidth = 2;
            this.guideAlpha = 1;
            this.alpha = 0;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, 300, Phaser.Easing.Cubic.Out, true);
        }
        update() {
            super.update();
            if (MiniBillar.GameVars.shotRunning || !MiniBillar.GameVars.startMatch) {
                return;
            }
            this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
            let cueBallPos = MiniBillar.GameVars.ballArray[0].position;
            let distantPoint = cueBallPos.plus(MiniBillar.CueContainer.currentInstance.aimDirectionVector.times(5e5));
            let distantPointPosition = new Billiard.Point(distantPoint.x, distantPoint.y);
            let intersectedBalls = [];
            let intersectionPoints = [];
            let cueBallCenter = new Billiard.Point(cueBallPos.x, cueBallPos.y);
            for (let i = 1, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
                let ball = MiniBillar.GameVars.ballArray[i];
                if (ball.active) {
                    let ballPosition = new Billiard.Point(ball.position.x, ball.position.y);
                    let intersection = Billiard.Maths.lineIntersectCircle(cueBallCenter, distantPointPosition, ballPosition, 2 * MiniBillar.GameConstants.BALL_RADIUS);
                    if (intersection.intersects) {
                        intersectedBalls.push(ball);
                        if (intersection.enter !== null) {
                            intersectionPoints.push(intersection.enter);
                        }
                    }
                }
            }
            let touchedBall;
            let circleCenter = null;
            if (intersectedBalls.length > 0) {
                let minSquaredDistance = 1e10;
                for (let i = 0, ln = intersectedBalls.length; i < ln; i++) {
                    let squaredDistance = (intersectedBalls[i].position.x - cueBallPos.x) * (intersectedBalls[i].position.x - cueBallPos.x) + (intersectedBalls[i].position.y - cueBallPos.y) * (intersectedBalls[i].position.y - cueBallPos.y);
                    if (squaredDistance < minSquaredDistance) {
                        minSquaredDistance = squaredDistance;
                        touchedBall = intersectedBalls[i];
                        circleCenter = intersectionPoints[i];
                    }
                }
                this.guide.clear();
                this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                this.guide.moveTo(cueBallPos.x * MiniBillar.GameConstants.PHYS_SCALE, cueBallPos.y * MiniBillar.GameConstants.PHYS_SCALE);
                if (circleCenter) {
                    this.guide.lineTo(circleCenter.x * MiniBillar.GameConstants.PHYS_SCALE, circleCenter.y * MiniBillar.GameConstants.PHYS_SCALE);
                }
                let drawTrajectoryLines = true;
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (!MiniBillar.GameVars.laserGuideActive) {
                        if (this.isBallProhibited(touchedBall.id)) {
                            this.guide.lineStyle(this.guideWidth * 1.35, 0xFF0000, this.guideAlpha);
                            drawTrajectoryLines = false;
                        }
                    }
                }
                if (circleCenter) {
                    this.guide.drawCircle(circleCenter.x * MiniBillar.GameConstants.PHYS_SCALE, circleCenter.y * MiniBillar.GameConstants.PHYS_SCALE, 2 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE);
                }
                if (drawTrajectoryLines) {
                    if (!circleCenter) {
                        this.guide.clear();
                        return;
                    }
                    let w = Billiard.Maths.findBearing(circleCenter.x - cueBallPos.x, circleCenter.y - cueBallPos.y);
                    let b = Billiard.Maths.findBearing(touchedBall.position.x - circleCenter.x, touchedBall.position.y - circleCenter.y);
                    let P = Math.abs(Billiard.Maths.angleDiff(b, w));
                    let touchedBallLineLength = 5 * MiniBillar.GameConstants.BALL_RADIUS * ((90 - P) / 90);
                    if (MiniBillar.GameVars.laserGuideActive) {
                        touchedBallLineLength = 80000;
                    }
                    let touchedBallLineEnd = new Billiard.Point(touchedBall.position.x + Math.cos(b * Math.PI / 180) * touchedBallLineLength, touchedBall.position.y + Math.sin(b * Math.PI / 180) * touchedBallLineLength);
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(touchedBall.position.x * MiniBillar.GameConstants.PHYS_SCALE, touchedBall.position.y * MiniBillar.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(touchedBallLineEnd.x * MiniBillar.GameConstants.PHYS_SCALE, touchedBallLineEnd.y * MiniBillar.GameConstants.PHYS_SCALE);
                    let C = Billiard.Maths.findBearing(circleCenter.x - cueBallPos.x, circleCenter.y - cueBallPos.y);
                    let T = Billiard.Maths.findBearing(touchedBallLineEnd.x - circleCenter.x, touchedBallLineEnd.y - circleCenter.y);
                    P = Billiard.Maths.angleDiff(T, C);
                    let whiteBallLineEnd = 5 * MiniBillar.GameConstants.BALL_RADIUS * P / 90;
                    if (MiniBillar.GameVars.laserGuideActive) {
                        whiteBallLineEnd = 80000 * P;
                    }
                    let E = T - 90;
                    let M = new Billiard.Point(circleCenter.x + whiteBallLineEnd * Math.cos(E * Math.PI / 180), circleCenter.y + whiteBallLineEnd * Math.sin(E * Math.PI / 180));
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(circleCenter.x * MiniBillar.GameConstants.PHYS_SCALE, circleCenter.y * MiniBillar.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(M.x * MiniBillar.GameConstants.PHYS_SCALE, M.y * MiniBillar.GameConstants.PHYS_SCALE);
                }
            } else {
                for (let i = 0; i < 4; i++) {
                    const intersection = Billiard.Maths.lineIntersectLine(cueBallCenter, distantPointPosition, MiniBillar.StageContainer.CUSHION_VERTEXES[i], MiniBillar.StageContainer.CUSHION_VERTEXES[i + 1]);
                    if (intersection) {
                        circleCenter = intersection;
                    }
                }
                if (circleCenter) {
                    this.guide.clear();
                    this.guide.lineStyle(this.guideWidth, 0xFFFFFF, this.guideAlpha);
                    this.guide.moveTo(cueBallPos.x * MiniBillar.GameConstants.PHYS_SCALE, cueBallPos.y * MiniBillar.GameConstants.PHYS_SCALE);
                    this.guide.lineTo(circleCenter.x * MiniBillar.GameConstants.PHYS_SCALE, circleCenter.y * MiniBillar.GameConstants.PHYS_SCALE);
                    this.guide.drawCircle(circleCenter.x * MiniBillar.GameConstants.PHYS_SCALE, circleCenter.y * MiniBillar.GameConstants.PHYS_SCALE, 2 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE);
                }
            }
        }
        setGuideProhibitedBalls(ballIds, prohibited) {
            for (let i = 0; i < ballIds.length; i++) {
                const index = this.prohibitedBalls.indexOf(ballIds[i]);
                if (prohibited) {
                    if (index < 0) {
                        this.prohibitedBalls.push(ballIds[i]);
                    }
                } else {
                    if (index > -1) {
                        this.prohibitedBalls.splice(index, 1);
                    }
                }
            }
        }
        isBallProhibited(ballId) {
            return this.prohibitedBalls.indexOf(ballId) > -1;
        }
    }
    MiniBillar.GuideContainer = GuideContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PocketedBallsTrail extends Phaser.Group {
        constructor(game) {
            super(game, null, "pocketed-balls-trail");
            this.x = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 485 : -485;
            this.y = -PocketedBallsTrail.RAILS_LENGTH / 2;
            this.railTweens = [];
            const railBottomImageName = MiniBillar.GameVars.gameData.equippedTable + "_rail_bottom.png";
            this.rails = new Phaser.Image(this.game, 0, 0, "texture_atlas_4", railBottomImageName);
            this.rails.anchor.x = .5;
            this.add(this.rails);
            const railTopImageName = MiniBillar.GameVars.gameData.equippedTable + "_rail_top.png";
            this.cover = new Phaser.Image(this.game, 0, 0, "texture_atlas_4", railTopImageName);
            this.cover.anchor.x = .5;
            this.add(this.cover);
            this.rails.scale.x = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 1 : -1;
            this.cover.scale.x = this.rails.scale.x;
        }
        pauseGame() {
            for (let i = 0; i < this.railTweens.length; i++) {
                this.railTweens[i].pause();
            }
        }
        resumeGame() {
            for (let i = 0; i < this.railTweens.length; i++) {
                this.railTweens[i].resume();
            }
        }
        addBall(ball) {
            let numBallsWaiting = 0;
            for (let i = 1; i < MiniBillar.GameVars.ballArray.length; i++) {
                if (MiniBillar.GameVars.ballArray[i].waitingToTheRail) {
                    numBallsWaiting++;
                }
            }
            ball.mc.shade.frameName = "shade_potted_ball.png";
            ball.waitingToTheRail = true;
            const delay = 1500 + 500 * numBallsWaiting + Math.round(150 * Math.random());
            const numPocketedBalls = this.children.length - 2 + numBallsWaiting;
            this.game.time.events.add(delay, function() {
                ball.waitingToTheRail = false;
                ball.mc.pocketTween = true;
                ball.mc.scale.set(PocketedBallsTrail.SCALE_FACTOR);
                ball.mc.position.set(0, 20);
                ball.shadow.destroy();
                this.addAt(ball.mc, 1);
                const vy = 2.5 + .65 * Math.random();
                const dy = PocketedBallsTrail.RAILS_LENGTH - numPocketedBalls * MiniBillar.GameConstants.BALL_RADIUS * 2 * MiniBillar.GameConstants.PHYS_SCALE - 8;
                const t = dy / vy * 1000 / 60 * (1 / PocketedBallsTrail.SCALE_FACTOR);
                ball.velocity = new Billiard.Vector2D(0, vy);
                const railTween = this.game.add.tween(ball.mc)
                    .to({
                        y: dy
                    }, t, Phaser.Easing.Linear.None, true);
                railTween.onComplete.add(function() {
                    ball.mc.pocketTween = false;
                    ball.velocity = new Billiard.Vector2D(0, 0);
                    if (numPocketedBalls !== 0) {
                        MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BALL_HIT, .015);
                    }
                    const i = this.railTweens.indexOf(railTween);
                    this.railTweens.splice(i, 1);
                }, this);
                this.railTweens.push(railTween);
            }, this);
        }
        changeSide() {
            this.x = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 485 : -485;
            this.rails.scale.x = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 1 : -1;
            this.cover.scale.x = this.rails.scale.x;
        }
        setPocketedBalls() {
            for (let i = 0; i < MiniBillar.GameVars.pocketedBalls.length; i++) {
                let ballId = MiniBillar.GameVars.pocketedBalls[i];
                for (let j = 1; j < MiniBillar.GameVars.ballArray.length; j++) {
                    let ball = MiniBillar.GameVars.ballArray[j];
                    if (ballId === MiniBillar.GameVars.ballArray[j].id) {
                        ball.mc.shade.frameName = "shade_potted_ball.png";
                        ball.mc.position.set(0, PocketedBallsTrail.RAILS_LENGTH - i * MiniBillar.GameConstants.BALL_RADIUS * 2 * MiniBillar.GameConstants.PHYS_SCALE - 8);
                        ball.mc.scale.set(PocketedBallsTrail.SCALE_FACTOR);
                        this.add(ball.mc);
                    }
                }
            }
        }
    }
    PocketedBallsTrail.RAILS_LENGTH = 448;
    PocketedBallsTrail.SCALE_FACTOR = .9;
    MiniBillar.PocketedBallsTrail = PocketedBallsTrail;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PoolState extends Phaser.State {
        init() {
            PoolState.currentInstance = this;
            this.playerSetPVP = false;
            this.victoryLayer = null;
            this.loseLayer = null;
            this.adversaryLeftLayer = null;
            this.notificationLayer = null;
            this.chatLayer = null;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.MatchManagerSolo.init(this.game);
            }
        }
        create() {
            this.createStage();
            if (MiniBillar.GameVars.playerPoints === 0) {
                this.game.camera.flash(0x203161, 750);
            }
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            MiniBillar.AudioManager.stopMusic(MiniBillar.AudioManager.MUSIC_MINIBILLARD, false);
            this.game.time.events.add(250, function() {
                MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.MUSIC_MATCH_MINIBILLARD, true);
            }, this);
        }
        shutdown() {
            PoolState.currentInstance = null;
            super.shutdown();
        }
        update() {
            MiniBillar.MatchManager.update();
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                if (!this.playerSetPVP) {
                    MiniBillar.MatchManagerPVP.playerSet();
                    this.playerSetPVP = true;
                }
            }
            super.update();
        }
        createStage() {
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "texture_atlas_2", "background.png");
            background.anchor.set(.5);
            background.scale.set(MiniBillar.GameVars.gameWidth / background.width, MiniBillar.GameVars.gameHeight / background.height);
            this.stageContainer = new MiniBillar.StageContainer(this.game);
            this.add.existing(this.stageContainer);
            this.hud = new MiniBillar.HUD(this.game);
            this.add.existing(this.hud);
            this.gui = new MiniBillar.GUI(this.game);
            this.add.existing(this.gui);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.arrow = new Phaser.Image(this.game, MiniBillar.GameVars.gameWidth / 2 + 140, 160, "texture_atlas_1", "timer_up_arrow.png");
                this.arrow.scale.x = MiniBillar.GameVars.scaleXMult;
                this.arrow.alpha = 0;
                this.arrow.scale.y = .2;
                this.arrow.anchor.set(.5, 1);
                this.add.existing(this.arrow);
                this.arrowOnTween = false;
            }
            this.groupMessagesLayer = new Phaser.Group(this.game);
            this.add.existing(this.groupMessagesLayer);
            this.groupPauseLayers = new Phaser.Group(this.game);
            this.add.existing(this.groupPauseLayers);
            this.spinCircleLayer = new MiniBillar.SpinCircleLayer(this.game);
            this.groupPauseLayers.add(this.spinCircleLayer);
            if (MiniBillar.GameVars.startMatch) {
                throw "Match already started";
            }
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameVars.timeMatch = Date.now();
            }
            this.startGame();
        }
        startGame() {
            if (MiniBillar.GameVars.canStart) {
                return;
            }
            MiniBillar.GameVars.startMatch = true;
            MiniBillar.GameVars.canStart = true;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.MatchManagerSolo.startGame();
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                MiniBillar.MatchManagerPVP.startGame();
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                MiniBillar.MatchManagerPVBot.startGame();
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.NO_GAME) {
                throw "No game mode selected";
            }
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.gameEnded === MiniBillar.GameConstants.GAME_UNDECIDED) {
                    MiniBillar.MatchManagerSolo.startSoloTime();
                } else {
                    this.endGame();
                    return;
                }
            }
            this.startStage();
        }
        ballPocketed(ballId) {
            this.hud.ballPocketed(ballId);
        }
        updateBallsHUD() {
            this.hud.updateBallsHUD();
        }
        startStage() {
            this.stageContainer.start();
            this.hud.start();
            this.gui.start();
        }
        showSpinCircleLayer() {
            this.stageContainer.pauseGame();
            this.spinCircleLayer.show();
        }
        onNonSoloTimeOut(playerTurn) {
            this.hideSpinCircleLayer();
            if (this.game.device.touch && !playerTurn) {
                this.gui.forceSettingContainer.disable();
                this.gui.forceSettingContainer.hide();
            }
        }
        hideSpinCircleLayer() {
            this.stageContainer.resumeGame();
            this.gui.setRedPointPosition();
            this.spinCircleLayer.hide();
        }
        resetSpinCircleLayer() {
            this.spinCircleLayer.reset();
        }
        pauseGame() {
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.hideNotificationLayer();
            }
            this.pauseLayer = new MiniBillar.PauseLayer(this.game);
            this.groupPauseLayers.add(this.pauseLayer);
            this.stageContainer.pauseGame();
        }
        resumeGame() {
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            this.stageContainer.resumeGame();
        }
        showVictoryLayer(victoryData) {
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.hud.stopClock();
            this.stageContainer.hideGuide("Showing victory layer");
            this.stageContainer.hideCue("Showing victory layer");
            this.stageContainer.hideSelectPocket("Showing victory layer");
            PoolState.currentInstance.victoryLayer = new MiniBillar.VictoryLayer(this.game);
            PoolState.currentInstance.victoryLayer.init(victoryData);
            this.groupPauseLayers.add(PoolState.currentInstance.victoryLayer);
            if (this.chatLayer) {
                this.hideChatLayer();
            }
        }
        hideVictoryLayer() {
            PoolState.currentInstance.victoryLayer.destroy();
            PoolState.currentInstance.endGame();
        }
        showLoseLayer(victoryData) {
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.hud.stopClock();
            this.stageContainer.hideGuide("Showing lose layer");
            this.stageContainer.hideCue("Showing lose layer");
            this.stageContainer.hideSelectPocket("Showing lose layer");
            PoolState.currentInstance.loseLayer = new MiniBillar.LosePVPLayer(this.game);
            this.groupPauseLayers.add(PoolState.currentInstance.loseLayer);
            if (this.chatLayer) {
                this.hideChatLayer();
            }
        }
        hideLoseLayer() {
            PoolState.currentInstance.loseLayer.destroy();
            this.endGame();
        }
        showAdversaryLeftLayer() {
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.hud.stopClock();
            this.stageContainer.hideGuide("Showing adversary left layer");
            this.stageContainer.hideCue("Showing adversary left layer");
            this.stageContainer.hideSelectPocket("Showing adversary left layer");
            let cueBall = MiniBillar.GameVars.ballArray[0];
            cueBall.hideHandIcon();
            PoolState.currentInstance.adversaryLeftLayer = new MiniBillar.AdversaryLeftLayer(this.game);
            this.groupPauseLayers.add(PoolState.currentInstance.adversaryLeftLayer);
            if (this.chatLayer) {
                this.hideChatLayer();
            }
        }
        hideAdversaryLeftLayer() {
            PoolState.currentInstance.adversaryLeftLayer.destroy();
            this.endGame();
        }
        showSoloRetryLayer() {
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            if (this.pauseLayer) {
                this.pauseLayer.destroy();
            }
            if (this.spinCircleLayer) {
                this.spinCircleLayer.hide();
            }
            this.stageContainer.pauseGame();
            this.gui.visible = false;
            this.stageContainer.hideGuide("Showing retry layer");
            this.stageContainer.hideCue("Showing retry layer");
            this.soloRetryLayer = new MiniBillar.RetrySoloLayer(this.game);
            this.groupPauseLayers.add(this.soloRetryLayer);
        }
        hideRetryLayer() {
            this.stageContainer.resumeGame();
            this.soloRetryLayer.destroy();
        }
        showNotificationLayer(type, isPlayerTurn, opponentChoosingPocket) {
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
            this.notificationLayer = new MiniBillar.NotificationLayer(this.game, type, isPlayerTurn, opponentChoosingPocket);
            this.groupMessagesLayer.add(this.notificationLayer);
        }
        hideNotificationLayer() {
            if (this.notificationLayer) {
                this.notificationLayer.destroy();
                this.notificationLayer = null;
            }
        }
        hideNonSOLOTimers() {
            this.hud.hideNonSOLOTimers();
        }
        endGame() {
            MiniBillar.GameManager.enterSplash();
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            }
        }
        newTurn() {
            this.gui.newTurn();
            this.stageContainer.newTurn();
        }
        changePowerBar() {
            this.pauseLayer.changePower();
            if (this.gui.forceSettingContainer !== null) {
                this.gui.forceSettingContainer.changeSide();
            }
            this.stageContainer.pocketedBallsTrail.changeSide();
        }
        animArrow() {
            if (!this.arrowOnTween) {
                this.arrowOnTween = true;
                this.game.add.tween(this.arrow.scale)
                    .to({
                        y: 1
                    }, 400, Phaser.Easing.Cubic.In, true);
                let tweenA = this.game.add.tween(this.arrow)
                    .to({
                        alpha: 1
                    }, 400, Phaser.Easing.Cubic.In, true);
                let tweenB = this.game.add.tween(this.arrow)
                    .to({
                        y: 110,
                        alpha: 0
                    }, 400, Phaser.Easing.Cubic.Out);
                tweenA.chain(tweenB);
                this.game.time.events.add(900, function() {
                    this.arrowOnTween = false;
                    this.arrow.scale.y = .2;
                    this.arrow.y = 160;
                }, this);
            }
        }
        changePowerBarSide() {
            if (this.gui.forceSettingContainer) {
                this.gui.forceSettingContainer.changeSide();
            }
        }
        showAdversaryEmoticon(emoticonID) {
            this.hud.showEmoticon(emoticonID, false);
        }
        emoticonSelected(emoticonID) {
            if (this.chatLayer) {
                this.chatLayer.destroy();
                this.chatLayer = null;
            }
            this.hud.showEmoticon(emoticonID, true);
        }
        onPlayerEmoticonShown() {
            this.game.time.events.add(1500, function() {
                this.gui.showChatButton();
            }, this);
        }
        showChatLayer() {
            this.gui.hideChatButton();
            this.chatLayer = new MiniBillar.ChatLayer(this.game);
            this.add.existing(this.chatLayer);
        }
        hideChatLayer() {
            this.gui.showChatButton();
            this.chatLayer.destroy();
            this.chatLayer = null;
        }
    }
    MiniBillar.PoolState = PoolState;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class StageContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "stage-container");
            StageContainer.currentInstance = this;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.position.set(MiniBillar.GameVars.gameWidth / 2, 365);
            this.pocketedBallsTrail = new MiniBillar.PocketedBallsTrail(this.game);
            this.add(this.pocketedBallsTrail);
            this.tunnelContainer = new Phaser.Group(this.game);
            if (MiniBillar.GameConstants.DEBUG) {
                this.tunnelContainer.visible = false;
            }
            this.add(this.tunnelContainer);
            const bgName = MiniBillar.GameVars.gameData.equippedTable + "_surface.png";
            let tableLayer2 = new Phaser.Image(this.game, 0, 0, "texture_atlas_4", bgName);
            tableLayer2.anchor.set(.5);
            if (MiniBillar.GameConstants.DEBUG) {
                tableLayer2.visible = false;
            }
            this.add(tableLayer2);
            let tableLayer1 = new Phaser.Graphics(this.game, 0, 0);
            tableLayer1.beginFill(MiniBillar.RewardsManager.getTableTunnelColour(MiniBillar.GameVars.gameData.equippedTable));
            tableLayer1.drawRect(-tableLayer2.width * 0.446, -tableLayer2.height * 0.426, tableLayer2.width * 0.892, tableLayer2.height * 0.852);
            this.tunnelContainer.add(tableLayer1);
            this.ballsContainer = new MiniBillar.BallsContainer(this.game);
            this.add(this.ballsContainer);
            this.guideContainer = new MiniBillar.GuideContainer(this.game);
            this.add(this.guideContainer);
            const fgName = MiniBillar.GameVars.gameData.equippedTable + "_cushions.png";
            let tableLayer3 = new Phaser.Image(this.game, 0, 0, "texture_atlas_3", fgName);
            tableLayer3.anchor.set(.5);
            if (MiniBillar.GameConstants.DEBUG) {
                tableLayer3.visible = false;
            }
            this.add(tableLayer3);
            this.selectPockets = new MiniBillar.SelectPockets(this.game);
            this.add(this.selectPockets);
            this.cueContainer = new MiniBillar.CueContainer(this.game);
            this.add(this.cueContainer);
            if (MiniBillar.GameConstants.DEBUG) {
                this.addDebugObjectsContainer();
            } else {
                this.debugObjectContainer = null;
            }
        }
        static onContact(contactEvent) {
            let ball = contactEvent.ball;
            let contact = {
                collisionType: contactEvent.collisionType,
                type: null,
                target: null,
                targetVelocity: null,
                position: ball.position,
                targetPosition: contactEvent.target.position,
                velocity: null,
                screw: ball.screw,
                deltaScrew: null,
            };
            if (contactEvent.collisionType === Billiard.Engine.BALL) {
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                        MiniBillar.MatchManagerPVP.setTouchedBall(ball.id);
                    } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                        MiniBillar.MatchManagerPVBot.setTouchedBall(ball.id);
                    }
                }
                contact.target = contactEvent.target;
                contact.targetVelocity = contactEvent.targetVelocity;
                contact.deltaScrew = contactEvent.deltaScrew;
                contact.type = contactEvent.collisionType;
                ball.contactArray.push(contact);
                const relativeVelocity = contactEvent.ballVelocity.minus(contactEvent.targetVelocity).magnitude;
                let volumeEffect = relativeVelocity / 6e3;
                volumeEffect = volumeEffect > 1 ? 1 : volumeEffect;
                MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BALL_HIT, volumeEffect);
            } else if (contactEvent.collisionType === Billiard.Engine.VERTEX || contactEvent.collisionType === Billiard.Engine.LINE) {
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                        MiniBillar.MatchManagerPVP.setTouchedCushion(true);
                    }
                }
                ball.contactArray.push(contact);
                MiniBillar.GameVars.wallCollisions.push(ball.id);
                MiniBillar.GameVars.wallCollisions = StageContainer.currentInstance.removeDuplicates(MiniBillar.GameVars.wallCollisions);
                const normalVelocity = contactEvent.normalVelocity.magnitude;
                let volumeEffect = normalVelocity / 6e3;
                volumeEffect = volumeEffect > 1 ? 1 : volumeEffect;
                MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.CUSHION_HIT, volumeEffect);
            } else if (contactEvent.collisionType === Billiard.Engine.POCKET) {
                ball.active = false;
                ball.contactArray.push(contact);
                const speed = contactEvent.speed;
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE || ball.id === 0) {
                    MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.POCKET);
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE && ball.id === 0) {
                        MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.LOSE_POINTS);
                    }
                } else {
                    MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.POCKET_ADD_TIME);
                }
                StageContainer.currentInstance.playPocketAnimation(contactEvent);
            }
        }
        update() {
            if ((MiniBillar.GameVars.paused && MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) || !MiniBillar.GameVars.startMatch) {
                return;
            }
            if (MiniBillar.GameVars.shotRunning) {
                this.billiardEngine.update();
                for (let i = 0, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
                    let ball = MiniBillar.GameVars.ballArray[i];
                    if (ball.active && ball.velocity.magnitudeSquared !== 0) {
                        ball.mc.x = ball.position.x * MiniBillar.GameConstants.PHYS_SCALE;
                        ball.mc.y = ball.position.y * MiniBillar.GameConstants.PHYS_SCALE;
                        ball.shadow.x = ball.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (ball.mc.x / 300);
                        ball.shadow.y = ball.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (ball.mc.y / 150);
                        ball.mc.updateRotation(ball.velocity.x * MiniBillar.GameConstants.PHYS_SCALE * ball.grip, ball.velocity.y * MiniBillar.GameConstants.PHYS_SCALE * ball.grip, ball.ySpin);
                    }
                }
            }
            super.update();
        }
        start() {
            this.billiardEngine = new Billiard.Engine(StageContainer.onContact, MiniBillar.GameVars.ballArray, MiniBillar.GameVars.lineArray, MiniBillar.GameVars.vertexArray, MiniBillar.GameVars.pocketArray);
            this.billiardEngine.friction = MiniBillar.GameConstants.FRICTION;
            this.billiardEngine.ballRadius = MiniBillar.GameConstants.BALL_RADIUS;
            this.billiardEngine.pocketRadius = MiniBillar.GameConstants.POCKET_RADIUS;
            this.billiardEngine.physScale = MiniBillar.GameConstants.PHYS_SCALE;
            this.billiardEngine.minVelocity = MiniBillar.GameConstants.MIN_VELOCITY;
            this.billiardEngine.cushionRestitution = MiniBillar.GameConstants.CUSHION_RESTITUTION;
            this.billiardEngine.ballRestitution = MiniBillar.GameConstants.BALL_RESTITUTION;
            this.ballsContainer.startGame();
            this.pocketedBallsTrail.setPocketedBalls();
            this.showCue("starting match");
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.showGuide("your turn");
            } else {
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    this.showGuide("your turn");
                } else {
                    this.hideGuide("not your turn");
                }
            }
        }
        pauseGame() {
            MiniBillar.GameVars.paused = true;
            MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
            this.pocketedBallsTrail.pauseGame();
        }
        resumeGame() {
            MiniBillar.GameVars.paused = false;
            this.pocketedBallsTrail.resumeGame();
        }
        removeDuplicates(arr) {
            let unique_array = [];
            for (let i = 0; i < arr.length; i++) {
                if (unique_array.indexOf(arr[i]) === -1) {
                    unique_array.push(arr[i]);
                }
            }
            return unique_array;
        }
        newTurn() {
            this.updateCueSprite();
            this.showCue("Stage container new turn");
            this.cueContainer.aimHelper();
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    this.showGuide("Stage container new turn and your turn");
                } else {
                    this.hideGuide("Stage container new turn and not your turn");
                }
                if (MiniBillar.GameVars.skipShowingPocketAndCue) {
                    this.hideGuide("skipShowingPocket");
                    this.hideCue("skipShowingPocket");
                }
            } else {
                this.showGuide("Stage container new turn");
            }
            this.ballsContainer.newTurn();
        }
        ballHasBeenShot() {
            this.hideCue("Stage container ball has been shot");
            this.hideGuide("Stage container ball has been shot");
            this.ballsContainer.ballHasBeenShot();
            this.selectPockets.resetSelectedPocket();
        }
        showSetCueBall(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Showing setCueBall because " + reason, null, "purple");
            }
            this.ballsContainer.setCueBall();
        }
        hideGuide(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Hiding guide because " + reason, null, "blue");
            }
            this.guideContainer.visible = false;
        }
        showGuide(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Showing guide because " + reason, null, "orange");
            }
            this.guideContainer.visible = true;
        }
        setGuideProhibitedBalls(ballIds, prohibited) {
            this.guideContainer.setGuideProhibitedBalls(ballIds, prohibited);
        }
        hideCue(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Hiding cue because " + reason, null, "darkblue");
            }
            this.cueContainer.hideCue();
        }
        updateCueSprite() {
            this.cueContainer.updateCueSprite();
        }
        showCue(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Showing cue because " + reason, null, "darkorange");
            }
            this.cueContainer.showCueAndUpdatePos();
        }
        showSelectPocket(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Showing pocket selector because " + reason, null, "green");
            }
            this.selectPockets.showSelectPockets();
        }
        setRivalPocket(pocketId) {
            this.selectPockets.setRivalPocket(pocketId);
        }
        hideSelectPocket(reason) {
            if (reason) {
                MiniBillar.GameManager.log("Hiding pocket selector because " + reason, null, "darkorange");
            }
            this.selectPockets.hideSelectPockets();
        }
        addBallToTrail(ball) {
            this.pocketedBallsTrail.addBall(ball);
        }
        playPocketAnimation(contactEvent) {
            let ball = contactEvent.ball;
            let pocket = contactEvent.target;
            let speed = contactEvent.speed;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.MatchManagerSolo.ballPocketed(ball);
            } else {
                if (ball.id === 8) {
                    MiniBillar.GameVars.pocketIdWhereBlackFell = pocket.id;
                }
                if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                    MiniBillar.MatchManagerPVP.ballPocketed(ball);
                } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                    MiniBillar.MatchManagerPVBot.ballPocketed(ball);
                }
            }
            ball.mc.pocketTween = true;
            if (ball.id === 0) {
                ball.shadow.visible = false;
            } else {
                ball.shadow.parent.removeChild(ball.shadow);
            }
            let t;
            if (speed < 1e3) {
                t = 150;
            } else if (speed < 2e3) {
                t = 120;
            } else if (speed < 3e3) {
                t = 90;
            } else if (speed < 5e3) {
                t = 60;
            } else {
                t = 30;
            }
            this.game.add.tween(ball.mc.scale)
                .to({
                    x: .925,
                    y: .925
                }, t, Phaser.Easing.Cubic.Out, true);
            ball.velocity = new Billiard.Vector2D((pocket.dropPosition.x - ball.mc.x) / t, (pocket.dropPosition.y - ball.mc.y) / t);
            this.game.add.tween(ball.mc)
                .to({
                    x: pocket.dropPosition.x * MiniBillar.GameConstants.PHYS_SCALE,
                    y: pocket.dropPosition.y * MiniBillar.GameConstants.PHYS_SCALE
                }, t, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function() {
                    ball.mc.parent.removeChild(ball.mc);
                    this.tunnelContainer.add(ball.mc);
                    this.game.add.tween(ball.mc.scale)
                        .to({
                            x: .65,
                            y: .65
                        }, 1.75 * t, Phaser.Easing.Linear.None, true);
                    ball.velocity = new Billiard.Vector2D((.7 * pocket.dropPosition.x - ball.mc.x) / t, (.7 * pocket.dropPosition.y - ball.mc.y) / t);
                    let pocketTween = this.game.add.tween(ball.mc)
                        .to({
                            x: 0.7 * pocket.dropPosition.x * MiniBillar.GameConstants.PHYS_SCALE,
                            y: 0.7 * pocket.dropPosition.y * MiniBillar.GameConstants.PHYS_SCALE
                        }, 1.75 * t, Phaser.Easing.Linear.None, true);
                    if (ball.id === 0) {
                        if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                            pocketTween.onComplete.add(this.releaseCueBall, this, 0, [contactEvent]);
                        } else {
                            pocketTween.onComplete.add(function() {
                                this.tunnelContainer.removeChild(ball.mc);
                                ball.mc.pocketTween = false;
                                ball.velocity = new Billiard.Vector2D(0, 0);
                            }, this);
                        }
                    } else {
                        pocketTween.onComplete.add(function() {
                            this.tunnelContainer.removeChild(ball.mc);
                            ball.mc.pocketTween = false;
                            ball.velocity = new Billiard.Vector2D(0, 0);
                        }, this);
                    }
                }, this);
        }
        releaseCueBall(ball, tween, args) {
            const cueBall = MiniBillar.GameVars.ballArray[0];
            const contactEvent = args[0];
            const pocket = contactEvent.target;
            let outPocketId;
            let outVelocity;
            MiniBillar.GameManager.log(pocket.id);
            switch (pocket.id) {
                case 0:
                    outPocketId = 5;
                    outVelocity = new Billiard.Vector2D(-1, -1).normalize().times(200);
                    break;
                case 1:
                    outPocketId = 4;
                    outVelocity = new Billiard.Vector2D(0, -1).normalize().times(200);
                    break;
                case 2:
                    outPocketId = 3;
                    outVelocity = new Billiard.Vector2D(1, -1).normalize().times(200);
                    break;
                case 3:
                    outPocketId = 2;
                    outVelocity = new Billiard.Vector2D(-1, 1).normalize().times(200);
                    break;
                case 4:
                    outPocketId = 1;
                    outVelocity = new Billiard.Vector2D(0, 1).normalize().times(200);
                    break;
                case 5:
                    outPocketId = 0;
                    outVelocity = new Billiard.Vector2D(1, 1).normalize().times(200);
                    break;
                default:
            }
            const outPocket = MiniBillar.GameVars.pocketArray[outPocketId];
            const tweenTime = 200;
            this.game.add.tween(cueBall.mc.scale)
                .to({
                    x: 1,
                    y: 1
                }, tweenTime, Phaser.Easing.Linear.None, true);
            this.game.add.tween(cueBall.mc)
                .to({
                    x: outPocket.position.x * MiniBillar.GameConstants.PHYS_SCALE,
                    y: outPocket.position.y * MiniBillar.GameConstants.PHYS_SCALE
                }, tweenTime, Phaser.Easing.Linear.None, true)
                .onComplete.add(function() {
                    const x = cueBall.mc.x;
                    const y = cueBall.mc.y;
                    this.tunnelContainer.removeChild(cueBall.mc);
                    this.ballsContainer.add(cueBall.mc);
                    cueBall.position.x = x / MiniBillar.GameConstants.PHYS_SCALE;
                    cueBall.position.y = y / MiniBillar.GameConstants.PHYS_SCALE;
                    cueBall.velocity = outVelocity;
                    cueBall.active = true;
                    this.game.time.events.add(200, function() {
                        cueBall.mc.pocketTween = false;
                        cueBall.shadow.visible = true;
                    }, this);
                }, this);
        }
        addDebugObjectsContainer() {
            this.debugObjectContainer = new MiniBillar.DebugObjectsContainer(this.game);
            this.add(this.debugObjectContainer);
            for (let i = 0; i < MiniBillar.GameVars.pocketArray.length; i++) {
                this.debugObjectContainer.drawPoint(MiniBillar.GameVars.pocketArray[i].position, MiniBillar.DebugObjectsContainer.RED);
                this.debugObjectContainer.drawPoint(MiniBillar.GameVars.pocketArray[i].dropPosition, MiniBillar.DebugObjectsContainer.GREEN);
                this.debugObjectContainer.drawCircle(MiniBillar.GameVars.pocketArray[i].position, MiniBillar.GameConstants.POCKET_RADIUS, MiniBillar.DebugObjectsContainer.WHITE);
            }
            for (let i = 0; i < MiniBillar.GameVars.lineArray.length; i++) {
                this.debugObjectContainer.drawLine(MiniBillar.GameVars.lineArray[i].p1, MiniBillar.GameVars.lineArray[i].p2, MiniBillar.DebugObjectsContainer.GREEN);
                this.debugObjectContainer.drawLine(MiniBillar.GameVars.lineArray[i].p3, MiniBillar.GameVars.lineArray[i].p4, MiniBillar.DebugObjectsContainer.YELLOW);
                this.debugObjectContainer.drawLine(MiniBillar.GameVars.lineArray[i].p5, MiniBillar.GameVars.lineArray[i].p6, MiniBillar.DebugObjectsContainer.BLUE);
            }
        }
    }
    StageContainer.CUSHION_VERTEXES = [
        new Billiard.Point(-42e3 + MiniBillar.GameConstants.BALL_RADIUS, -21e3 + MiniBillar.GameConstants.BALL_RADIUS),
        new Billiard.Point(42e3 - MiniBillar.GameConstants.BALL_RADIUS, -21e3 + MiniBillar.GameConstants.BALL_RADIUS),
        new Billiard.Point(42e3 - MiniBillar.GameConstants.BALL_RADIUS, 21e3 - MiniBillar.GameConstants.BALL_RADIUS),
        new Billiard.Point(-42e3 + MiniBillar.GameConstants.BALL_RADIUS, 21e3 - MiniBillar.GameConstants.BALL_RADIUS),
        new Billiard.Point(-42e3 + MiniBillar.GameConstants.BALL_RADIUS, -21e3 + MiniBillar.GameConstants.BALL_RADIUS)
    ];
    MiniBillar.StageContainer = StageContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class Ball extends Phaser.Group {
        constructor(game, ballRadius, n, ballObject) {
            super(game, null, "ball");
            this.n = n;
            this.ballObject = ballObject;
            this.pocketTween = false;
            this.ballRotation = [1, 0, 0, 0];
            this.circRad = ballRadius;
            let spriteSheetPrefix;
            if (this.n <= 8) {
                this.ballType = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                spriteSheetPrefix = "solid_";
            } else {
                this.ballType = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                spriteSheetPrefix = "stripes_";
            }
            this.ballImage = new Phaser.Image(game, 0, 0, "texture_atlas_1", "solid_0.png");
            this.ballImage.anchor.set(.5);
            this.ballImage.width = 2 * this.circRad;
            this.ballImage.height = 2 * this.circRad;
            this.addChild(this.ballImage);
            if (this.ballType === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                this.ballImage.frameName = spriteSheetPrefix + this.n.toString() + ".png";
            } else {
                this.ballImage.frameName = spriteSheetPrefix + this.n.toString() + "_0.png";
            }
            this.spotHolder = new Phaser.Group(game);
            this.add(this.spotHolder);
            this.spot = new Phaser.Sprite(game, 0, 0, "texture_atlas_1");
            this.spot.anchor.set(.5);
            this.spot.frameName = "spot_" + n + ".png";
            this.spotHolder.addChild(this.spot);
            this.shade = new Phaser.Image(game, 0, 0, "texture_atlas_1", "shade.png");
            this.shade.anchor.set(.5);
            this.shade.width = 2.2 * this.circRad;
            this.shade.height = 2.2 * this.circRad;
            this.addChild(this.shade);
            this.updateRotation(10 * Math.random() - 5, 10 * Math.random() - 5, 10 * Math.random() - 5);
        }
        update() {
            if (MiniBillar.PoolState.currentInstance.victoryLayer || MiniBillar.PoolState.currentInstance.loseLayer) {
                if (this.pocketTween) {
                    MiniBillar.StageContainer.currentInstance.pauseGame();
                    this.pocketTween = false;
                }
                return;
            }
            if (this.pocketTween) {
                this.updateRotation(this.ballObject.velocity.x, this.ballObject.velocity.y, 0);
            }
            super.update();
        }
        updateRotation(t, s, h) {
            let r = Math.sqrt(t * t + h * h + s * s);
            if (r > 0.1) {
                this.ballRotation = this.rotateQuat(this.ballRotation, h / r, -t / r, s / r, r / this.circRad);
                this.ballRotation = this.normalize(this.ballRotation);
                this.renderBall(this.ballRotation);
            }
        }
        rotateQuat(t, s, h, i, a) {
            let o = Math.sqrt(s * s + h * h + i * i);
            let r = s / o;
            let e = h / o;
            let l = i / o;
            let p = Math.sin(.5 * a);
            let n = r * p;
            let d = e * p;
            let c = l * p;
            let M = Math.cos(.5 * a);
            let P = t[0];
            let y = t[1];
            let H = t[2];
            let R = t[3];
            let g = P * M + y * c - H * d + R * n;
            let b = -P * c + y * M + H * n + R * d;
            let u = P * d - y * n + H * M + R * c;
            let m = -P * n - y * d - H * c + R * M;
            return [g, b, u, m];
        }
        renderBall(q) {
            const qy = q[0];
            const qx = q[1];
            const qz = q[2];
            const qw = q[3];
            const rotationY = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz) + Math.PI;
            const rotationX = Math.asin(2 * qx * qy + 2 * qz * qw) + Math.PI;
            const test = qx * qy + qz * qw;
            if (!(test > .499 || test < -.499)) {
                this.angle = Billiard.Maths._180_DIV_PI * rotationY;
                this.shade.angle = -this.angle;
                if (this.ballType === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    const v = (rotationX - Billiard.Maths.PI_2) / Math.PI;
                    const rotationIndex = 41 - Math.round(41 * v);
                    this.ballImage.frameName = "stripes_" + (this.n) + "_" + rotationIndex.toString() + ".png";
                }
                if (this.spotHolder) {
                    const rotationZ = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz) + Math.PI;
                    if (rotationX < Billiard.Maths.PI_2 || rotationX > 3 * Billiard.Maths.PI_2) {
                        if (rotationZ > Billiard.Maths.PI_2 && rotationZ < 3 * Billiard.Maths.PI_2) {
                            this.spotHolder.y = this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = this.circRad * Math.sin(rotationZ);
                        } else {
                            this.spotHolder.y = -this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = -this.circRad * Math.sin(rotationZ);
                        }
                    } else {
                        if (rotationZ > Billiard.Maths.PI_2 && rotationZ < 3 * Billiard.Maths.PI_2) {
                            this.spotHolder.y = -this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = -this.circRad * Math.sin(rotationZ);
                        } else {
                            this.spotHolder.y = this.circRad * Math.cos(rotationZ) * Math.sin(rotationX);
                            this.spotHolder.x = this.circRad * Math.sin(rotationZ);
                        }
                    }
                    const dist = Math.sqrt(this.spotHolder.x * this.spotHolder.x + this.spotHolder.y * this.spotHolder.y);
                    const distRatio = dist / this.circRad;
                    const scaleY = Math.cos(distRatio * Billiard.Maths.PI_2);
                    const spotDir = Math.atan2(this.spotHolder.y, this.spotHolder.x);
                    if (scaleY < 0.1) {
                        this.spotHolder.visible = false;
                    } else {
                        const spotScale = 0.8;
                        this.spotHolder.visible = true;
                        this.spotHolder.scale.set(.8, scaleY * spotScale);
                    }
                    this.spotHolder.angle = Billiard.Maths._180_DIV_PI * spotDir + 90;
                    this.spot.angle = -this.spotHolder.angle;
                }
            }
        }
        normalize(t) {
            let s = Math.sqrt(t[0] * t[0] + t[1] * t[1] + t[2] * t[2] + t[3] * t[3]);
            return [t[0] / s, t[1] / s, t[2] / s, t[3] / s];
        }
    }
    MiniBillar.Ball = Ball;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class BallObject {
        constructor(game, n, x, y, active) {
            this.game = game;
            this.id = n;
            this.active = active;
            if (this.active) {
                this.shadow = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "shadow.png");
                this.shadow.anchor.set(.5);
            } else {
                this.shadow = null;
            }
            this.mc = new MiniBillar.Ball(this.game, MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE, n, this);
            this.position = new Billiard.Vector2D(x, y);
            this.velocity = new Billiard.Vector2D(0, 0);
            this.lastCollisionObject = null;
            this.firstContact = false;
            this.contactArray = [];
            this.waitingToTheRail = false;
            if (this.id === 0) {
                this.screw = 0;
                this.english = 0;
                this.deltaScrew = new Billiard.Vector2D(0, 0);
            }
            this.grip = 1;
            this.ySpin = 0;
            this.mc.x = this.position.x * MiniBillar.GameConstants.PHYS_SCALE;
            this.mc.y = this.position.y * MiniBillar.GameConstants.PHYS_SCALE;
            if (this.shadow) {
                this.shadow.x = this.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.x / 300);
                this.shadow.y = this.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            }
        }
        setPosition(x, y) {
            this.mc.x = x;
            this.mc.y = y;
            this.shadow.x = this.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.x / 300);
            this.shadow.y = this.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            this.position.x = this.mc.x / MiniBillar.GameConstants.PHYS_SCALE;
            this.position.y = this.mc.y / MiniBillar.GameConstants.PHYS_SCALE;
        }
        destroy() {
            this.mc.destroy();
            this.shadow.destroy();
        }
    }
    MiniBillar.BallObject = BallObject;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class BallsContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "balls-container");
            BallsContainer.currentInstance = this;
            this.shadowsContainer = new Phaser.Group(this.game);
            this.add(this.shadowsContainer);
        }
        destroy(destroyChildren, soft) {
            BallsContainer.currentInstance = null;
            super.destroy(destroyChildren, soft);
        }
        update() {
            if (!MiniBillar.GameVars.startMatch || !MiniBillar.GameVars.ballArray) {
                return;
            }
            super.update();
            let cueBall = MiniBillar.GameVars.ballArray[0];
            if (MiniBillar.GameVars.draggingCueBall) {
                cueBall.update();
            }
            if (MiniBillar.GameConstants.DEBUG) {
                MiniBillar.StageContainer.currentInstance.debugObjectContainer.drawCueBallTrajectoryPoint(cueBall.position, MiniBillar.DebugObjectsContainer.RED);
            }
        }
        startGame() {
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                if (MiniBillar.GameVars.ballArray[i].active) {
                    this.add(MiniBillar.GameVars.ballArray[i].mc);
                    this.shadowsContainer.add(MiniBillar.GameVars.ballArray[i].shadow);
                }
            }
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.alpha = 0;
                this.game.add.tween(this)
                    .to({
                        alpha: 1
                    }, 500, Phaser.Easing.Cubic.Out, true);
            }
        }
        newTurn() {
            const cueBall = MiniBillar.GameVars.ballArray[0];
            cueBall.firstContact = false;
        }
        ballHasBeenShot() {
            if (MiniBillar.GameConstants.DEBUG) {
                MiniBillar.StageContainer.currentInstance.debugObjectContainer.clearCueBallGraphics();
            }
        }
        removeBalls() {
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                this.remove(MiniBillar.GameVars.ballArray[i].mc);
                this.shadowsContainer.remove(MiniBillar.GameVars.ballArray[i].shadow);
            }
        }
        resetBalls() {
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                this.add(MiniBillar.GameVars.ballArray[i].mc);
                this.shadowsContainer.add(MiniBillar.GameVars.ballArray[i].shadow);
            }
        }
        setCueBall() {
            let cueBall = MiniBillar.GameVars.ballArray[0];
            if (!cueBall.active) {
                cueBall.active = true;
                cueBall.mc.pocketTween = false;
                cueBall.velocity = new Billiard.Vector2D(0, 0);
                cueBall.grip = 1;
                cueBall.ySpin = 0;
                cueBall.screw = 0;
                cueBall.english = 0;
                cueBall.deltaScrew = new Billiard.Vector2D(0, 0);
                let x = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][0];
                let y = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][1];
                let exceptionalPosition = false;
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                        while (!MiniBillar.CueBallObject.isValidPosition(x, y)) {
                            x = this.game.rnd.realInRange(-38000, 38000);
                            y = this.game.rnd.realInRange(-19000, 19000);
                            exceptionalPosition = true;
                        }
                    }
                }
                cueBall.position = new Billiard.Vector2D(x, y);
                cueBall.mc.scale.set(1);
                cueBall.mc.x = cueBall.position.x * MiniBillar.GameConstants.PHYS_SCALE;
                cueBall.mc.y = cueBall.position.y * MiniBillar.GameConstants.PHYS_SCALE;
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    if (exceptionalPosition) {
                        if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                            MiniBillar.MatchManagerPVP.sendCueBallPosition(cueBall.mc.x, cueBall.mc.y);
                        }
                    }
                }
                cueBall.shadow.visible = true;
                cueBall.shadow.x = cueBall.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (cueBall.mc.x / 300);
                cueBall.shadow.y = cueBall.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (cueBall.mc.y / 150);
                this.add(cueBall.mc);
                cueBall.mc.alpha = 0;
                this.game.add.tween(cueBall.mc)
                    .to({
                        alpha: 1
                    }, 300, Phaser.Easing.Cubic.Out, true);
            }
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                    MiniBillar.GameVars.draggingCueBall = true;
                    cueBall.addHandIcon();
                }
            }
        }
    }
    MiniBillar.BallsContainer = BallsContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class CueBallObject extends MiniBillar.BallObject {
        constructor(game, n, x, y) {
            super(game, n, x, y, true);
            this.cueBallBig = null;
            this.handIcon = null;
        }
        static changePosition(x, y) {
            let newX = x;
            let newY = y;
            let upperLeftCushionPoint = MiniBillar.StageContainer.CUSHION_VERTEXES[0];
            let lowerRightCushionPoint = MiniBillar.StageContainer.CUSHION_VERTEXES[2];
            if (x < upperLeftCushionPoint.x) {
                newX = upperLeftCushionPoint.x * .999;
            } else if (x > lowerRightCushionPoint.x) {
                newX = lowerRightCushionPoint.x * .999;
            }
            if (y < upperLeftCushionPoint.y) {
                newY = upperLeftCushionPoint.y * .999;
            } else if (y > lowerRightCushionPoint.y) {
                newY = lowerRightCushionPoint.y * .999;
            }
            if (MiniBillar.GameVars.firstShot && x > -21000) {
                newX = -21000;
            }
            for (let i = 1, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
                if (MiniBillar.GameVars.ballArray[i].active) {
                    let dx = MiniBillar.GameVars.ballArray[i].position.x - newX;
                    let dy = MiniBillar.GameVars.ballArray[i].position.y - newY;
                    let d = Math.sqrt(dx * dx + dy * dy);
                    if (d < MiniBillar.GameConstants.BALL_RADIUS * 2) {
                        return null;
                    }
                }
            }
            return {
                x: newX * MiniBillar.GameConstants.PHYS_SCALE,
                y: newY * MiniBillar.GameConstants.PHYS_SCALE
            };
        }
        static isValidPosition(x, y, id) {
            let isValid = true;
            let upperLeftCushionPoint = MiniBillar.StageContainer.CUSHION_VERTEXES[0];
            let lowerRightCushionPoint = MiniBillar.StageContainer.CUSHION_VERTEXES[2];
            if (MiniBillar.GameVars.firstShot) {
                if (x < upperLeftCushionPoint.x || y < upperLeftCushionPoint.y || x > -21000 || y > lowerRightCushionPoint.y) {
                    isValid = false;
                }
            } else {
                if (x < upperLeftCushionPoint.x || y < upperLeftCushionPoint.y || x > lowerRightCushionPoint.x || y > lowerRightCushionPoint.y) {
                    isValid = false;
                }
            }
            if (isValid) {
                for (let i = 1, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
                    if (MiniBillar.GameVars.ballArray[i].active) {
                        if (id && id === MiniBillar.GameVars.ballArray[i].id) {
                            continue;
                        }
                        let dx = MiniBillar.GameVars.ballArray[i].position.x - x;
                        let dy = MiniBillar.GameVars.ballArray[i].position.y - y;
                        let d = Math.sqrt(dx * dx + dy * dy);
                        if (d < MiniBillar.GameConstants.BALL_RADIUS * 2) {
                            isValid = false;
                            break;
                        }
                    }
                }
            }
            return isValid;
        }
        update() {
            if (MiniBillar.GameVars.draggingCueBall && this.cueBallBig && this.cueBallBig.alpha > 0) {
                let x = (this.game.input.activePointer.x - MiniBillar.StageContainer.currentInstance.x) * MiniBillar.GameVars.scaleXMultInverse;
                let y = (this.game.input.activePointer.y - MiniBillar.StageContainer.currentInstance.y) * MiniBillar.GameVars.scaleYMultInverse;
                let point = {
                    x: x,
                    y: y
                };
                point = CueBallObject.changePosition(x / MiniBillar.GameConstants.PHYS_SCALE, y / MiniBillar.GameConstants.PHYS_SCALE);
                if (point) {
                    this.cueBallBig.x = point.x;
                    this.cueBallBig.y = point.y;
                    this.mc.x = point.x;
                    this.mc.y = point.y;
                    this.shadow.x = this.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.x / 300);
                    this.shadow.y = this.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.y / 150);
                }
            }
            if (this.handIcon) {
                this.handIcon.x = this.mc.x + 30;
                this.handIcon.y = this.mc.y;
            }
        }
        setPositionReceived(x, y) {
            this.game.add.tween(this.mc)
                .to({
                    x: x,
                    y: y
                }, 200, Phaser.Easing.Linear.None, true);
            this.game.add.tween(this.shadow)
                .to({
                    x: x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (x / 300),
                    y: y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (y / 150)
                }, 200, Phaser.Easing.Linear.None, true)
                .onComplete.add(function() {
                    MiniBillar.CueContainer.currentInstance.showCueAndUpdatePos();
                    MiniBillar.MatchManager.cueBallSet(x, y);
                }, this);
            this.position.x = x / MiniBillar.GameConstants.PHYS_SCALE;
            this.position.y = y / MiniBillar.GameConstants.PHYS_SCALE;
        }
        setPositioOnShoot(x, y) {
            this.mc.x = x;
            this.mc.y = y;
            this.shadow.x = x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (x / 300);
            this.shadow.y = y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (y / 150);
            this.position.x = x / MiniBillar.GameConstants.PHYS_SCALE;
            this.position.y = y / MiniBillar.GameConstants.PHYS_SCALE;
        }
        addHandIcon() {
            if (this.handIcon) {
                this.handIcon.destroy();
                this.handIcon = null;
            }
            this.handIcon = new Phaser.Image(this.game, this.mc.x, this.mc.y, "texture_atlas_1", "hand-icon.png");
            this.handIcon.anchor.set(.5);
            this.handIcon.scale.set(.8);
            MiniBillar.StageContainer.currentInstance.add(this.handIcon);
            if (this.cueBallBig) {
                this.cueBallBig.destroy();
                this.cueBallBig = null;
            }
            this.cueBallBig = new Phaser.Image(this.game, this.mc.x, this.mc.y, "texture_atlas_1", "cue_ball.png");
            this.cueBallBig.anchor.set(.5);
            this.cueBallBig.scale.set(0.5);
            this.cueBallBig.alpha = 0;
            if (this.game.device.desktop) {
                const scaleDiff = this.mc.width * this.mc.scale.x / this.cueBallBig.width * this.cueBallBig.scale.x;
                this.cueBallBig.scale.set(scaleDiff);
            }
            this.cueBallBig.inputEnabled = true;
            this.cueBallBig.events.onInputDown.add(this.onDown, this);
            this.cueBallBig.events.onInputUp.add(this.onUp, this);
            MiniBillar.StageContainer.currentInstance.add(this.cueBallBig);
            this.handIcon.alpha = 0;
            this.game.add.tween(this.handIcon)
                .to({
                    alpha: 1
                }, 300, Phaser.Easing.Cubic.Out, true);
            this.game.add.tween(this.handIcon.scale)
                .to({
                    x: 0.9,
                    y: 0.9
                }, 500, Phaser.Easing.Cubic.InOut, true, 0, -1, true);
        }
        hideHandIcon() {
            if (!MiniBillar.GameVars.draggingCueBall) {
                return;
            }
            MiniBillar.GameVars.draggingCueBall = false;
            this.handIcon.destroy();
            this.handIcon = null;
            this.cueBallBig.destroy();
            this.cueBallBig = null;
        }
        onDown() {
            if (this.game.device.desktop) {
                const scaleDiff = this.mc.width * this.mc.scale.x / this.cueBallBig.width * this.cueBallBig.scale.x;
                this.cueBallBig.scale.set(scaleDiff);
                this.mc.alpha = 0;
            }
            MiniBillar.BallsContainer.currentInstance.bringToTop(this.mc);
            MiniBillar.StageContainer.currentInstance.hideCue("Moving cue ball");
            MiniBillar.StageContainer.currentInstance.hideGuide("Moving cue ball");
            this.handIcon.destroy();
            this.handIcon = null;
            this.cueBallBig.alpha = .65;
        }
        onUp() {
            if (!MiniBillar.GameVars.draggingCueBall) {
                return;
            }
            MiniBillar.StageContainer.currentInstance.showCue("Just placed white ball");
            this.cueBallBig.destroy();
            this.cueBallBig = null;
            this.addHandIcon();
            this.position.x = this.mc.x / MiniBillar.GameConstants.PHYS_SCALE;
            this.position.y = this.mc.y / MiniBillar.GameConstants.PHYS_SCALE;
            this.mc.alpha = 1;
            MiniBillar.MatchManager.cueBallSet(this.mc.x, this.mc.y);
        }
        onUpTimeOut() {
            if (!MiniBillar.GameVars.draggingCueBall) {
                return;
            }
            MiniBillar.GameVars.draggingCueBall = false;
            this.cueBallBig.destroy();
            this.cueBallBig = null;
            if (this.handIcon) {
                this.handIcon.destroy();
                this.handIcon = null;
            }
            this.mc.x = this.position.x * MiniBillar.GameConstants.PHYS_SCALE;
            this.mc.y = this.position.y * MiniBillar.GameConstants.PHYS_SCALE;
            this.shadow.x = this.mc.x + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.x / 300);
            this.shadow.y = this.mc.y + .35 * MiniBillar.GameConstants.BALL_RADIUS * MiniBillar.GameConstants.PHYS_SCALE * (this.mc.y / 150);
            this.mc.alpha = 1;
            MiniBillar.MatchManager.cueBallSet(this.mc.x, this.mc.y);
        }
    }
    MiniBillar.CueBallObject = CueBallObject;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class CueBallSpinButton extends Phaser.Group {
        constructor(game) {
            super(game, null, "cue-ball-spin-button");
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.cueBallButton = new Phaser.Button(this.game, 0, 0, "texture_atlas_1", this.onUpCueBallButton, this);
            this.cueBallButton.forceOut = true;
            this.cueBallButton.setFrames("btn_spin_pressed.png", "btn_spin.png", "btn_spin_pressed.png", "btn_spin.png");
            if (this.game.device.touch) {
                this.cueBallButton.onInputDown.add(function() {
                    MiniBillar.GameVars.GUIButtonDown = true;
                    this.cueBallButton.scale.set(this.cueBallButton.scale.x * 1.1, this.cueBallButton.scale.y * 1.1);
                }, this, 5);
            }
            this.cueBallButton.onInputOver.add(function() {
                this.cueBallButton.scale.set(this.cueBallButton.scale.x * 1.1, this.cueBallButton.scale.y * 1.1);
            }, this);
            this.cueBallButton.onInputOut.add(function() {
                this.cueBallButton.scale.set(1, 1);
            }, this);
            this.cueBallButton.anchor.set(.5);
            this.add(this.cueBallButton);
            this.redDot = new Phaser.Graphics(this.game, 0, 0);
            this.redDot.beginFill(0xFA2E63);
            this.redDot.drawCircle(0, 0, 7);
            this.add(this.redDot);
        }
        disable() {
            this.cueBallButton.alpha = .6;
            this.cueBallButton.inputEnabled = false;
            this.redDot.x = 0;
            this.redDot.y = 0;
        }
        enable() {
            this.cueBallButton.alpha = 1;
            this.cueBallButton.inputEnabled = true;
            this.redDot.x = 0;
            this.redDot.y = 0;
        }
        setRedPointPosition(english, verticalSpin) {
            if (english && verticalSpin) {
                const x = MiniBillar.GUI.CUE_BALL_BUTTON_SCALE * MiniBillar.SpinCircleLayer.SPIN_CIRCLE_RADIUS * english;
                const y = -MiniBillar.GUI.CUE_BALL_BUTTON_SCALE * MiniBillar.SpinCircleLayer.SPIN_CIRCLE_RADIUS * verticalSpin;
                this.game.add.tween(this.cueBallButton.scale)
                    .to({
                        x: 1.125,
                        y: 1.125
                    }, 175, Phaser.Easing.Cubic.Out, true, 0, 0, true);
                this.game.add.tween(this.redDot)
                    .to({
                        x: x,
                        y: y
                    }, 350, Phaser.Easing.Cubic.Out, true, 400);
            } else {
                this.redDot.x = MiniBillar.GUI.CUE_BALL_BUTTON_SCALE * MiniBillar.SpinCircleLayer.SPIN_CIRCLE_RADIUS * MiniBillar.GameVars.english;
                this.redDot.y = -MiniBillar.GUI.CUE_BALL_BUTTON_SCALE * MiniBillar.SpinCircleLayer.SPIN_CIRCLE_RADIUS * MiniBillar.GameVars.verticalSpin;
            }
        }
        onUpCueBallButton() {
            this.cueBallButton.scale.set(1, 1);
            if (MiniBillar.GameVars.shotRunning || (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE && MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.PLAYER)) {
                return;
            }
            MiniBillar.MatchManager.showSpinCircleLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
    }
    MiniBillar.CueBallSpinButton = CueBallSpinButton;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class ForceSettingContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "force-setting-container");
            this.x = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 0 : MiniBillar.GameVars.gameWidth;
            this.y = MiniBillar.GameVars.gameHeight / 2 + 40;
            this.canMove = true;
            this.initialY = 0;
            this.powerBarEmpty = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_1", "power_bar_empty.png");
            this.powerBarEmpty.anchor.set(0, .5);
            this.powerBarEmpty.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.powerBarEmpty.inputEnabled = true;
            this.powerBarEmpty.events.onInputDown.add(this.onDownPowerBarEmpty, this);
            this.powerBarEmpty.events.onInputUp.add(this.onUpPowerBarEmpty, this);
            this.add(this.powerBarEmpty);
            this.maskHeight = 505 * MiniBillar.GameVars.scaleYMult;
            this.powerMask = new Phaser.Graphics(this.game, 0, -this.maskHeight * 0.5);
            this.powerMask.beginFill(0xffffff);
            this.powerMask.drawRect(0, 0, this.powerBarEmpty.width, this.maskHeight);
            this.add(this.powerMask);
            this.forceBar = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_1", "power_bar_full.png");
            this.forceBar.anchor.set(0, .5);
            this.forceBar.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.forceBar.mask = this.powerMask;
            this.add(this.forceBar);
            this.cue = new Phaser.Sprite(this.game, this.powerBarEmpty.x + this.powerBarEmpty.width * 0.5 - 8, 0, "texture_atlas_1", "cue_power.png");
            this.cue.anchor.set(.5);
            this.cue.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(this.cue);
            if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.RIGHT) {
                this.powerBarEmpty.scale.x *= -1;
                this.forceBar.scale.x *= -1;
                this.powerMask.scale.x *= -1;
                this.cue.scale.x *= -1;
                this.cue.x *= -1;
            }
            this.visible = false;
        }
        update() {
            if (MiniBillar.CueContainer.currentInstance.settingPower && this.canMove) {
                let localY = this.game.input.activePointer.y - this.y - this.initialY;
                localY += 230;
                localY = Phaser.Math.clamp(localY, 0, 430);
                MiniBillar.CueContainer.currentInstance.impulseFactor = Billiard.Maths.fixNumber(localY / 430);
                this.cue.y = localY;
                this.powerMask.scale.y = 1 - (localY / 430);
                if (this.powerMask.scale.y === 0) {
                    this.powerMask.scale.y = .001;
                }
            }
        }
        changeSide() {
            this.powerBarEmpty.scale.x *= -1;
            this.forceBar.scale.x *= -1;
            this.powerMask.scale.x *= -1;
            this.cue.scale.x *= -1;
            this.cue.x *= -1;
            if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT) {
                if (this.canMove) {
                    this.x = 0;
                } else {
                    this.x = -100;
                }
            } else {
                if (this.canMove) {
                    this.x = MiniBillar.GameVars.gameWidth;
                } else {
                    this.x = MiniBillar.GameVars.gameWidth + 100;
                }
            }
        }
        show() {
            this.visible = true;
        }
        hide() {
            this.canMove = false;
            this.game.add.tween(this.cue)
                .to({
                    y: 0
                }, 150, Phaser.Easing.Cubic.Out, true);
            this.game.add.tween(this)
                .to({
                    x: this.x - (100 * (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 1 : -1))
                }, 200, Phaser.Easing.Cubic.In, true, 100);
            this.game.add.tween(this.powerMask.scale)
                .to({
                    y: 1
                }, 150, Phaser.Easing.Cubic.Out, true);
        }
        disable() {
            MiniBillar.CueContainer.currentInstance.settingPower = false;
            MiniBillar.CueContainer.currentInstance.impulseFactor = 0;
        }
        reset() {
            this.canMove = true;
            this.powerMask.scale.y = 1;
            this.cue.y = 0;
            this.game.add.tween(this)
                .to({
                    x: MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT ? 0 : MiniBillar.GameVars.gameWidth
                }, 200, Phaser.Easing.Cubic.Out, true);
            this.disable();
        }
        onDownPowerBarEmpty() {
            if (MiniBillar.StageContainer.currentInstance.selectPockets.canSelect) {
                return;
            }
            this.initialY = this.game.input.activePointer.y - 110;
            MiniBillar.CueContainer.currentInstance.settingPower = true;
        }
        onUpPowerBarEmpty() {
            if (MiniBillar.StageContainer.currentInstance.selectPockets.canSelect) {
                return;
            }
            MiniBillar.CueContainer.currentInstance.settingPower = false;
            if (MiniBillar.CueContainer.currentInstance.impulseFactor > 0) {
                this.hide();
                MiniBillar.CueContainer.currentInstance.shoot();
            }
        }
    }
    MiniBillar.ForceSettingContainer = ForceSettingContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class GUI extends Phaser.Group {
        constructor(game) {
            super(game, null, "gui");
            if (MiniBillar.GameConstants.SHOW_DEV_BUTTONS_ON_SOLO && MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                const winButton = new Phaser.Button(this.game, 920, 25, "texture_atlas_0");
                winButton.anchor.set(1.0, 0.5);
                winButton.inputEnabled = true;
                winButton.events.onInputDown.add(this.onClickForceWin, this);
                winButton.setFrames("btn_force_win_on.png", "btn_force_win_off.png", "btn_force_win_on.png");
                winButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(winButton);
                const loseButton = new Phaser.Button(this.game, 920, 75, "texture_atlas_0");
                loseButton.anchor.set(1.0, 0.5);
                loseButton.inputEnabled = true;
                loseButton.events.onInputDown.add(this.onClickForceLose, this);
                loseButton.setFrames("btn_force_lose_on.png", "btn_force_lose_off.png", "btn_force_lose_on.png");
                loseButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(loseButton);
                const resetButton = new Phaser.Button(this.game, 150, 40, "texture_atlas_0");
                resetButton.anchor.set(1.0, 0.5);
                resetButton.inputEnabled = true;
                resetButton.events.onInputDown.add(this.onClickForceReset, this);
                resetButton.setFrames("btn_menu_on.png", "btn_menu_off.png", "btn_menu_on.png");
                resetButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(resetButton);
            } else if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                this.chatButton = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 - 40 * MiniBillar.GameVars.scaleXMult, 18, "texture_atlas_1", this.onClickChat, this);
                this.chatButton.setFrames("btn_chat_on.png", "btn_chat_off.png", "btn_chat_on.png");
                this.chatButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.chatButton.anchor.set(.5);
                if (this.game.device.touch) {
                    this.chatButton.onInputDown.add(function() {
                        MiniBillar.GameVars.GUIButtonDown = true;
                        this.chatButton.scale.set(this.chatButton.scale.x * 1.1, this.chatButton.scale.y * 1.1);
                    }, this, 5);
                }
                this.chatButton.onInputOver.add(function() {
                    this.chatButton.scale.set(this.chatButton.scale.x * 1.1, this.chatButton.scale.y * 1.1);
                }, this);
                this.chatButton.onInputOut.add(function() {
                    this.chatButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                }, this);
                this.chatButton.forceOut = true;
                this.add(this.chatButton);
                if (MiniBillar.GameConstants.SHOW_PVBOT_CHEAT_BUTTONS && MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                    MiniBillar.GameVars.laserGuideActive = false;
                    MiniBillar.GameVars.sabotageBot = false;
                    const superGuideButton = new Phaser.Button(this.game, 920, 25, "texture_atlas_0");
                    superGuideButton.anchor.set(1.0, 0.5);
                    superGuideButton.inputEnabled = true;
                    superGuideButton.events.onInputDown.add(this.onClickActivateSuperGuide, this);
                    superGuideButton.setFrames("btn_laserGuide_pressed.png", "btn_laserGuide.png", "btn_laserGuide_pressed.png");
                    superGuideButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                    this.add(superGuideButton);
                    const sabotageBotButton = new Phaser.Button(this.game, 920, 75, "texture_atlas_0");
                    sabotageBotButton.anchor.set(1.0, 0.5);
                    sabotageBotButton.inputEnabled = true;
                    sabotageBotButton.events.onInputDown.add(this.onClickActivateSabotageBot, this);
                    sabotageBotButton.setFrames("btn_bot_sabotage_pressed.png", "btn_bot_sabotage.png", "btn_bot_sabotage_pressed.png");
                    sabotageBotButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                    this.add(sabotageBotButton);
                }
            }
            const pauseButton = new Phaser.Button(this.game, 38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1");
            pauseButton.inputEnabled = true;
            pauseButton.anchor.set(0.5);
            pauseButton.events.onInputUp.add(this.onClickPause, this);
            if (this.game.device.touch) {
                pauseButton.onInputDown.add(function() {
                    MiniBillar.GameVars.GUIButtonDown = true;
                    pauseButton.scale.set(pauseButton.scale.x * 1.1, pauseButton.scale.y * 1.1);
                }, this, 5);
            }
            pauseButton.onInputOver.add(function() {
                pauseButton.scale.set(pauseButton.scale.x * 1.1, pauseButton.scale.y * 1.1);
            }, this);
            pauseButton.onInputOut.add(function() {
                pauseButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            pauseButton.setFrames("btn_pause_pressed.png", "btn_pause.png", "btn_pause_pressed.png");
            pauseButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(pauseButton);
            this.cueBallSpinButton = new MiniBillar.CueBallSpinButton(this.game);
            this.cueBallSpinButton.x = (MiniBillar.GameVars.gameWidth - 37 * MiniBillar.GameVars.scaleXMult);
            this.cueBallSpinButton.y = 37 * MiniBillar.GameVars.scaleYMult;
            this.add(this.cueBallSpinButton);
            if (this.game.device.touch) {
                this.forceSettingContainer = new MiniBillar.ForceSettingContainer(this.game);
                this.add(this.forceSettingContainer);
            } else {
                this.forceSettingContainer = null;
            }
        }
        setRedPointPosition(english, verticalSpin) {
            this.cueBallSpinButton.setRedPointPosition(english, verticalSpin);
        }
        start() {
            if (this.game.device.touch) {
                if (this.forceSettingContainer) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    } else if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                }
            }
            this.checkCueBallButtonValidity();
        }
        newTurn() {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                this.cueBallSpinButton.enable();
            } else {
                this.cueBallSpinButton.disable();
            }
            if (this.game.device.touch) {
                if (this.forceSettingContainer) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    } else if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                        this.forceSettingContainer.reset();
                        this.forceSettingContainer.show();
                    }
                }
            }
            this.checkCueBallButtonValidity();
            MiniBillar.MatchManager.resetSpinCircleLayer();
        }
        disableSpinButton() {
            this.cueBallSpinButton.disable();
        }
        hideChatButton() {
            this.chatButton.visible = false;
        }
        showChatButton() {
            this.chatButton.visible = true;
        }
        checkCueBallButtonValidity() {
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                    this.cueBallSpinButton.enable();
                } else {
                    this.cueBallSpinButton.disable();
                }
            } else {
                this.cueBallSpinButton.enable();
            }
        }
        onClickPause(b) {
            b.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            MiniBillar.MatchManager.showPauseLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickForceWin() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameVars.playerPoints = MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD + 1;
                MiniBillar.MatchManagerSolo.endSoloGame(MiniBillar.GameConstants.PLAYER_WIN);
            }
        }
        onClickForceLose() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameVars.playerPoints = 0;
                MiniBillar.MatchManagerSolo.endSoloGame(MiniBillar.GameConstants.PLAYER_LOSE);
            }
        }
        onClickForceReset() {
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
                MiniBillar.MatchManagerSolo.reset();
            }
        }
        onClickActivateSuperGuide() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameVars.laserGuideActive = !MiniBillar.GameVars.laserGuideActive;
            console.log(MiniBillar.GameVars.laserGuideActive ? "Laser cue guide active" : "Laser cue guide inactive");
        }
        onClickActivateSabotageBot() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameVars.sabotageBot = !MiniBillar.GameVars.sabotageBot;
            console.log(MiniBillar.GameVars.sabotageBot ? "Bot will fail" : "Bot back to normal");
        }
        onClickChat() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            this.chatButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            MiniBillar.PoolState.currentInstance.showChatLayer();
        }
    }
    GUI.CUE_BALL_BUTTON_SCALE = .13;
    MiniBillar.GUI = GUI;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class SelectPockets extends Phaser.Group {
        constructor(game) {
            super(game, null, "select-pocket");
            this.canSelect = false;
            this.selectedPocketId = -1;
            this.pockets = [];
            for (let i = 0; i < 6; i++) {
                const x = MiniBillar.GameVars.pocketArray[i].position.x * MiniBillar.GameConstants.PHYS_SCALE;
                const y = MiniBillar.GameVars.pocketArray[i].position.y * MiniBillar.GameConstants.PHYS_SCALE;
                let pocket = new Phaser.Image(this.game, x, y, "texture_atlas_1", "pocket_mark.png");
                pocket.anchor.set(0.5);
                pocket.name = MiniBillar.GameVars.pocketArray[i].id.toString();
                pocket.inputEnabled = true;
                pocket.events.onInputUp.add(this.onPocketDown, this);
                this.add(pocket);
                this.pockets.push(pocket);
            }
            this.visible = false;
        }
        showSelectPockets() {
            if (this.visible && this.alpha !== .8) {
                return;
            }
            this.alpha = 1;
            this.hideSelectPockets();
            MiniBillar.GameVars.pocketIdWhereBlackFell = -1;
            MiniBillar.StageContainer.currentInstance.hideCue("Showing select pockets");
            MiniBillar.StageContainer.currentInstance.hideGuide("Showing select pockets");
            this.visible = true;
            this.canSelect = true;
            this.tweens = [];
            for (let i = 0; i < 6; i++) {
                const tween = this.game.add.tween(this.pockets[i])
                    .to({
                        alpha: [0, 1]
                    }, 2000, Phaser.Easing.Linear.None, true, 0, -1);
                this.tweens.push(tween);
            }
        }
        hideSelectPockets() {
            if (!this.visible) {
                return;
            }
            this.visible = false;
            for (let i = 0; i < 6; i++) {
                this.game.tweens.remove(this.tweens[i]);
                this.pockets[i].alpha = 1;
            }
        }
        setRivalPocket(pocketId) {
            this.setSelectedPocket(pocketId, false);
        }
        resetSelectedPocket() {
            this.selectedPocketId = -1;
        }
        setSelectedPocket(pocketId, showCueAndGuide = true) {
            if (!this.canSelect) {
                return;
            }
            this.canSelect = false;
            if (showCueAndGuide) {
                MiniBillar.StageContainer.currentInstance.showCue("Select pockets set");
                MiniBillar.StageContainer.currentInstance.showGuide("Select pockets set");
            }
            for (let i = 0; i < 6; i++) {
                this.game.tweens.remove(this.tweens[i]);
                if (parseInt(this.pockets[i].name) === pocketId) {
                    this.pockets[i].alpha = .6;
                } else {
                    this.pockets[i].alpha = 0;
                }
            }
            this.selectedPocketId = pocketId;
            MiniBillar.MatchManager.pocketSelected(pocketId);
        }
        onPocketDown(img) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            const pocketId = parseInt(img.name);
            this.setSelectedPocket(pocketId);
        }
    }
    MiniBillar.SelectPockets = SelectPockets;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class SpinCircleLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "spin-circle");
            SpinCircleLayer.currentInstance = this;
            SpinCircleLayer.discardClick = false;
            this.canMove = false;
            let transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .8;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputUp.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const ballContainer = new Phaser.Group(this.game);
            ballContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            ballContainer.x = MiniBillar.GameVars.gameWidth / 2;
            ballContainer.y = MiniBillar.GameVars.gameHeight / 2;
            this.add(ballContainer);
            const circle = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "cue_ball.png");
            circle.anchor.set(.5);
            circle.inputEnabled = true;
            circle.input.pixelPerfectClick = true;
            circle.input.pixelPerfectAlpha = 0.5;
            circle.events.onInputDown.add(this.onDownCircle, this);
            circle.events.onInputUp.add(this.onUpCircle, this);
            circle.events.onInputOut.add(this.onUpCircle, this);
            ballContainer.add(circle);
            this.redDot = new Phaser.Graphics(this.game, MiniBillar.GameVars.english, MiniBillar.GameVars.verticalSpin);
            this.redDot.beginFill(0xf1004f);
            this.redDot.drawCircle(0, 0, 40);
            ballContainer.add(this.redDot);
            this.alpha = 0;
            this.visible = false;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, 400, Phaser.Easing.Cubic.Out, true);
        }
        show() {
            this.visible = true;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, 400, Phaser.Easing.Cubic.Out, true);
        }
        hide() {
            SpinCircleLayer.discardClick = false;
            this.visible = false;
            this.alpha = 0;
        }
        reset() {
            this.redDot.scale.set(1, 1);
            this.redDot.position.set(0, 0);
        }
        destroy() {
            SpinCircleLayer.currentInstance = null;
            SpinCircleLayer.discardClick = false;
            super.destroy();
        }
        update() {
            super.update();
            if (this.canMove) {
                this.redDot.scale.set(3, 3);
                const x = (this.game.input.activePointer.x - MiniBillar.GameVars.gameWidth / 2) * MiniBillar.GameVars.scaleXMultInverse;
                const y = (this.game.input.activePointer.y - MiniBillar.GameVars.gameHeight / 2) * MiniBillar.GameVars.scaleYMultInverse;
                const d = Math.sqrt(x * x + y * y);
                if (d < SpinCircleLayer.SPIN_CIRCLE_RADIUS) {
                    this.redDot.position.set(x, y);
                }
            }
        }
        onDownTransparentLayer() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            const english = Math.floor(1000 * this.redDot.x / SpinCircleLayer.SPIN_CIRCLE_RADIUS) / 1000;
            const verticalSpin = -Math.floor(1000 * this.redDot.y / SpinCircleLayer.SPIN_CIRCLE_RADIUS) / 1000;
            MiniBillar.MatchManager.hideSpinCircleLayer(english, verticalSpin);
        }
        onDownCircle() {
            this.canMove = true;
        }
        onUpCircle() {
            this.canMove = false;
            this.redDot.scale.set(1, 1);
        }
    }
    SpinCircleLayer.currentInstance = null;
    SpinCircleLayer.discardClick = false;
    SpinCircleLayer.SPIN_CIRCLE_RADIUS = 160;
    MiniBillar.SpinCircleLayer = SpinCircleLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class AvatarBubble extends Phaser.Group {
        constructor(game, imageName, x, y, useTimer) {
            super(game, null, "avatar-bubble");
            this.game = game;
            this.x = x;
            this.y = y;
            this.useTimer = useTimer;
            const bubbleRadiusOuter = 81;
            const bubbleRadiusInner = 74;
            const bubbleBorder = new Phaser.Graphics(this.game);
            bubbleBorder.beginFill(0xd3f1f7);
            bubbleBorder.drawCircle(0, 0, bubbleRadiusOuter);
            this.add(bubbleBorder);
            if (this.useTimer) {
                this.timerSprite = new Phaser.Sprite(this.game, 0, 0, "texture_atlas_1", "timer_60.png");
                this.timerSprite.scale.set(bubbleRadiusOuter / this.timerSprite.width);
                this.timerSprite.anchor.set(.5);
                this.add(this.timerSprite);
            }
            this.avatarImage = new Phaser.Image(this.game, 0, 0, "texture_atlas_5", imageName + ".png");
            this.avatarImage.scale.set(bubbleRadiusInner / this.avatarImage.width);
            this.avatarImage.anchor.set(.5, .325);
            this.avatarImage.scale.set(.425);
            this.add(this.avatarImage);
            const mask = new Phaser.Graphics(this.game);
            mask.beginFill(0xffffff);
            mask.drawCircle(0, 0, bubbleRadiusInner);
            this.add(mask);
            this.avatarImage.mask = mask;
        }
        hideTimer(skipTween = false, timeout) {
            if (!this.useTimer || !this.timerSprite.visible) {
                return;
            }
            if (skipTween) {
                this.timerSprite.visible = false;
            } else {
                if (timeout) {
                    this.timerSprite.frameName = "timer_1.png";
                }
                this.game.add.tween(this.timerSprite.scale).to({
                        x: 1.2,
                        y: 1.2
                    }, 150, Phaser.Easing.Quadratic.Out, true)
                    .onComplete.add(function() {
                        this.game.add.tween(this.timerSprite.scale).to({
                                x: .5,
                                y: .5
                            }, 750, Phaser.Easing.Quadratic.In, true)
                            .onComplete.add(function() {
                                this.timerSprite.visible = false;
                            }, this);
                    }, this);
            }
        }
        showTimer() {
            if (!this.useTimer) {
                return;
            }
            this.timerSprite.scale.set(1);
            this.timerSprite.visible = true;
        }
        setTimerProgress(frame) {
            if (!this.useTimer) {
                return;
            }
            frame = Phaser.Math.clamp(frame, 1, 60);
            this.timerSprite.frameName = "timer_" + frame + ".png";
        }
        setFrameName(frameName) {
            this.avatarImage.frameName = frameName;
        }
        setAlpha(alpha) {
            this.avatarImage.alpha = alpha;
        }
    }
    MiniBillar.AvatarBubble = AvatarBubble;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class EmoticonBalloon extends Phaser.Group {
        constructor(game, isPlayer) {
            super(game, null, "emoticon-balloon");
            this.isPlayer = isPlayer;
            this.visible = false;
            this.scale.set(0);
            const balloon = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "emoticon_balloon.png");
            balloon.anchor.set(.5);
            if (!isPlayer) {
                balloon.scale.x = -1;
            }
            this.add(balloon);
            this.emoticon = new Phaser.Image(this.game, balloon.x, balloon.y + 4, "texture_atlas_5");
            this.emoticon.anchor.set(.5);
            this.add(this.emoticon);
        }
        update() {
            super.update();
            if (this.visible) {
                this.f++;
                if (this.f === 300) {
                    this.hide();
                }
            }
        }
        showEmoticon(emoticonID) {
            emoticonID = emoticonID || 1;
            this.f = 0;
            this.emoticon.frameName = "emoticon_" + emoticonID + ".png";
            this.visible = true;
            this.scale.set(0);
            let delay = this.isPlayer ? 250 : 0;
            this.game.add.tween(this.scale)
                .to({
                    x: 1,
                    y: 1
                }, 400, Phaser.Easing.Elastic.Out, true, delay);
        }
        hide() {
            this.game.add.tween(this.scale)
                .to({
                    x: 0,
                    y: 0
                }, 750, Phaser.Easing.Elastic.In, true)
                .onComplete.add(function() {
                    this.visible = false;
                    if (this.isPlayer) {
                        MiniBillar.PoolState.currentInstance.onPlayerEmoticonShown();
                    }
                }, this);
        }
    }
    MiniBillar.EmoticonBalloon = EmoticonBalloon;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class HUD extends Phaser.Group {
        constructor(game) {
            super(game, null, "hud");
            this.x = MiniBillar.GameVars.gameWidth / 2;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.sumPoints = false;
            this.counter = 0;
            this.timerSXOffset = 14;
            this.sidesAssigned = false;
            this.sumTime = false;
            this.counterTime = 0;
            this.updateNonSOLOClock = false;
            const hudBg = new Phaser.Image(this.game, 0, 0, "texture_atlas_1", "hudBg.png");
            hudBg.anchor.set(.5, 1);
            hudBg.angle = 180;
            this.add(hudBg);
            this.matchDataContainer = this.game.add.group();
            this.add(this.matchDataContainer);
            this.matchDataContainer.y = -20;
            this.pocketedBalls = [];
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.createSoloModeHud();
                this.superText = new Phaser.Image(this.game, 0, MiniBillar.GameVars.gameHeight * .4, "texture_atlas_1", "superText.png");
                this.superText.anchor.set(.5);
                this.superText.scale.set(0);
                this.superText.alpha = 0;
                this.add(this.superText);
                this.comboText = new Phaser.Image(this.game, 0, MiniBillar.GameVars.gameHeight * .4, "texture_atlas_1", "comboText.png");
                this.comboText.anchor.set(.5);
                this.comboText.scale.set(0);
                this.comboText.alpha = 0;
                this.add(this.comboText);
                this.comboTextTween1 = null;
                this.comboTextTween2 = null;
            } else {
                this.createPlayersInfoBar(MiniBillar.GameVars.gameData.playerData, MiniBillar.GameVars.adversaryData);
                this.vs = new Phaser.Image(this.game, 0, 65, "texture_atlas_1", "vs.png");
                this.vs.anchor.set(.5);
                this.matchDataContainer.add(this.vs);
                this.createPocketedBallsSetsNonSOLO();
                this.createEmoticonBalloons();
            }
        }
        start() {
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE && MiniBillar.GameVars.firstShot) {
                this.animatePlayerDataOnStart();
                this.updateNonSOLOClock = true;
                this.turnStartTime = new Date();
            }
        }
        update() {
            super.update();
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.updateSoloScore();
            } else {
                if (this.updateNonSOLOClock) {
                    if (MiniBillar.GameVars.gameOver) {
                        this.updateNonSOLOClock = false;
                    }
                    const currentTime = new Date();
                    const timeDifference = this.turnStartTime.getTime() - currentTime.getTime();
                    const halfSecondsPassedDuringTurn = Math.floor(Math.abs(timeDifference / 500));
                    if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                        this.playerAvatarBubble.setTimerProgress((MiniBillar.GameVars.timerPVP * 2) - halfSecondsPassedDuringTurn);
                    } else {
                        this.adversaryAvatarBubble.setTimerProgress((MiniBillar.GameVars.timerPVP * 2) - halfSecondsPassedDuringTurn);
                    }
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                        if ((MiniBillar.GameVars.timerPVP * 1000) + timeDifference < 0) {
                            MiniBillar.RulesManager.timeOut();
                        }
                    }
                }
            }
        }
        newTurn() {
            for (let ballId of this.pocketedBalls) {
                this.updateBallSet(ballId);
            }
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                this.updateNonSOLOClock = true;
                this.turnStartTime = new Date();
            }
            if (this.sidesAssigned) {
                this.pocketedBalls = [];
            }
        }
        ballPocketed(id) {
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.sumPoints = true;
                if (id !== 0) {
                    this.sumTime = true;
                }
            } else if (id === 8 || id === 0) {
                return;
            }
            this.pocketedBalls.push(id);
            this.updateBallSet(id);
        }
        assignSidesForNonSOLO(leftSideType) {
            this.populateBallSetNonSOLO(leftSideType !== MiniBillar.GameConstants.BALL_TYPE_SOLID);
        }
        focusOnActivePortrait(startingGame) {
            const playerTurn = MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER;
            this.playerAvatarBubble.setAlpha(playerTurn ? 1 : .45);
            this.adversaryAvatarBubble.setAlpha(playerTurn ? .45 : 1);
            if (playerTurn) {
                this.playerAvatarBubble.setTimerProgress(60);
                this.adversaryAvatarBubble.hideTimer(startingGame, true);
                this.playerAvatarBubble.showTimer();
            } else {
                this.adversaryAvatarBubble.setTimerProgress(60);
                this.playerAvatarBubble.hideTimer(startingGame, true);
                this.adversaryAvatarBubble.showTimer();
            }
        }
        hideNonSOLOTimers() {
            this.updateNonSOLOClock = false;
            if (this.playerAvatarBubble.visible) {
                this.playerAvatarBubble.hideTimer(false, false);
            }
            if (this.adversaryAvatarBubble.visible) {
                this.adversaryAvatarBubble.hideTimer(false, false);
            }
        }
        updateBallsHUD() {
            this.ballPocketed();
        }
        updateSoloTimer() {
            if (!this.sumTime) {
                this.timer.text = (Math.max(MiniBillar.GameVars.timerSolo, 0)) + "";
                this.updateTimerSLabel();
                if (MiniBillar.GameVars.timerSolo <= 20) {
                    MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
                } else {
                    MiniBillar.AudioManager.stopEffect(MiniBillar.AudioManager.TIME_RUNNING_OUT);
                }
            }
        }
        stopClock() {
            if (this.updateNonSOLOClock) {
                this.updateNonSOLOClock = false;
            }
        }
        showEmoticon(emoticonID, isPlayer) {
            if (isPlayer) {
                this.playerEmoticonBalloon.showEmoticon(emoticonID);
            } else {
                this.adversaryEmoticonBalloon.showEmoticon(emoticonID);
            }
        }
        showComboEffect(delay = 0) {
            this.comboTextTween1 = this.game.add.tween(this.comboText.scale)
                .to({
                    x: 1,
                    y: 1
                }, 600, Phaser.Easing.Elastic.Out, true, delay);
            this.comboTextTween1.onStart.add(function() {
                this.createExplosionArray(this.comboText.x, this.comboText.y + 50, 10);
            }, this);
            this.game.add.tween(this.comboText)
                .to({
                    alpha: 1
                }, 400, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function() {
                    this.comboTextTween2 = this.game.add.tween(this.comboText)
                        .to({
                            alpha: 0
                        }, 400, Phaser.Easing.Cubic.Out, true, 1800)
                        .onComplete.add(function() {
                            this.comboText.scale.set(0);
                        }, this);
                }, this);
        }
        showSuperComboEffect(delay) {
            this.game.add.tween(this.superText.scale)
                .to({
                    x: 1,
                    y: 1
                }, 600, Phaser.Easing.Elastic.Out, true, delay);
            if (this.comboTextTween1) {
                this.comboTextTween1.pendingDelete = true;
            }
            if (this.comboTextTween2) {
                this.comboTextTween2.pendingDelete = true;
            }
            let tween = this.game.add.tween(this.superText);
            tween.to({
                alpha: 1
            }, 400, Phaser.Easing.Cubic.Out, true, delay);
            tween.onStart.add(function() {
                this.showComboEffect(600);
                this.createExplosionArray(this.superText.x, this.superText.y - 30, 10);
            }, this);
            tween.onComplete.add(function() {
                this.game.add.tween(this.superText)
                    .to({
                        alpha: 0
                    }, 400, Phaser.Easing.Cubic.Out, true, 800)
                    .onComplete.add(function() {
                        this.superText.scale.set(0);
                    }, this);
            }, this);
        }
        createExplosionArray(x, y, explosionCount) {
            const xDelta = 20;
            let startX = -(xDelta * (explosionCount * .5));
            for (let i = 0; i < explosionCount; i++) {
                const sparkleSprite = new Phaser.Sprite(this.game, startX + (i * xDelta), y, "texture_atlas_1");
                sparkleSprite.anchor.set(0.5);
                sparkleSprite.angle = (360 / explosionCount) * i;
                const sparkleFrames = MiniBillar.Utils.createAnimFramesArr("sparkle_effect", 14, false, 0, 15);
                sparkleSprite.animations.add("sparkle", sparkleFrames).play(24, false, true);
                this.add(sparkleSprite);
                sparkleSprite.sendToBack();
            }
        }
        updateBallSet(ballId) {
            for (let entry of this.ballsSet) {
                if (entry.frameName === "ball_icon_" + ballId + ".png") {
                    entry.frameName = "ball_icon_0.png";
                }
            }
        }
        updateSoloScore() {
            if (this.sumPoints) {
                let num = parseInt(this.points.text.replace(/,/g, ""));
                if (MiniBillar.GameVars.playerPoints > 999999) {
                    this.points.setStyle({
                        font: "28px Oswald-DemiBold"
                    }, true);
                    if (MiniBillar.GameVars.playerPoints > 9999999) {
                        this.points.setStyle({
                            font: "24px Oswald-DemiBold"
                        }, true);
                    }
                }
                if (num < MiniBillar.GameVars.playerPoints) {
                    num++;
                    this.points.text = MiniBillar.Utils.validNumber(num) + " pts";
                    this.points.fill = "#1CCE68";
                    if (num > MiniBillar.GameVars.gameData.statistics.solo.highScore) {
                        MiniBillar.GameVars.gameData.statistics.solo.highScore = num;
                        this.highscoreLayer.text = MiniBillar.Utils.validNumber(MiniBillar.GameVars.gameData.statistics.solo.highScore);
                    }
                } else if (num > MiniBillar.GameVars.playerPoints) {
                    if (this.counter === 3) {
                        num--;
                        this.points.text = MiniBillar.Utils.validNumber(num) + " pts";
                        this.points.fill = "#FA2E63";
                        if (num > MiniBillar.GameVars.gameData.statistics.solo.highScore) {
                            MiniBillar.GameVars.gameData.statistics.solo.highScore = num;
                            this.highscoreLayer.text = MiniBillar.Utils.validNumber(MiniBillar.GameVars.gameData.statistics.solo.highScore);
                        }
                        this.counter = 0;
                    } else {
                        this.counter++;
                    }
                } else {
                    this.counter = 0;
                    this.sumPoints = false;
                    this.points.fill = "#E5FFFF";
                }
            }
            if (this.sumTime) {
                let num = parseInt(this.timer.text);
                if (num < MiniBillar.GameVars.timerSolo) {
                    if (this.counterTime === 3) {
                        num++;
                        this.timer.text = num + "";
                        this.updateTimerSLabel();
                        this.counterTime = 0;
                    } else {
                        this.counterTime++;
                    }
                } else {
                    this.sumTime = false;
                }
            }
        }
        updateTimerSLabel() {
            if (MiniBillar.GameVars.timerSolo > 999) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 4;
            } else if (MiniBillar.GameVars.timerSolo > 99) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 3;
            } else if (MiniBillar.GameVars.timerSolo > 9) {
                this.timerS.x = this.timer.x + this.timerSXOffset * 2;
            } else {
                this.timerS.x = this.timer.x + this.timerSXOffset;
            }
        }
        createSoloModeHud() {
            this.createPocketedBallsSetsSolo();
            this.populateBallSetSolo();
            const nameLine = new Phaser.Image(this.game, -276, 54, "texture_atlas_1", "name_line.png");
            nameLine.anchor.set(0, .5);
            this.matchDataContainer.add(nameLine);
            const playerName = new Phaser.Text(this.game, -261, 58, MiniBillar.GameVars.gameData.playerData.nick, {
                font: "18px Oswald-Medium",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            playerName.anchor.set(0, 1);
            this.matchDataContainer.add(playerName);
            const avatarBubble = new MiniBillar.AvatarBubble(this.game, MiniBillar.GameVars.gameData.playerData.avatar, -310, 65, false);
            this.matchDataContainer.add(avatarBubble);
            this.timer = new Phaser.Text(this.game, 0, 76, MiniBillar.GameVars.timerSolo.toString(), {
                font: "44px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            this.timer.anchor.set(0.5, 1);
            this.matchDataContainer.add(this.timer);
            this.timerS = new Phaser.Text(this.game, 0, this.timer.y - 5, "s", {
                font: "24px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            this.timerS.anchor.set(0, 1);
            this.matchDataContainer.add(this.timerS);
            this.updateTimerSLabel();
            this.points = new Phaser.Text(this.game, 340, 82, MiniBillar.Utils.validNumber(MiniBillar.GameVars.playerPoints) + " pts", {
                font: "28px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            this.points.anchor.set(1, .5);
            this.matchDataContainer.add(this.points);
            const highScoreLabel = new Phaser.Text(this.game, 275, 54, "HIGHSCORE:", {
                font: "21px Oswald-Medium",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            highScoreLabel.anchor.set(1);
            this.matchDataContainer.add(highScoreLabel);
            this.highscoreLayer = new Phaser.Text(this.game, 340, 54, MiniBillar.Utils.validNumber(MiniBillar.GameVars.gameData.statistics.solo.highScore), {
                font: "21px Oswald-Medium",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            this.highscoreLayer.anchor.set(1);
            this.matchDataContainer.add(this.highscoreLayer);
        }
        createPlayersInfoBar(playerData, adversaryData) {
            this.playerNameLabel = new Phaser.Text(this.game, -125, 39, playerData.nick, {
                font: "18px Oswald-Medium",
                fontWeight: "400",
                fill: "#E5FFFF"
            });
            this.playerNameLabel.anchor.set(1, 0.5);
            this.matchDataContainer.add(this.playerNameLabel);
            const playerNameLine = new Phaser.Image(this.game, -110, 52, "texture_atlas_1", "name_line.png");
            playerNameLine.anchor.set(0, .5);
            playerNameLine.scale.x *= -1;
            this.matchDataContainer.add(playerNameLine);
            this.playerAvatarBubble = new MiniBillar.AvatarBubble(this.game, playerData.avatar, -80, 63, true);
            this.matchDataContainer.add(this.playerAvatarBubble);
            const currentCuePlayer = new Phaser.Image(this.game, -440, 63, "texture_atlas_5", MiniBillar.GameVars.gameData.playerData.equipedCue + "_sprite_0.png");
            currentCuePlayer.scale.set(.8, .8);
            currentCuePlayer.anchor.set(1, .5);
            currentCuePlayer.angle = 180;
            this.matchDataContainer.add(currentCuePlayer);
            const cueMaskPlayer = new Phaser.Graphics(this.game);
            cueMaskPlayer.beginFill(0xffffff);
            cueMaskPlayer.drawRect(-355, 0, -100, 200);
            this.add(cueMaskPlayer);
            currentCuePlayer.mask = cueMaskPlayer;
            const adversaryName = adversaryData.nick;
            this.adversaryNameLabel = new Phaser.Text(this.game, 125, 39, adversaryName, {
                font: "18px Oswald-Medium",
                fontWeight: "400",
                fill: "#E5FFFF",
                align: "center"
            });
            this.adversaryNameLabel.anchor.set(0, 0.5);
            this.matchDataContainer.add(this.adversaryNameLabel);
            const adversaryNameLine = new Phaser.Image(this.game, 110, 52, "texture_atlas_1", "name_line.png");
            adversaryNameLine.anchor.set(0, .5);
            this.matchDataContainer.add(adversaryNameLine);
            this.adversaryAvatarBubble = new MiniBillar.AvatarBubble(this.game, adversaryData.avatar, 80, 63, true);
            this.matchDataContainer.add(this.adversaryAvatarBubble);
            const currentCueAdversary = new Phaser.Image(this.game, 440, 63, "texture_atlas_5", adversaryData.equipedCue + "_sprite_0.png");
            currentCueAdversary.scale.set(.8, .8);
            currentCueAdversary.anchor.set(1, .5);
            this.matchDataContainer.add(currentCueAdversary);
            const cueMaskAdversary = new Phaser.Graphics(this.game);
            cueMaskAdversary.beginFill(0xffffff);
            cueMaskAdversary.drawRect(355, 0, 100, 200);
            this.add(cueMaskAdversary);
            currentCueAdversary.mask = cueMaskAdversary;
        }
        createEmoticonBalloons() {
            this.adversaryEmoticonBalloon = new MiniBillar.EmoticonBalloon(this.game, false);
            this.adversaryEmoticonBalloon.x = 26;
            this.adversaryEmoticonBalloon.y = 112;
            this.matchDataContainer.add(this.adversaryEmoticonBalloon);
            this.playerEmoticonBalloon = new MiniBillar.EmoticonBalloon(this.game, true);
            this.playerEmoticonBalloon.x = -26;
            this.playerEmoticonBalloon.y = 112;
            this.matchDataContainer.add(this.playerEmoticonBalloon);
        }
        createPocketedBallsSetsSolo() {
            this.ballsSet = [];
            let x = -250;
            for (let i = 0; i < 15; i++) {
                let ballSocket = new Phaser.Image(this.game, x, 80, "texture_atlas_1", "ball_icon_0.png");
                ballSocket.anchor.set(0.5);
                this.matchDataContainer.add(ballSocket);
                this.ballsSet.push(ballSocket);
                x += 30;
            }
        }
        createPocketedBallsSetsNonSOLO() {
            this.ballsSet = [];
            const distanceFromCenterX = 327;
            let x = -distanceFromCenterX;
            const distBetweenBalls = 32;
            for (let i = 0; i < 15; i++) {
                if (i === 7) {
                    x *= -1;
                } else {
                    let ballSocket = new Phaser.Image(this.game, x, 74, "texture_atlas_1", "ball_icon_0.png");
                    ballSocket.anchor.set(0.5);
                    this.matchDataContainer.add(ballSocket);
                    this.ballsSet.push(ballSocket);
                }
                x += distBetweenBalls;
            }
        }
        animatePlayerDataOnStart() {
            this.playerNameLabel.scale.set(0);
            this.playerNameLabel.alpha = 0;
            this.game.add.tween(this.playerNameLabel.scale)
                .to({
                    y: 1,
                    x: 1
                }, 300, Phaser.Easing.Cubic.Out, true, 500);
            this.game.add.tween(this.playerNameLabel)
                .to({
                    alpha: 1
                }, 300, Phaser.Easing.Cubic.Out, true, 500);
            this.vs.scale.y = 0;
            this.game.add.tween(this.vs.scale)
                .to({
                    y: 1
                }, 300, Phaser.Easing.Elastic.Out, true, 1300);
            this.adversaryNameLabel.scale.set(0);
            this.adversaryNameLabel.alpha = 0;
            this.game.add.tween(this.adversaryNameLabel.scale)
                .to({
                    y: 1,
                    x: 1
                }, 300, Phaser.Easing.Cubic.Out, true, 2100);
            this.game.add.tween(this.adversaryNameLabel)
                .to({
                    alpha: 1
                }, 300, Phaser.Easing.Cubic.Out, true, 2100);
        }
        populateBallSetNonSOLO(sidesInverted) {
            this.sidesAssigned = true;
            let imageId = sidesInverted ? 9 : 1;
            for (let i = 0; i < 14; i++) {
                this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
                if (i === 6) {
                    if (sidesInverted) {
                        imageId = 0;
                    } else {
                        imageId++;
                    }
                }
                imageId++;
            }
        }
        populateBallSetSolo() {
            let imageId = 1;
            for (let i = 0; i < 15; i++) {
                this.ballsSet[i].frameName = "ball_icon_" + imageId + ".png";
                imageId++;
            }
        }
    }
    MiniBillar.HUD = HUD;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class AdversaryLeftLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "adversary-left-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .75;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const text = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth * .5, 350, "ADVERSARY CONNECTION LOST", {
                font: "60px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#EB3359"
            });
            text.stroke = "#673952";
            text.strokeThickness = 5;
            text.anchor.set(.5);
            this.add(text);
            this.showButtonsTimer = 1;
        }
        update() {
            if (!this.buttonsCreated) {
                if (this.showButtonsTimer < 0) {
                    this.buttonsCreated = true;
                    const buttonHome = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 - 120 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickHome, this);
                    buttonHome.setFrames("btn_close_pressed.png", "btn_close.png", "btn_close_pressed.png", "btn_close.png");
                    buttonHome.anchor.set(.5);
                    if (this.game.device.touch) {
                        buttonHome.onInputDown.add(function() {
                            buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
                        }, this);
                    }
                    buttonHome.onInputOver.add(function() {
                        buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
                    }, this);
                    buttonHome.onInputOut.add(function() {
                        buttonHome.scale.set(1, 1);
                    }, this);
                    buttonHome.forceOut = true;
                    buttonHome.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                    this.add(buttonHome);
                    const buttonNewRival = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickNewRival, this);
                    buttonNewRival.setFrames("btn_new_rival_pressed.png", "btn_new_rival.png", "btn_new_rival_pressed.png", "btn_new_rival.png");
                    buttonNewRival.anchor.set(.5);
                    if (this.game.device.touch) {
                        buttonNewRival.onInputDown.add(function() {
                            buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1);
                        }, this);
                    }
                    buttonNewRival.onInputOver.add(function() {
                        buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1);
                    }, this);
                    buttonNewRival.onInputOut.add(function() {
                        buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                    }, this);
                    buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                    this.add(buttonNewRival);
                } else {
                    this.showButtonsTimer -= this.game.time.physicsElapsed;
                }
            }
        }
        onClickHome(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideAdversaryLeftLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickNewRival(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideAdversaryLeftLayer();
            MiniBillar.GameVars.goDirectlyToLobby = true;
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.AdversaryLeftLayer = AdversaryLeftLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class ChatLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "chat-layer");
            ChatLayer.currentInstance = this;
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .25;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const menuContainer = new Phaser.Group(this.game);
            menuContainer.x = MiniBillar.GameVars.gameWidth / 2;
            menuContainer.y = 85;
            menuContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(menuContainer);
            const rectangleWithRadius = new Phaser.Graphics(this.game);
            menuContainer.add(rectangleWithRadius);
            const rectWidth = 710;
            const rectHeight = 160;
            const radius = 20;
            const px = -rectWidth / 2;
            const py = -rectHeight / 2;
            rectangleWithRadius.beginFill(0x1D2836, .8);
            rectangleWithRadius.drawRoundedRect(px, py, rectWidth, rectHeight, radius);
            rectangleWithRadius.endFill();
            const rows = 3;
            const cols = 14;
            for (let i = 0; i < cols; i++) {
                for (let j = 0; j < rows; j++) {
                    let index = cols * j + i + 1;
                    if (index <= MiniBillar.GameVars.emoticonsAmount) {
                        let delta = 50;
                        let x = (i - cols / 2 + .5) * delta;
                        let y = (j - 1) * delta;
                        let emoticonButton = new Phaser.Button(this.game, x, y, "texture_atlas_5", this.onClickEmoticon, this);
                        emoticonButton.setFrames("emoticon_" + index + "_on.png", "emoticon_" + index + ".png", "emoticon_" + index + "_on.png");
                        emoticonButton.name = index.toString();
                        emoticonButton.anchor.set(.5);
                        if (this.game.device.touch) {
                            emoticonButton.onInputDown.add(function() {
                                MiniBillar.GameVars.GUIButtonDown = true;
                                emoticonButton.scale.set(emoticonButton.scale.x * 1.1, emoticonButton.scale.y * 1.1);
                            }, this, 5);
                        }
                        emoticonButton.onInputOver.add(function() {
                            emoticonButton.scale.set(emoticonButton.scale.x * 1.1, emoticonButton.scale.y * 1.1);
                        }, this);
                        emoticonButton.onInputOut.add(function() {
                            emoticonButton.scale.set(1);
                        }, this);
                        menuContainer.add(emoticonButton);
                    }
                }
            }
        }
        onClickEmoticon(b) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            b.clearFrames();
            b.scale.set(1);
            MiniBillar.MatchManager.emoticonSelected(parseInt(b.name));
        }
        onDownTransparentLayer() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.PoolState.currentInstance.hideChatLayer();
        }
    }
    MiniBillar.ChatLayer = ChatLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class EndGamePortraitContainer extends Phaser.Group {
        constructor(game, messageImageFilename, isWinner) {
            super(game, null, "end-game-portrait-container");
            const portraitPackY = 280;
            if (isWinner) {
                this.rotateRays = true;
                const rayContainer = this.game.add.group();
                rayContainer.position.set(MiniBillar.GameVars.gameWidth / 2, portraitPackY);
                rayContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(rayContainer);
                this.sendToBack(rayContainer);
                this.portraitRaysImage = new Phaser.Image(game, 0, 0, "texture_atlas_1", "rays_win.png");
                this.portraitRaysImage.anchor.set(0.5);
                rayContainer.add(this.portraitRaysImage);
                this.game.add.tween(this.portraitRaysImage.scale)
                    .from({
                        x: .1,
                        y: .1
                    }, 950, Phaser.Easing.Cubic.Out, true);
            } else {
                this.rotateRays = false;
                this.portraitRaysImage = null;
            }
            this.avatarBubble = new MiniBillar.AvatarBubble(this.game, MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameWidth / 2, portraitPackY, false);
            this.avatarBubble.scale.set(MiniBillar.GameVars.scaleXMult * 1.78, MiniBillar.GameVars.scaleYMult * 1.78);
            this.add(this.avatarBubble);
            this.messageImage = new Phaser.Image(game, MiniBillar.GameVars.gameWidth / 2, portraitPackY + 64, "texture_atlas_1", messageImageFilename);
            this.messageImage.anchor.set(0.5);
            this.messageImage.scale.set(MiniBillar.GameVars.scaleXMult, .001);
            this.add(this.messageImage);
            this.game.add.tween(this.avatarBubble.scale).from({
                    x: .1,
                    y: .1
                }, 800, Phaser.Easing.Elastic.Out, true)
                .onComplete.add(function() {
                    this.game.add.tween(this.messageImage.scale)
                        .to({
                            y: MiniBillar.GameVars.scaleYMult
                        }, 800, Phaser.Easing.Elastic.Out, true);
                }, this);
        }
        update() {
            super.update();
            if (this.rotateRays) {
                this.portraitRaysImage.angle += .2;
            }
        }
    }
    MiniBillar.EndGamePortraitContainer = EndGamePortraitContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class LosePVPLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "lose-pvp-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(game, "you_lose.png", false);
            this.add(endGamePortraitContainer);
            const buttonHome = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 - 120 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickHome, this);
            buttonHome.setFrames("btn_close_pressed.png", "btn_close.png", "btn_close_pressed.png", "btn_close.png");
            buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                buttonHome.onInputDown.add(function() {
                    buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
                }, this);
            }
            buttonHome.onInputOver.add(function() {
                buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
            }, this);
            buttonHome.onInputOut.add(function() {
                buttonHome.scale.set(1, 1);
            }, this);
            buttonHome.forceOut = true;
            buttonHome.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonHome);
            const buttonNewRival = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickNewRival, this);
            buttonNewRival.setFrames("btn_new_rival_pressed.png", "btn_new_rival.png", "btn_new_rival_pressed.png", "btn_new_rival.png");
            buttonNewRival.anchor.set(.5);
            if (this.game.device.touch) {
                buttonNewRival.onInputDown.add(function() {
                    buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1);
                }, this);
            }
            buttonNewRival.onInputOver.add(function() {
                buttonNewRival.scale.set(buttonNewRival.scale.x * 1.1, buttonNewRival.scale.y * 1.1);
            }, this);
            buttonNewRival.onInputOut.add(function() {
                buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonNewRival);
            MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.LOSE);
        }
        onClickHome(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideLoseLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickNewRival(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideLoseLayer();
            MiniBillar.GameVars.goDirectlyToLobby = true;
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.LosePVPLayer = LosePVPLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PauseLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "pause-layer");
            PauseLayer.currentInstance = this;
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const buttonBack = new Phaser.Button(this.game, 38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickExit, this);
            buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png", "btn_back_off.png");
            buttonBack.forceOut = true;
            buttonBack.anchor.set(.5);
            if (this.game.device.touch) {
                buttonBack.onInputDown.add(function() {
                    buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
                }, this);
            }
            buttonBack.onInputOver.add(function() {
                buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
            }, this);
            buttonBack.onInputOut.add(function() {
                buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonBack);
            let scaledItemsContainer = new Phaser.Group(this.game);
            scaledItemsContainer.x = MiniBillar.GameVars.gameWidth / 2;
            scaledItemsContainer.y = MiniBillar.GameVars.gameHeight / 2;
            scaledItemsContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(scaledItemsContainer);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                const restartButton = new Phaser.Button(this.game, 0, -8, "texture_atlas_1", this.onClickReset, this);
                restartButton.setFrames("btn_restart_pressed.png", "btn_restart.png", "btn_restart_pressed.png", "btn_restart.png");
                restartButton.anchor.set(.5);
                restartButton.scale.set(1);
                if (this.game.device.touch) {
                    restartButton.onInputDown.add(function() {
                        restartButton.scale.set(restartButton.scale.x * 1.1, restartButton.scale.y * 1.1);
                    }, this);
                }
                restartButton.onInputOver.add(function() {
                    restartButton.scale.set(restartButton.scale.x * 1.1, restartButton.scale.y * 1.1);
                }, this);
                restartButton.onInputOut.add(function() {
                    restartButton.scale.set(1);
                }, this);
                scaledItemsContainer.add(restartButton);
                const soloHomeButton = new Phaser.Button(this.game, 0, 100, "texture_atlas_1", this.onClickSoloHome, this);
                soloHomeButton.setFrames("btn_close_pressed.png", "btn_close.png", "btn_close_pressed.png", "btn_close.png");
                soloHomeButton.anchor.set(.5);
                if (this.game.device.touch) {
                    soloHomeButton.onInputDown.add(function() {
                        soloHomeButton.scale.set(soloHomeButton.scale.x * 1.1, soloHomeButton.scale.y * 1.1);
                    }, this);
                }
                soloHomeButton.onInputOver.add(function() {
                    soloHomeButton.scale.set(soloHomeButton.scale.x * 1.1, soloHomeButton.scale.y * 1.1);
                }, this);
                soloHomeButton.onInputOut.add(function() {
                    soloHomeButton.scale.set(1);
                }, this);
                scaledItemsContainer.add(soloHomeButton);
                const rulesText = new Phaser.Text(this.game, 0, 160, MiniBillar.GameConstants.RULES_TEXT, {
                    font: this.game.device.desktop ? "24px Oswald-DemiBold" : "34px Oswald-DemiBold",
                    fontWeight: "600",
                    fill: "#e7f6f8",
                    align: "center",
                    stroke: "#2f3237",
                    strokeThickness: 3
                });
                rulesText.anchor.set(0.5, 0);
                MiniBillar.Utils.colourRulesText(rulesText);
                scaledItemsContainer.add(rulesText);
            } else {
                const resignButton = new Phaser.Button(this.game, 0, -8, "texture_atlas_1", this.onClickResign, this);
                resignButton.setFrames("btn_resign_pressed.png", "btn_resign.png", "btn_resign_pressed.png", "btn_resign.png");
                resignButton.anchor.set(.5);
                resignButton.scale.set(1);
                if (this.game.device.touch) {
                    resignButton.onInputDown.add(function() {
                        resignButton.scale.set(resignButton.scale.x * 1.1, resignButton.scale.y * 1.1);
                    }, this);
                }
                resignButton.onInputOver.add(function() {
                    resignButton.scale.set(resignButton.scale.x * 1.1, resignButton.scale.y * 1.1);
                }, this);
                resignButton.onInputOut.add(function() {
                    resignButton.scale.set(1);
                }, this);
                scaledItemsContainer.add(resignButton);
            }
            const audioSwitchButton = new MiniBillar.SwitchButton(this.game, !MiniBillar.GameVars.gameData.musicMuted, MiniBillar.SwitchButton.MUSIC);
            audioSwitchButton.x = 30;
            audioSwitchButton.y = -100;
            scaledItemsContainer.add(audioSwitchButton);
            const audioLabel = new Phaser.Text(this.game, -24, audioSwitchButton.y + 2, "AUDIO", {
                font: "24px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8",
                align: "center",
                stroke: "#2f3237",
                strokeThickness: 3
            });
            audioLabel.anchor.set(1, .5);
            scaledItemsContainer.add(audioLabel);
            if (this.game.device.touch) {
                const switchStartingState = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.RIGHT;
                const powerSwitchButton = new MiniBillar.SwitchButton(this.game, switchStartingState, MiniBillar.SwitchButton.POWER);
                powerSwitchButton.x = 30;
                powerSwitchButton.y = -160;
                scaledItemsContainer.add(powerSwitchButton);
                const powerTextLeft = "POWER BAR: LEFT";
                const powerTextRight = "POWER BAR: RIGHT";
                this.powerLabel = new Phaser.Text(this.game, -24, powerSwitchButton.y + 2, powerTextLeft, {
                    font: "24px Oswald-DemiBold",
                    fontWeight: "600",
                    fill: "#e7f6f8",
                    align: "center",
                    stroke: "#2f3237",
                    strokeThickness: 3
                });
                this.powerLabel.anchor.set(1, .5);
                scaledItemsContainer.add(this.powerLabel);
                if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.RIGHT) {
                    this.powerLabel.text = powerTextRight;
                }
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    scaledItemsContainer.y += 100;
                }
            }
            this.alpha = 0;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, 400, Phaser.Easing.Cubic.Out, true);
        }
        changePower() {
            const powerTextLeft = "POWER BAR: LEFT";
            const powerTextRight = "POWER BAR: RIGHT";
            if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT) {
                this.powerLabel.text = powerTextLeft;
            } else {
                this.powerLabel.text = powerTextRight;
            }
        }
        destroy() {
            PauseLayer.currentInstance = null;
            super.destroy();
        }
        onClickExit(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hidePauseLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickResign(b) {
            b.clearFrames();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.MatchManager.hideNotificationLayer();
            MiniBillar.MatchManager.hidePauseLayer();
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                    console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
                }
                MiniBillar.MatchManagerPVP.matchOverDueToResignation(MiniBillar.GameVars.gameData.playerData.sessionId);
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                    console.error("sending GameConstants.MESSAGE_TYPE_RESIGN");
                }
                MiniBillar.MatchManagerPVBot.matchOverDueToResignation(true);
            }
        }
        onClickReset(b) {
            b.clearFrames();
            MiniBillar.GameVars.paused = false;
            MiniBillar.GameVars.rematch = true;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameManager.enterSoloGame();
            }
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickSoloHome(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hidePauseLayer();
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.MatchManagerSolo.endSoloGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
            }
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.PauseLayer = PauseLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class RetrySoloLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "retry-solo-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(game, "game_over.png", false);
            this.add(endGamePortraitContainer);
            const buttonRestart = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickReset, this);
            buttonRestart.setFrames("btn_restart_pressed.png", "btn_restart.png", "btn_restart_pressed.png");
            buttonRestart.anchor.set(.5);
            if (this.game.device.touch) {
                buttonRestart.onInputDown.add(function() {
                    buttonRestart.scale.set(buttonRestart.scale.x * 1.1, buttonRestart.scale.y * 1.1);
                }, this);
            }
            buttonRestart.onInputOver.add(function() {
                buttonRestart.scale.set(buttonRestart.scale.x * 1.1, buttonRestart.scale.y * 1.1);
            }, this);
            buttonRestart.onInputOut.add(function() {
                buttonRestart.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonRestart.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonRestart);
            const buttonHome = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 - 120 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickHome, this);
            buttonHome.setFrames("btn_close_pressed.png", "btn_close.png", "btn_close_pressed.png");
            buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                buttonHome.onInputDown.add(function() {
                    buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
                }, this);
            }
            buttonHome.onInputOver.add(function() {
                buttonHome.scale.set(buttonHome.scale.x * 1.1, buttonHome.scale.y * 1.1);
            }, this);
            buttonHome.onInputOut.add(function() {
                buttonHome.scale.set(1, 1);
            }, this);
            buttonHome.forceOut = true;
            buttonHome.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonHome);
            MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.LOSE);
        }
        onClickHome(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hidePauseLayer();
            MiniBillar.MatchManager.hideRetryLayer();
            MiniBillar.MatchManagerSolo.endSoloGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickReset(b) {
            b.clearFrames();
            MiniBillar.GameVars.paused = false;
            MiniBillar.GameVars.rematch = true;
            MiniBillar.GameManager.enterSoloGame();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.RetrySoloLayer = RetrySoloLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class VictoryLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "victory-layer");
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .6;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            this.endGamePortraitContainer = new MiniBillar.EndGamePortraitContainer(game, "you_win.png", true);
            this.add(this.endGamePortraitContainer);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                this.buttonRestart = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickReset, this);
                this.buttonRestart.setFrames("btn_restart_pressed.png", "btn_restart.png", "btn_restart_pressed.png");
                this.buttonRestart.anchor.set(.5);
                if (this.game.device.touch) {
                    this.buttonRestart.onInputDown.add(function() {
                        this.buttonRestart.scale.set(this.buttonRestart.scale.x * 1.1, this.buttonRestart.scale.y * 1.1);
                    }, this);
                }
                this.buttonRestart.onInputOver.add(function() {
                    this.buttonRestart.scale.set(this.buttonRestart.scale.x * 1.1, this.buttonRestart.scale.y * 1.1);
                }, this);
                this.buttonRestart.onInputOut.add(function() {
                    this.buttonRestart.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                }, this);
                this.buttonRestart.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(this.buttonRestart);
            } else {
                this.buttonNewRival = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 + 50 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickNewRival, this);
                this.buttonNewRival.setFrames("btn_new_rival_pressed.png", "btn_new_rival.png", "btn_new_rival_pressed.png");
                this.buttonNewRival.anchor.set(.5);
                if (this.game.device.touch) {
                    this.buttonNewRival.onInputDown.add(function() {
                        this.buttonNewRival.scale.set(this.buttonNewRival.scale.x * 1.1, this.buttonNewRival.scale.y * 1.1);
                    }, this);
                }
                this.buttonNewRival.onInputOver.add(function() {
                    this.buttonNewRival.scale.set(this.buttonNewRival.scale.x * 1.1, this.buttonNewRival.scale.y * 1.1);
                }, this);
                this.buttonNewRival.onInputOut.add(function() {
                    this.buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                }, this);
                this.buttonNewRival.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(this.buttonNewRival);
            }
            this.buttonHome = new Phaser.Button(this.game, MiniBillar.GameVars.gameWidth / 2 - 120 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / 2 + 275, "texture_atlas_1", this.onClickHome, this);
            this.buttonHome.setFrames("btn_close_pressed.png", "btn_close.png", "btn_close_pressed.png");
            this.buttonHome.anchor.set(.5);
            if (this.game.device.touch) {
                this.buttonHome.onInputDown.add(function() {
                    this.buttonHome.scale.set(this.buttonHome.scale.x * 1.1, this.buttonHome.scale.y * 1.1);
                }, this);
            }
            this.buttonHome.onInputOver.add(function() {
                this.buttonHome.scale.set(this.buttonHome.scale.x * 1.1, this.buttonHome.scale.y * 1.1);
            }, this);
            this.buttonHome.onInputOut.add(function() {
                this.buttonHome.scale.set(1, 1);
            }, this);
            this.buttonHome.forceOut = true;
            this.buttonHome.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(this.buttonHome);
            MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.WIN);
            if (!MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked) {
                this.animStarBox = new MiniBillar.AnimatedStarBox(game);
                this.animStarBox.y = 475;
                this.animStarBox.x = MiniBillar.GameVars.gameWidth * 0.5;
                this.animStarBox.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(this.animStarBox);
                this.rewardCardContainer = new MiniBillar.RewardCardContainer(game);
                this.rewardCardContainer.y = MiniBillar.GameVars.gameHeight * 0.5;
                this.rewardCardContainer.x = MiniBillar.GameVars.gameWidth * 0.5;
                this.rewardCardContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(this.rewardCardContainer);
            }
        }
        init(victoryData) {
            if (!victoryData) {
                throw "Error reading victory data";
            }
            if (victoryData.starUnlocked === 3) {
                this.endGamePortraitContainer.visible = false;
                this.buttonHome.alpha = 0;
                if (this.buttonRestart) {
                    this.buttonRestart.visible = false;
                }
                if (this.buttonNewRival) {
                    this.buttonNewRival.visible = false;
                }
                if (this.animStarBox) {
                    this.animStarBox.y = this.buttonHome.y;
                    this.animStarBox.animateGiftBox();
                    this.animStarBox.giftBox.boxOpeningTween.onComplete.add(function() {
                        this.rewardCardContainer.createAndDisplayCards(victoryData.recentlyUnlockedCardIds);
                        this.rewardCardContainer.animateCardPointsIncrementation(victoryData.numberOfCardsUnlocked);
                        this.buttonHome.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
                        this.buttonHome.scale.x *= -1;
                        this.buttonHome.anchor.set(.5);
                        this.buttonHome.x = MiniBillar.GameVars.gameWidth - 10 + (this.buttonHome.width * .5);
                        this.buttonHome.y = MiniBillar.GameVars.gameHeight - 10 - (this.buttonHome.height * .5);
                        this.game.add.tween(this.buttonHome).to({
                                alpha: 1
                            }, 250, Phaser.Easing.Cubic.Out, true, 1000)
                            .onComplete.add(function() {
                                const pulseTween = this.game.add.tween(this.buttonHome.scale);
                                pulseTween.to({
                                    x: -1.0915 * MiniBillar.GameVars.scaleXMult,
                                    y: MiniBillar.GameVars.scaleYMult
                                }, 300, Phaser.Easing.Linear.None, false);
                                pulseTween.to({
                                    x: -MiniBillar.GameVars.scaleXMult,
                                    y: 1.0915 * MiniBillar.GameVars.scaleYMult
                                }, 700, Phaser.Easing.Elastic.Out);
                                pulseTween.loop();
                                pulseTween.start();
                            }, this);
                    }, this);
                }
            }
            if (this.animStarBox) {
                for (let i = 0; i < 3; i++) {
                    if (i === victoryData.starUnlocked - 1) {
                        this.animStarBox.animateStarToFullScale(i);
                        break;
                    } else {
                        this.animStarBox.setStarActive(i);
                    }
                }
            }
        }
        onClickReset(b) {
            b.clearFrames();
            MiniBillar.GameVars.paused = false;
            MiniBillar.GameVars.rematch = true;
            MiniBillar.GameManager.enterSoloGame();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickHome(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideVictoryLayer();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onClickNewRival(b) {
            b.clearFrames();
            MiniBillar.MatchManager.hideVictoryLayer();
            MiniBillar.GameVars.goDirectlyToLobby = true;
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.VictoryLayer = VictoryLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class MatchManager {
        static init(game, sessionId) {
            MatchManager.game = game;
            MiniBillar.GameVars.gameOver = false;
            MiniBillar.GameVars.english = 0;
            MiniBillar.GameVars.verticalSpin = 0;
            MiniBillar.GameVars.turnSet = true;
            MiniBillar.GameVars.draggingCueBall = false;
            MiniBillar.GameVars.pocketIdWhereBlackFell = -1;
        }
        static update() {
            if (!MiniBillar.GameVars.startMatch || !MiniBillar.GameVars.ballArray) {
                return;
            }
            MiniBillar.GameVars.shotRunning = false;
            for (let i = 0, ln = MiniBillar.GameVars.ballArray.length; i < ln; i++) {
                let ball = MiniBillar.GameVars.ballArray[i];
                if (ball.active && ball.velocity.magnitudeSquared > 0) {
                    MiniBillar.GameVars.shotRunning = true;
                    break;
                }
            }
            const cueBall = MiniBillar.GameVars.ballArray[0];
            if (cueBall.mc.pocketTween) {
                MiniBillar.GameVars.shotRunning = true;
            }
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.MatchManagerSolo.update();
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                MiniBillar.MatchManagerPVP.update();
            } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                MiniBillar.MatchManagerPVBot.update();
            }
        }
        static showPauseLayer() {
            MiniBillar.PoolState.currentInstance.pauseGame();
        }
        static hideNotificationLayer() {
            MiniBillar.PoolState.currentInstance.hideNotificationLayer();
        }
        static hidePauseLayer() {
            MiniBillar.PoolState.currentInstance.resumeGame();
        }
        static showSoloRetryLayer() {
            MiniBillar.PoolState.currentInstance.showSoloRetryLayer();
        }
        static hideRetryLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.hideRetryLayer();
            }
        }
        static showVictoryLayer(victoryData) {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.showVictoryLayer(victoryData);
            }
        }
        static hideVictoryLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.hideVictoryLayer();
            }
        }
        static showLoseLayer(victoryData) {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.showLoseLayer();
            }
        }
        static hideLoseLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.hideLoseLayer();
            }
        }
        static showAdversaryLeftLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.showAdversaryLeftLayer();
            }
        }
        static hideAdversaryLeftLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.hideAdversaryLeftLayer();
            }
        }
        static ballHasBeenShot(shotData) {
            MiniBillar.GameVars.shotRunning = true;
            MiniBillar.GameVars.turnSet = false;
            MiniBillar.GameVars.shotCount++;
            MiniBillar.PoolState.currentInstance.gui.disableSpinButton();
            MiniBillar.StageContainer.currentInstance.ballHasBeenShot();
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.PoolState.currentInstance.hideNonSOLOTimers();
                if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                    if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                        MiniBillar.MatchManagerPVP.ballHasBeenShot(shotData);
                    } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                        MiniBillar.MatchManagerPVBot.ballHasBeenShot(shotData);
                    }
                }
            }
        }
        static reset() {
            MiniBillar.GameVars.paused = false;
            MiniBillar.GameVars.rematch = true;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameManager.enterSoloGame();
            }
        }
        static showSpinCircleLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.showSpinCircleLayer();
            }
        }
        static hideSpinCircleLayer(english, verticalSpin) {
            MiniBillar.GameVars.english = english;
            MiniBillar.GameVars.verticalSpin = verticalSpin;
            MiniBillar.PoolState.currentInstance.hideSpinCircleLayer();
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                Communication.CommunicationManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL_SPIN_SET,
                    data: {
                        english: MiniBillar.GameVars.english,
                        verticalSpin: MiniBillar.GameVars.verticalSpin
                    }
                });
            }
        }
        static resetSpinCircleLayer() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.resetSpinCircleLayer();
            }
        }
        static ballPocketed(ball) {
            const id = ball.id;
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.PoolState.currentInstance.hud.ballPocketed(id);
            }
            if (id !== 0) {
                MiniBillar.StageContainer.currentInstance.addBallToTrail(ball);
                MiniBillar.GameVars.pocketedBalls.push(id);
            }
        }
        static setRedPointPosition() {
            if (MiniBillar.PoolState.currentInstance) {
                MiniBillar.PoolState.currentInstance.gui.setRedPointPosition();
            }
        }
        static setCueAimDirection() {
            MiniBillar.CueContainer.currentInstance.aimDirectionVector = new Billiard.Vector2D(-Math.cos(MiniBillar.CueContainer.currentInstance.rotation), -Math.sin(MiniBillar.CueContainer.currentInstance.rotation));
        }
        static forceCueToShoot(shotData) {
            MiniBillar.CueContainer.currentInstance.shootReceived(shotData.vector, shotData.deltaScrew, shotData.english);
        }
        static savePosition(velocity, deltaScrew, english) {
            MiniBillar.GameVars.ballsData.length = 0;
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                let ballData = {
                    id: MiniBillar.GameVars.ballArray[i].id,
                    active: MiniBillar.GameVars.ballArray[i].active,
                    x: MiniBillar.GameVars.ballArray[i].position.x,
                    y: MiniBillar.GameVars.ballArray[i].position.y
                };
                MiniBillar.GameVars.ballsData.push(ballData);
            }
            let ballsData = [];
            for (let i = 0; i < MiniBillar.GameVars.ballsData.length; i++) {
                let ball = MiniBillar.GameVars.ballsData[i];
                let newBall = {
                    id: ball.id,
                    x: ball.x,
                    y: ball.y,
                    active: ball.active
                };
                if (ball.id === 0 && ball.active === false) {
                    newBall.x = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][0];
                    newBall.y = MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[0][1];
                }
                ballsData.push(newBall);
            }
        }
        static cueBallSet(x, y) {
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                MiniBillar.MatchManagerPVP.sendCueBallPosition(x, y);
            }
            MiniBillar.StageContainer.currentInstance.newTurn();
        }
        static pocketSelected(pocketId) {
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVP_MODE) {
                    MiniBillar.MatchManagerPVP.sendSelectedPocket(pocketId);
                } else if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                    MiniBillar.MatchManagerPVBot.sendSelectedPocket(pocketId);
                }
            }
        }
        static rackBalls(rndSeed) {
            let seed = rndSeed || Billiard.Maths.fixNumber(Math.random()).toString();
            const prng = new Phaser.RandomDataGenerator([(seed).toString()]);
            if (MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.SOLO_MODE) {
                MiniBillar.GameVars.ballArray = [];
                let ballIndexes = [2, 3, 4, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15];
                let cueBallObject;
                cueBallObject = new MiniBillar.CueBallObject(this.game, 0, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[0][1]);
                MiniBillar.GameVars.ballArray.push(cueBallObject);
                let ballObject;
                ballObject = new MiniBillar.BallObject(this.game, 1, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[1][1], true);
                MiniBillar.GameVars.ballArray.push(ballObject);
                ballObject = new MiniBillar.BallObject(this.game, 8, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[8][1], true);
                MiniBillar.GameVars.ballArray.push(ballObject);
                let i = prng.pick(ballIndexes);
                let ballIndexesAux = ballIndexes.slice();
                if (i <= 7) {
                    ballIndexesAux = ballIndexesAux.splice(6, 7);
                } else {
                    ballIndexesAux = ballIndexesAux.splice(0, 6);
                }
                let j = prng.pick(ballIndexesAux);
                ballObject = new MiniBillar.BallObject(this.game, i, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[3][1], true);
                MiniBillar.GameVars.ballArray.push(ballObject);
                ballObject = new MiniBillar.BallObject(this.game, j, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[14][1], true);
                MiniBillar.GameVars.ballArray.push(ballObject);
                let index = ballIndexes.indexOf(i);
                ballIndexes.splice(index, 1);
                index = ballIndexes.indexOf(j);
                ballIndexes.splice(index, 1);
                ballIndexes = MiniBillar.Utils.shuffle(ballIndexes, prng);
                index = 0;
                for (let i = 0; i < MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO.length; i++) {
                    if (i !== 0 && i !== 1 && i !== 8 && i !== 3 && i !== 14) {
                        ballObject = new MiniBillar.BallObject(this.game, ballIndexes[index], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS_SOLO[i][1], true);
                        MiniBillar.GameVars.ballArray.push(ballObject);
                        index++;
                    }
                }
                for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                    ballObject = MiniBillar.GameVars.ballArray[i];
                    let x = ballObject.position.x + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                    let y = ballObject.position.y + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                    ballObject.position = new Billiard.Vector2D(x, y);
                }
                for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                    let ballData = {
                        id: MiniBillar.GameVars.ballArray[i].id,
                        active: true,
                        x: MiniBillar.GameVars.ballArray[i].position.x,
                        y: MiniBillar.GameVars.ballArray[i].position.y
                    };
                    MiniBillar.GameVars.ballsData.push(ballData);
                }
            } else {
                MiniBillar.GameVars.ballArray = [];
                for (let i = 0; i < MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS.length; i++) {
                    if (i === 0) {
                        let cueBallObject;
                        cueBallObject = new MiniBillar.CueBallObject(this.game, i, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][1]);
                        MiniBillar.GameVars.ballArray.push(cueBallObject);
                    } else {
                        let ballObject = new MiniBillar.BallObject(this.game, i, MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][0], MiniBillar.GameConstants.BALLS_INITIAL_POSITIONS[i][1], true);
                        let x = ballObject.position.x + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                        let y = ballObject.position.y + 0.05 * Billiard.Maths.fixNumber(prng.frac());
                        ballObject.position = new Billiard.Vector2D(x, y);
                        MiniBillar.GameVars.ballArray.push(ballObject);
                    }
                }
            }
        }
        static showAdversaryEmoticon(emoticonID) {
            MiniBillar.PoolState.currentInstance.showAdversaryEmoticon(emoticonID);
        }
        static emoticonSelected(emoticonID) {
            if (!MiniBillar.GameVars.playersSetForPVBot) {
                Communication.CommunicationManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_EMOTICON_SELECTED,
                    data: emoticonID
                });
            }
            MiniBillar.PoolState.currentInstance.emoticonSelected(emoticonID);
        }
        static cueBallSpinSet(data) {
            const english = data.english;
            const verticalSpin = data.verticalSpin;
            MiniBillar.PoolState.currentInstance.gui.cueBallSpinButton.setRedPointPosition(english, verticalSpin);
        }
    }
    MiniBillar.MatchManager = MatchManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class MatchManagerPVBot extends MiniBillar.MatchManager {
        static init(game) {
            super.init(game);
            MatchManagerPVBot.game = game;
            MatchManagerPVBot.doWriteGameData = false;
            MatchManagerPVBot.sidesAlreadyAssigned = false;
            MiniBillar.GameManager.validatePocketedBalls();
            MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
            this.game.state.start("PoolState", true, false);
        }
        static startGame() {
            MiniBillar.MatchManager.rackBalls();
            if (MiniBillar.GameVars.firstShot && MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                MiniBillar.StageContainer.currentInstance.showSetCueBall("Game start and local player's turn");
                MiniBillar.PoolState.currentInstance.showNotificationLayer(MiniBillar.GameConstants.NOTIFICATION_NONE, true, false);
            } else {
                MiniBillar.PoolState.currentInstance.showNotificationLayer(MiniBillar.GameConstants.NOTIFICATION_NONE, false, false);
            }
            MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(true);
            MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([8], true);
            MatchManagerPVBot.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVBot.pocketedBalls = [];
            Billiard.Bot.init(MiniBillar.GameConstants.FRICTION, MiniBillar.GameConstants.BALL_RADIUS, MiniBillar.GameConstants.POCKET_RADIUS, MiniBillar.GameConstants.PHYS_SCALE, MiniBillar.GameConstants.MIN_VELOCITY, MiniBillar.GameConstants.CUSHION_RESTITUTION, MiniBillar.GameConstants.BALL_RESTITUTION, MiniBillar.GameVars.extractLineArrayString(), MiniBillar.GameVars.extractVertexArrayString(), MiniBillar.GameVars.extractPocketArrayString(), MatchManagerPVBot.calculateBotDifficulty());
        }
        static update() {
            if (MiniBillar.GameVars.gameOver) {
                return;
            }
            if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
                MiniBillar.GameVars.turnSet = true;
                MatchManagerPVBot.ballsStoppedMoving(MatchManagerPVBot.pocketedBalls, MatchManagerPVBot.firstTouchedBall, MiniBillar.GameVars.pocketIdWhereBlackFell);
            }
        }
        static ballPocketed(ball) {
            if (ball.id === 8) {
                MiniBillar.RulesManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED,
                    data: null
                });
            }
            MiniBillar.PoolState.currentInstance.ballPocketed(ball.id);
            MatchManagerPVBot.pocketedBalls.push(ball.id);
            super.ballPocketed(ball);
        }
        static newTurn(state) {
            if (MiniBillar.GameVars.gameOver) {
                return;
            }
            MatchManagerPVBot.implementStateMessages(state);
            MiniBillar.GameVars.firstShot = false;
            MiniBillar.GameVars.shotRunning = false;
            MiniBillar.GameVars.english = 0;
            MiniBillar.GameVars.verticalSpin = 0;
            MatchManagerPVBot.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVBot.pocketedBalls = [];
            MiniBillar.MatchManager.setCueAimDirection();
            MiniBillar.PoolState.currentInstance.newTurn();
        }
        static endPVBotGame(reason) {
            MiniBillar.GameVars.gameOver = true;
            MiniBillar.GameVars.gameEnded = reason;
            MiniBillar.GameVars.paused = true;
            if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MatchManagerPVBot.doWriteGameData = true;
                super.showLoseLayer();
            } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon++;
                MatchManagerPVBot.doWriteGameData = true;
                miniplaySend2API("wins", 1);
                let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
                MiniBillar.PoolState.currentInstance.endGame();
            }
            if (MatchManagerPVBot.doWriteGameData) {
                MiniBillar.GameManager.writeGameData();
            }
            miniplaySend2API("plays", 1);
        }
        static matchOverDueToResignation(playerResigned) {
            if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("matchOverDueToResignation()");
            }
            if (playerResigned) {
                MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
            } else {
                MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_WIN);
            }
        }
        static setTouchedBall(ballId) {
            if (ballId === 0) {
                return;
            }
            if (MatchManagerPVBot.firstTouchedBall === MiniBillar.GameConstants.BALL_TYPE_NONE) {
                if (ballId < 8) {
                    MatchManagerPVBot.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                } else if (ballId > 8) {
                    MatchManagerPVBot.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                } else {
                    MatchManagerPVBot.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_BLACK;
                }
            } else {
                return;
            }
        }
        static sendSelectedPocket(pocketId) {
            if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                MiniBillar.RulesManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
                    data: pocketId
                });
                MiniBillar.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static adversaryCueBallPosition(position) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                cueBall.setPositionReceived(position.x * MiniBillar.GameConstants.PHYS_SCALE, position.y * MiniBillar.GameConstants.PHYS_SCALE);
            }
        }
        static adversaryRotatedCue(cueRotation) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                MiniBillar.CueContainer.currentInstance.moveCue(cueRotation);
            }
        }
        static showPocketSelected(num) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                MiniBillar.StageContainer.currentInstance.showSelectPocket("Setting pocket rival chose");
                MiniBillar.StageContainer.currentInstance.setRivalPocket(num);
                MiniBillar.StageContainer.currentInstance.showCue("adversary selected pocket set");
                MiniBillar.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static shotDataReceived(shotData) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                let shotDataFinal = {
                    vector: new Billiard.Vector2D(shotData.cueSpeed.vx, shotData.cueSpeed.vy),
                    deltaScrew: new Billiard.Vector2D(shotData.deltaScrew.x, shotData.deltaScrew.y),
                    english: shotData.english
                };
                super.forceCueToShoot(shotDataFinal);
            }
        }
        static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
            let data = {
                playerTurn: MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER,
                balls: balls,
                firstBall: firstBall,
                blackBallPocket: blackBallPocket
            };
            MiniBillar.RulesManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED,
                data: data
            });
            if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_BALLS_STOPPED");
            }
        }
        static ballHasBeenShot(shotData) {
            MiniBillar.RulesManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_SHOT,
                data: shotData
            });
            if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_SHOT");
            }
        }
        static matchFinished(winnerId, delay = 0) {
            if (delay > 0) {
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND, function() {
                    if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                        console.error("matchFinished()");
                    }
                    if (MiniBillar.GameVars.gameData.playerData.sessionId === winnerId) {
                        MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_WIN);
                    } else {
                        MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_LOSE);
                    }
                }, this);
            } else {
                if (MiniBillar.GameConstants.LOG_BOT_SERVER_INFO) {
                    console.error("matchFinished()");
                }
                if (MiniBillar.GameVars.gameData.playerData.sessionId === winnerId) {
                    MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_WIN);
                } else {
                    MatchManagerPVBot.endPVBotGame(MiniBillar.GameConstants.PLAYER_LOSE);
                }
            }
        }
        static cueRotated(cueRotation) {
            MiniBillar.RulesManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION,
                data: cueRotation
            });
        }
        static calculateBotDifficulty() {
            let base = 3;
            let maximum = 5;
            const played = MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed;
            const won = MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon;
            if (played < 3) {
                return 3;
            }
            if (played < 7) {
                maximum = 5;
            } else if (played < 15) {
                maximum = 7;
            } else {
                maximum = 9;
            }
            let additionalDifficulty = (maximum - base) * (won / played);
            let skill = base + additionalDifficulty;
            return skill;
        }
        static startBotFiringSequence(canMoveCueBall, canPocketBlackBall, botBallsType, botWakeTime, selectPocketTimeAfterWake, shootTimeAfterWake) {
            MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * botWakeTime, function() {
                if (canMoveCueBall) {
                    let cueBallPos = Billiard.Bot.getCueBallPosition(MiniBillar.GameVars.extractBallsArrayString(), botBallsType);
                    MiniBillar.RulesManager.sendMessage({
                        type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL,
                        data: {
                            x: cueBallPos.x,
                            y: cueBallPos.y
                        }
                    });
                }
                const shotData = Billiard.Bot.getShot(MiniBillar.GameVars.extractBallsArrayString(), MiniBillar.GameVars.shotCount, botBallsType === MiniBillar.GameConstants.BALL_TYPE_NONE ? "" : botBallsType, 20000);
                const deltaScrew = MiniBillar.CueContainer.currentInstance.aimDirectionVector.times(new Billiard.Vector2D(shotData.velocity.x, shotData.velocity.y).magnitude *
                    shotData.screw *
                    shotData.verticalSpin);
                if (MiniBillar.GameVars.sabotageBot) {
                    shotData.velocity.x = 0;
                    shotData.velocity.y = 0;
                }
                let shotDataForRulesManager = {
                    cueSpeed: {
                        vx: shotData.velocity.x,
                        vy: shotData.velocity.y
                    },
                    deltaScrew: {
                        x: deltaScrew.x,
                        y: deltaScrew.y
                    },
                    english: shotData.english
                };
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * selectPocketTimeAfterWake, function() {
                    if (canPocketBlackBall) {
                        MiniBillar.RulesManager.sendMessage({
                            type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
                            data: shotData.pocket8Ball
                        });
                    }
                    const v = new Billiard.Vector2D(shotData.velocity.x, shotData.velocity.y).normalize();
                    let cueAngle = Math.atan2(-v.y, -v.x);
                    MatchManagerPVBot.cueRotated(cueAngle);
                }, MiniBillar.GameManager);
                MatchManagerPVBot.game.time.events.add(Phaser.Timer.SECOND * shootTimeAfterWake, function() {
                    MatchManagerPVBot.ballHasBeenShot(shotDataForRulesManager);
                }, MiniBillar.GameManager);
            }, MiniBillar.GameManager);
        }
        static implementStateMessages(state) {
            MiniBillar.GameVars.skipShowingPocketAndCue = false;
            const isPlayerTurn = MiniBillar.GameVars.gameData.playerData.sessionId === state.currentTurn;
            if (state.fault === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                cueBall.onUpTimeOut();
                MiniBillar.CueContainer.currentInstance.onUpTimeOut();
                MiniBillar.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
            }
            let player = MiniBillar.GameVars.gameData.playerData.sessionId === state.human.sessionId ? state.human : state.bot;
            let adversary = MiniBillar.GameVars.gameData.playerData.sessionId === state.bot.sessionId ? state.human : state.bot;
            if (isPlayerTurn) {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
            } else {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
            }
            if (!MatchManagerPVBot.sidesAlreadyAssigned) {
                if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                    MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(MiniBillar.GameConstants.BALL_TYPE_SOLID);
                    MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([9, 10, 11, 12, 13, 14, 15], true);
                    MatchManagerPVBot.sidesAlreadyAssigned = true;
                } else if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(MiniBillar.GameConstants.BALL_TYPE_STRIPED);
                    MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([1, 2, 3, 4, 5, 6, 7], true);
                    MatchManagerPVBot.sidesAlreadyAssigned = true;
                }
            }
            if (state.ballInHand) {
                MiniBillar.StageContainer.currentInstance.showSetCueBall("Foul commited by non local player");
            }
            MiniBillar.StageContainer.currentInstance.hideSelectPocket("Not local player's turn or not time to choose pocket");
            MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(false);
            let opponentChoosingPocket = false;
            if (!isPlayerTurn && adversary.canPocketBlackBall) {
                opponentChoosingPocket = true;
                MiniBillar.GameVars.skipShowingPocketAndCue = true;
            }
            MiniBillar.PoolState.currentInstance.showNotificationLayer(state.fault, isPlayerTurn, opponentChoosingPocket);
            if (isPlayerTurn && player.canPocketBlackBall) {
                MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([8], false);
                MiniBillar.StageContainer.currentInstance.showSelectPocket("It's time to choose pocket");
                MiniBillar.GameVars.skipShowingPocketAndCue = true;
            }
            if (!isPlayerTurn) {
                MatchManagerPVBot.startBotFiringSequence(state.ballInHand, adversary.canPocketBlackBall, adversary.typeBalls, 3.6, 1, 2);
            }
        }
    }
    MiniBillar.MatchManagerPVBot = MatchManagerPVBot;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class MatchManagerPVP extends MiniBillar.MatchManager {
        static init(game, currentTurnPlayer_SessionId) {
            super.init(game);
            MatchManagerPVP.game = game;
            MatchManagerPVP.doWriteGameData = false;
            MatchManagerPVP.sidesAlreadyAssigned = false;
            if (!MiniBillar.GameVars.gameData.playerData) {
                console.error("playerData corrupt");
            }
            if (!MiniBillar.GameVars.adversaryData) {
                console.error("adversaryData corrupt");
            }
            MiniBillar.GameManager.validatePocketedBalls();
            if (MiniBillar.GameVars.gameData.playerData.sessionId === currentTurnPlayer_SessionId) {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
            } else {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
            }
            this.game.state.start("PoolState", true, false);
        }
        static startGame() {
            MiniBillar.MatchManager.rackBalls(Communication.CommunicationManager.room.id);
            if (MiniBillar.GameVars.firstShot && MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER) {
                MiniBillar.StageContainer.currentInstance.showSetCueBall("Game start and local player's turn");
                MiniBillar.PoolState.currentInstance.showNotificationLayer(MiniBillar.GameConstants.NOTIFICATION_NONE, true, false);
            } else {
                MiniBillar.PoolState.currentInstance.showNotificationLayer(MiniBillar.GameConstants.NOTIFICATION_NONE, false, false);
            }
            MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(true);
            MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([8], true);
            MatchManagerPVP.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVP.pocketedBalls = [];
        }
        static update() {
            if (MiniBillar.GameVars.gameOver) {
                return;
            }
            if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
                MiniBillar.GameVars.turnSet = true;
                MatchManagerPVP.ballsStoppedMoving(MatchManagerPVP.pocketedBalls, MatchManagerPVP.firstTouchedBall, MiniBillar.GameVars.pocketIdWhereBlackFell);
            }
        }
        static ballPocketed(ball) {
            if (ball.id === 8) {
                Communication.CommunicationManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED,
                    data: null
                });
            }
            MiniBillar.PoolState.currentInstance.ballPocketed(ball.id);
            MatchManagerPVP.pocketedBalls.push(ball.id);
            super.ballPocketed(ball);
        }
        static newTurn(state) {
            if (MiniBillar.GameVars.gameOver) {
                return;
            }
            MatchManagerPVP.implementStateMessages(state);
            MiniBillar.GameVars.firstShot = false;
            MiniBillar.GameVars.shotRunning = false;
            MiniBillar.GameVars.english = 0;
            MiniBillar.GameVars.verticalSpin = 0;
            MatchManagerPVP.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_NONE;
            MatchManagerPVP.pocketedBalls = [];
            MiniBillar.GameVars.timerSolo = 20;
            MiniBillar.MatchManager.setCueAimDirection();
            MiniBillar.PoolState.currentInstance.newTurn();
        }
        static endPVPGame(reason) {
            MiniBillar.GameVars.gameOver = true;
            MiniBillar.GameVars.gameEnded = reason;
            MiniBillar.GameVars.paused = true;
            if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MatchManagerPVP.doWriteGameData = true;
                super.showLoseLayer();
            } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesPlayed++;
                MiniBillar.GameVars.gameData.statistics.nonSolo.gamesWon++;
                MatchManagerPVP.doWriteGameData = true;
                miniplaySend2API("wins", 1);
                let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
                MiniBillar.PoolState.currentInstance.endGame();
            } else if (reason === MiniBillar.GameConstants.ADVERSARY_LEFT_ROOM) {
                super.showAdversaryLeftLayer();
            }
            if (MatchManagerPVP.doWriteGameData) {
                MiniBillar.GameManager.writeGameData();
            }
            miniplaySend2API("plays", 1);
        }
        static matchOverDueToResignation(resigningPlayerSessionId) {
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_RESIGN,
                data: MiniBillar.GameVars.gameData.playerData.sessionId
            });
            Communication.CommunicationManager.leaveRoom();
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("matchOverDueToResignation()");
            }
            if (MiniBillar.GameVars.gameData.playerData.sessionId === resigningPlayerSessionId) {
                MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_RESIGNS);
            } else {
                MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_WIN);
            }
        }
        static adversaryLeftRoomPVP() {
            MiniBillar.GameManager.log("ADVERSARY LEFT ROOM");
            if (MiniBillar.GameVars.gameOver || MiniBillar.GameVars.gameMode === MiniBillar.GameConstants.PVBOT_MODE) {
                return;
            }
            if (MiniBillar.LobbyState.currentInstance) {
                MiniBillar.GameManager.enterSplash();
            }
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("adversaryLeftRoomPVP()");
            }
            MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.ADVERSARY_LEFT_ROOM);
        }
        static setTouchedBall(ballId) {
            if (ballId === 0) {
                return;
            }
            if (MatchManagerPVP.firstTouchedBall === MiniBillar.GameConstants.BALL_TYPE_NONE) {
                if (ballId < 8) {
                    MatchManagerPVP.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                } else if (ballId > 8) {
                    MatchManagerPVP.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                } else {
                    MatchManagerPVP.firstTouchedBall = MiniBillar.GameConstants.BALL_TYPE_BLACK;
                }
            } else {
                return;
            }
        }
        static setTouchedCushion(touchedCushion) {}
        static sendCueBallPosition(x, y) {
            if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                Communication.CommunicationManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL,
                    data: {
                        x: x,
                        y: y
                    }
                });
            }
        }
        static sendSelectedPocket(pocketId) {
            if (MiniBillar.GameVars.currentTurn !== MiniBillar.GameConstants.ADVERSARY) {
                Communication.CommunicationManager.sendMessage({
                    type: MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED,
                    data: pocketId
                });
                MiniBillar.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static adversaryCueBallPosition(position) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                cueBall.setPositionReceived(position.x, position.y);
            }
        }
        static adversaryRotatedCue(cueRotation) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                MiniBillar.CueContainer.currentInstance.moveCue(cueRotation);
            }
        }
        static showPocketSelected(num) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                MiniBillar.StageContainer.currentInstance.showSelectPocket("Setting pocket rival chose");
                MiniBillar.StageContainer.currentInstance.setRivalPocket(num);
                MiniBillar.StageContainer.currentInstance.showCue("adversary selected pocket set");
                MiniBillar.GameVars.skipShowingPocketAndCue = false;
            }
        }
        static shotDataReceived(shotData) {
            if (MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.ADVERSARY) {
                let shotDataFinal = {
                    vector: new Billiard.Vector2D(shotData.cueSpeed.vx, shotData.cueSpeed.vy),
                    deltaScrew: new Billiard.Vector2D(shotData.deltaScrew.x, shotData.deltaScrew.y),
                    english: shotData.english
                };
                super.forceCueToShoot(shotDataFinal);
            }
        }
        static cueRotated(cueRotation) {
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION,
                data: cueRotation
            });
        }
        static ballsStoppedMoving(balls, firstBall, blackBallPocket) {
            let data = {
                playerTurn: MiniBillar.GameVars.currentTurn === MiniBillar.GameConstants.PLAYER,
                balls: balls,
                firstBall: firstBall,
                blackBallPocket: blackBallPocket
            };
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED,
                data: data
            });
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_BALLS_STOPPED");
            }
        }
        static ballHasBeenShot(shotData) {
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_SHOT,
                data: shotData
            });
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_SHOT");
            }
        }
        static matchFinished(winnerId) {
            this.game.time.events.add(650, Communication.CommunicationManager.leaveRoom, Communication.CommunicationManager);
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("matchFinished()");
            }
            if (MiniBillar.GameVars.gameData.playerData.sessionId === winnerId) {
                MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_WIN);
            } else {
                MatchManagerPVP.endPVPGame(MiniBillar.GameConstants.PLAYER_LOSE);
            }
        }
        static playerSet() {
            Communication.CommunicationManager.sendMessage({
                type: MiniBillar.GameConstants.MESSAGE_TYPE_PLAYER_SET,
                data: null
            });
            if (MiniBillar.GameConstants.LOG_SERVER_INFO) {
                console.error("sending GameConstants.MESSAGE_TYPE_PLAYER_SET");
            }
        }
        static implementStateMessages(state) {
            if (!state.playerA || !state.playerB) {
                return;
            }
            MiniBillar.GameVars.skipShowingPocketAndCue = false;
            const isPlayerTurn = MiniBillar.GameVars.gameData.playerData.sessionId === state.currentTurn;
            if (state.fault === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                cueBall.onUpTimeOut();
                MiniBillar.CueContainer.currentInstance.onUpTimeOut();
                MiniBillar.PoolState.currentInstance.onNonSoloTimeOut(isPlayerTurn);
            }
            let player = MiniBillar.GameVars.gameData.playerData.sessionId === state.playerA.sessionId ? state.playerA : state.playerB;
            let adversary = MiniBillar.GameVars.gameData.playerData.sessionId === state.playerB.sessionId ? state.playerA : state.playerB;
            if (isPlayerTurn) {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.PLAYER;
            } else {
                MiniBillar.GameVars.currentTurn = MiniBillar.GameConstants.ADVERSARY;
            }
            if (!MatchManagerPVP.sidesAlreadyAssigned) {
                if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                    MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(MiniBillar.GameConstants.BALL_TYPE_SOLID);
                    MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([9, 10, 11, 12, 13, 14, 15], true);
                    MatchManagerPVP.sidesAlreadyAssigned = true;
                } else if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    MiniBillar.PoolState.currentInstance.hud.assignSidesForNonSOLO(MiniBillar.GameConstants.BALL_TYPE_STRIPED);
                    MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([1, 2, 3, 4, 5, 6, 7], true);
                    MatchManagerPVP.sidesAlreadyAssigned = true;
                }
            }
            if (state.ballInHand && MiniBillar.StageContainer.currentInstance) {
                MiniBillar.StageContainer.currentInstance.showSetCueBall("Foul commited by non local player");
            }
            MiniBillar.StageContainer.currentInstance.hideSelectPocket("Not local player's turn or not time to choose pocket");
            MiniBillar.PoolState.currentInstance.hud.focusOnActivePortrait(false);
            let opponentChoosingPocket = false;
            if (!isPlayerTurn && adversary.canPocketBlackBall) {
                opponentChoosingPocket = true;
                MiniBillar.GameVars.skipShowingPocketAndCue = true;
            }
            MiniBillar.PoolState.currentInstance.showNotificationLayer(state.fault, isPlayerTurn, opponentChoosingPocket);
            if (isPlayerTurn && player.canPocketBlackBall) {
                MiniBillar.StageContainer.currentInstance.setGuideProhibitedBalls([8], false);
                MiniBillar.StageContainer.currentInstance.showSelectPocket("It's time to choose pocket");
                MiniBillar.GameVars.skipShowingPocketAndCue = true;
            }
        }
    }
    MiniBillar.MatchManagerPVP = MatchManagerPVP;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class MatchManagerSolo extends MiniBillar.MatchManager {
        static init(game) {
            super.init(game);
            MatchManagerSolo.game = game;
            MatchManagerSolo.doWriteGameData = false;
            MatchManagerSolo.currentTurnStreak = 0;
            MatchManagerSolo.comboTicker = 0;
        }
        static startGame() {
            MiniBillar.MatchManager.rackBalls();
            MiniBillar.GameManager.validatePocketedBalls();
            if (MiniBillar.GameVars.gameData.soloTutorial) {
                MiniBillar.PoolState.currentInstance.showNotificationLayer(MiniBillar.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS);
                MiniBillar.GameVars.gameData.soloTutorial = false;
                MiniBillar.GameManager.writeGameData();
            }
        }
        static update() {
            if (!MiniBillar.GameVars.shotRunning && !MiniBillar.GameVars.turnSet) {
                this.newTurn();
                MatchManagerSolo.currentTurnStreak = 0;
                MatchManagerSolo.comboTicker = 0;
            }
            if (MatchManagerSolo.comboTicker > 0) {
                MatchManagerSolo.comboTicker -= this.game.time.physicsElapsed;
            } else if (MatchManagerSolo.currentTurnStreak > 0) {
                MatchManagerSolo.currentTurnStreak = 0;
            }
        }
        static ballPocketed(ball) {
            const id = ball.id;
            if (id === 0) {
                MiniBillar.GameVars.playerPoints -= 20;
            } else {
                MiniBillar.GameVars.timerSolo += 10;
                MiniBillar.GameVars.playerPoints += 50;
                MiniBillar.PoolState.currentInstance.animArrow();
                if (MatchManagerSolo.currentTurnStreak === 1) {
                    MiniBillar.GameVars.playerPoints += 50;
                    MiniBillar.PoolState.currentInstance.hud.showComboEffect(700);
                } else if (MatchManagerSolo.currentTurnStreak >= 2) {
                    MiniBillar.GameVars.playerPoints += 50;
                    MiniBillar.PoolState.currentInstance.hud.showSuperComboEffect(500);
                }
                MatchManagerSolo.currentTurnStreak++;
                MatchManagerSolo.comboTicker = 3;
            }
            super.ballPocketed(ball);
            if (MiniBillar.GameVars.pocketedBalls.length >= 15) {
                let cueBall = MiniBillar.GameVars.ballArray[0];
                this.game.add.tween(cueBall.mc).to({
                        alpha: 0
                    }, 350, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        MatchManagerSolo.resetBalls();
                    }, this);
                this.game.add.tween(cueBall.shadow).to({
                        alpha: 0
                    }, 350, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        MatchManagerSolo.resetBalls();
                    }, this);
            }
        }
        static newTurn() {
            if (MiniBillar.GameVars.gameOver) {
                return;
            }
            MiniBillar.GameVars.firstShot = false;
            MiniBillar.GameVars.shotRunning = false;
            MiniBillar.GameVars.turnSet = true;
            MiniBillar.GameVars.english = 0;
            MiniBillar.GameVars.verticalSpin = 0;
            if (MiniBillar.GameVars.pocketedBalls.length >= 15) {
                MatchManagerSolo.resetBalls();
            }
            MiniBillar.MatchManager.setCueAimDirection();
            MiniBillar.PoolState.currentInstance.newTurn();
            MiniBillar.GameVars.ballsData.length = 0;
            for (let i = 0; i < MiniBillar.GameVars.ballArray.length; i++) {
                let ballData = {
                    id: MiniBillar.GameVars.ballArray[i].id,
                    active: MiniBillar.GameVars.ballArray[i].active,
                    x: MiniBillar.GameVars.ballArray[i].position.x,
                    y: MiniBillar.GameVars.ballArray[i].position.y
                };
                MiniBillar.GameVars.ballsData.push(ballData);
            }
            MiniBillar.GameManager.log("ballData:" + JSON.stringify(MiniBillar.GameVars.ballsData));
        }
        static resetBalls() {
            MiniBillar.GameVars.pocketedBalls = [];
            MiniBillar.GameVars.ballsData = [];
            MiniBillar.GameVars.canStart = false;
            MiniBillar.GameVars.firstShot = true;
            MiniBillar.GameVars.resetScoreAndTime = false;
            MiniBillar.GameManager.enterSoloGame();
        }
        static computeSoloStats() {
            if (MiniBillar.GameVars.playerPoints > MiniBillar.GameVars.gameData.statistics.solo.highScore) {
                MiniBillar.GameVars.gameData.statistics.solo.highScore = MiniBillar.GameVars.playerPoints;
                MatchManagerSolo.doWriteGameData = true;
            }
        }
        static endSoloGame(reason) {
            MiniBillar.GameVars.gameOver = true;
            MiniBillar.GameVars.gameEnded = reason;
            MiniBillar.GameVars.paused = true;
            MatchManagerSolo.computeSoloStats();
            if (reason === MiniBillar.GameConstants.PLAYER_LOSE) {
                super.showSoloRetryLayer();
            } else if (reason === MiniBillar.GameConstants.PLAYER_WIN) {
                MatchManagerSolo.doWriteGameData = true;
                let victoryData = MiniBillar.RewardsManager.prepareRewardStats();
                super.showVictoryLayer(victoryData);
            } else if (reason === MiniBillar.GameConstants.PLAYER_RESIGNS) {
                MiniBillar.PoolState.currentInstance.endGame();
            }
            if (MatchManagerSolo.doWriteGameData) {
                MiniBillar.GameManager.writeGameData();
            }
            miniplaySend2API("score", MiniBillar.GameVars.gameData.statistics.solo.highScore);
            if (MiniBillar.GameVars.timerSolo === -1) {
                miniplaySend2API("plays", 1);
            }
        }
        static startSoloTime() {
            this.game.time.events.loop(Phaser.Timer.SECOND, function() {
                if (MiniBillar.GameVars.paused || !MiniBillar.GameVars.startMatch) {
                    return;
                }
                MiniBillar.GameVars.timerSolo--;
                MiniBillar.PoolState.currentInstance.hud.updateSoloTimer();
                if (MiniBillar.GameVars.timerSolo === -1) {
                    const rewardEarned = MiniBillar.GameVars.playerPoints >= MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD;
                    if (rewardEarned) {
                        this.endSoloGame(MiniBillar.GameConstants.PLAYER_WIN);
                    } else {
                        this.endSoloGame(MiniBillar.GameConstants.PLAYER_LOSE);
                    }
                }
            }, this);
        }
    }
    MiniBillar.MatchManagerSolo = MatchManagerSolo;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class RulesManager {
        static init(playerData, botData) {
            RulesManager.offlineState = ({
                human: null,
                bot: null,
                currentTurn: null,
                changeTurn: false,
                numberShots: 0,
                balls: [],
                ballInHand: true,
                pocketSelected: -1,
                fault: MiniBillar.GameConstants.NOTIFICATION_NONE,
                playerLeft: false,
                winnerSessionId: null
            });
            for (let i = 0; i < 16; i++) {
                let ball = {
                    id: i,
                    active: true
                };
                RulesManager.offlineState.balls.push(ball);
            }
            RulesManager.setupPlayerAndBot(playerData, botData);
        }
        static sendMessage(message) {
            RulesManager.onMessage(message);
        }
        static onMessage(message) {
            switch (message.type) {
                case MiniBillar.GameConstants.MESSAGE_TYPE_BALLS_STOPPED:
                    RulesManager.offlineState.human.ballsMoving = false;
                    RulesManager.updateState(message.data);
                    RulesManager.decideTurn();
                    if (!RulesManager.offlineState.winnerSessionId) {
                        MiniBillar.GameManager.onPVBotTurnChange(RulesManager.offlineState);
                    } else {
                        MiniBillar.MatchManagerPVBot.matchFinished(this.offlineState.winnerSessionId);
                    }
                    break;
                case MiniBillar.GameConstants.MESSAGE_TYPE_POCKET_SELECTED:
                    RulesManager.offlineState.pocketSelected = message.data;
                    MiniBillar.MatchManagerPVBot.showPocketSelected(message.data);
                    break;
                case MiniBillar.GameConstants.MESSAGE_TYPE_CUE_ROTATION:
                    MiniBillar.MatchManagerPVBot.adversaryRotatedCue(message.data);
                    break;
                case MiniBillar.GameConstants.MESSAGE_TYPE_CUE_BALL:
                    MiniBillar.MatchManagerPVBot.adversaryCueBallPosition(message.data);
                    break;
                case MiniBillar.GameConstants.MESSAGE_TYPE_SHOT:
                    RulesManager.offlineState.human.ballsMoving = true;
                    RulesManager.offlineState.bot.ballsMoving = true;
                    MiniBillar.MatchManagerPVBot.shotDataReceived(message.data);
                    break;
                case MiniBillar.GameConstants.MESSAGE_TYPE_BALL_8_POCKETED:
                    if (!RulesManager.offlineState.human.canPocketBlackBall && !RulesManager.offlineState.bot.canPocketBlackBall) {
                        if (RulesManager.offlineState.currentTurn === RulesManager.offlineState.human.sessionId) {
                            RulesManager.offlineState.winnerSessionId = RulesManager.offlineState.bot.sessionId;
                        } else {
                            RulesManager.offlineState.winnerSessionId = RulesManager.offlineState.human.sessionId;
                        }
                        MiniBillar.MatchManagerPVBot.matchFinished(RulesManager.offlineState.winnerSessionId, 2);
                        RulesManager.offlineState.winnerSessionId = null;
                    }
                    break;
                default:
            }
        }
        static timeOut() {
            RulesManager.offlineState.changeTurn = true;
            RulesManager.offlineState.ballInHand = true;
            RulesManager.offlineState.fault = MiniBillar.GameConstants.NOTIFICATION_TIMEOUT;
            RulesManager.offlineState.pocketSelected = -1;
            RulesManager.decideTurn();
            MiniBillar.GameManager.onPVBotTurnChange(RulesManager.offlineState);
        }
        static setupPlayerAndBot(playerData, botData) {
            RulesManager.offlineState.human = playerData;
            RulesManager.offlineState.bot = botData;
            RulesManager.offlineState.currentTurn = RulesManager.offlineState.human.sessionId;
            RulesManager.offlineState.numberShots += 1;
        }
        static updateState(data) {
            let balls = data.balls;
            let firstBallTouch = data.firstBall;
            let blackBallPocket = data.blackBallPocket;
            let player;
            if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                player = this.offlineState.human;
            } else {
                player = this.offlineState.bot;
            }
            let fault = false;
            let typeFault = MiniBillar.GameConstants.NOTIFICATION_NONE;
            if (firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_NONE) {
                fault = true;
                typeFault = MiniBillar.GameConstants.NOTIFICATION_NO_BALL_TOUCHED;
            }
            if (firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_BLACK && !player.canPocketBlackBall) {
                fault = true;
                typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            if (firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_SOLID && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                fault = true;
                typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            if (firstBallTouch === MiniBillar.GameConstants.BALL_TYPE_STRIPED && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                fault = true;
                typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED;
            }
            for (let i = 0; i < balls.length; i++) {
                if (balls[i] === 0) {
                    fault = true;
                    typeFault = MiniBillar.GameConstants.NOTIFICATION_CUE_BALL_POTTED;
                } else if (balls[i] === 8 && !player.canPocketBlackBall) {
                    fault = true;
                    typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                } else if (balls[i] < 8 && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    fault = true;
                    typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                } else if (balls[i] > 8 && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                    fault = true;
                    typeFault = MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED;
                }
            }
            let pocketBall = false;
            let win = -1;
            for (let i = 0; i < balls.length; i++) {
                if (balls[i] === 0) {
                    continue;
                } else if (balls[i] < 8 && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                    pocketBall = true;
                } else if (balls[i] > 8 && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    pocketBall = true;
                } else if (balls[i] !== 8 && player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE) {
                    pocketBall = true;
                } else if (balls[i] === 8) {
                    if (player.canPocketBlackBall) {
                        if (fault) {
                            win = 0;
                        } else {
                            if (this.offlineState.pocketSelected === blackBallPocket) {
                                win = 1;
                            } else {
                                win = 0;
                            }
                        }
                    } else {
                        win = 0;
                    }
                }
            }
            if (win !== -1) {
                if (win === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
                    } else {
                        this.offlineState.winnerSessionId = this.offlineState.human.sessionId;
                    }
                } else if (win === 1) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.winnerSessionId = this.offlineState.human.sessionId;
                    } else {
                        this.offlineState.winnerSessionId = this.offlineState.bot.sessionId;
                    }
                }
            }
            if (player.typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE && !fault) {
                let solidBalls = 0;
                let stripedBalls = 0;
                for (let i = 0; i < balls.length; i++) {
                    if (balls[i] === 0 || balls[i] === 8) {
                        continue;
                    } else if (balls[i] < 8) {
                        solidBalls++;
                    } else if (balls[i] > 8) {
                        stripedBalls++;
                    }
                }
                if (solidBalls > 0 && stripedBalls === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.human.typeBalls = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.bot.typeBalls = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                    } else {
                        this.offlineState.bot.typeBalls = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.human.typeBalls = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                    }
                } else if (stripedBalls > 0 && solidBalls === 0) {
                    if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                        this.offlineState.bot.typeBalls = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.human.typeBalls = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                    } else {
                        this.offlineState.human.typeBalls = MiniBillar.GameConstants.BALL_TYPE_SOLID;
                        this.offlineState.bot.typeBalls = MiniBillar.GameConstants.BALL_TYPE_STRIPED;
                    }
                }
            }
            if (fault) {
                this.offlineState.changeTurn = true;
                this.offlineState.ballInHand = true;
            } else {
                if (pocketBall) {
                    this.offlineState.changeTurn = false;
                } else {
                    this.offlineState.changeTurn = true;
                }
                this.offlineState.ballInHand = false;
            }
            this.offlineState.fault = typeFault;
            this.offlineState.pocketSelected = -1;
            for (let i = 0; i < balls.length; i++) {
                for (let j = 0; j < this.offlineState.balls.length; j++) {
                    if (balls[i] === this.offlineState.balls[j].id) {
                        this.offlineState.balls[j].active = false;
                        if (this.offlineState.balls[j].id === 0) {
                            this.offlineState.balls[j].active = true;
                        }
                    }
                }
            }
            this.offlineState.bot.canPocketBlackBall = RulesManager.canPocketBlackBall(this.offlineState.bot.typeBalls);
            this.offlineState.human.canPocketBlackBall = RulesManager.canPocketBlackBall(this.offlineState.human.typeBalls);
        }
        static decideTurn() {
            if (this.offlineState.changeTurn) {
                if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                    this.offlineState.currentTurn = this.offlineState.bot.sessionId;
                } else {
                    this.offlineState.currentTurn = this.offlineState.human.sessionId;
                }
            } else {
                if (this.offlineState.currentTurn === this.offlineState.human.sessionId) {
                    this.offlineState.currentTurn = this.offlineState.human.sessionId;
                } else {
                    this.offlineState.currentTurn = this.offlineState.bot.sessionId;
                }
            }
            this.offlineState.numberShots += 1;
        }
        static canPocketBlackBall(typeBalls) {
            let result = true;
            for (let i = 0; i < RulesManager.offlineState.balls.length; i++) {
                if (RulesManager.offlineState.balls[i].id === 0 || RulesManager.offlineState.balls[i].id === 8) {
                    continue;
                }
                if (!RulesManager.offlineState.balls[i].active) {
                    continue;
                }
                if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_NONE) {
                    result = false;
                } else if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_SOLID) {
                    if (RulesManager.offlineState.balls[i].id < 8) {
                        result = false;
                    }
                } else if (typeBalls === MiniBillar.GameConstants.BALL_TYPE_STRIPED) {
                    if (RulesManager.offlineState.balls[i].id > 8) {
                        result = false;
                    }
                }
            }
            return result;
        }
    }
    MiniBillar.RulesManager = RulesManager;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class NotificationLayer extends Phaser.Group {
        constructor(game, type, isPlayerTurn, opponentChoosingPocket) {
            super(game, null, "messages-layer");
            NotificationLayer.currentInstance = this;
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.x = MiniBillar.GameVars.gameWidth / 2;
            this.y = MiniBillar.GameVars.gameHeight / 2;
            this.notificationDurationScaleModifier = 0.4;
            this.layerFadeDuration = 1000 * this.notificationDurationScaleModifier;
            this.layerDisplayDuration = 7000 * this.notificationDurationScaleModifier;
            this.alpha = 0;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, this.layerFadeDuration, Phaser.Easing.Cubic.Out, true)
                .onComplete.add(function() {
                    NotificationLayer.currentInstance.hideNotification();
                }, this);
            if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                this.showNonSOLONotification(type, isPlayerTurn, opponentChoosingPocket);
            } else {
                if (type === MiniBillar.GameConstants.NOTIFICATION_FIRST_TIME_INSTRUCTIONS) {
                    const transparentBackground = new Phaser.Sprite(this.game, 0, 145, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
                    transparentBackground.anchor.set(0.5, 0);
                    transparentBackground.alpha = .6;
                    this.add(transparentBackground);
                    let rulesText = new Phaser.Text(this.game, 0, 160, MiniBillar.GameConstants.RULES_TEXT, {
                        font: this.game.device.desktop ? "24px Oswald-DemiBold" : "34px Oswald-DemiBold",
                        fontWeight: "600",
                        fill: "#e7f6f8",
                        align: "center",
                        stroke: "#2f3237",
                        strokeThickness: 3
                    });
                    rulesText.anchor.set(0.5, 0);
                    MiniBillar.Utils.colourRulesText(rulesText);
                    this.add(rulesText);
                    transparentBackground.scale.set((rulesText.width + 40) / 64, (rulesText.height + 30) / 64);
                    this.layerDisplayDuration = 16000 * this.notificationDurationScaleModifier;
                }
            }
        }
        hideNotification() {
            if (!this.game) {
                return;
            }
            this.game.add.tween(this)
                .to({
                    alpha: 0
                }, this.layerFadeDuration, Phaser.Easing.Cubic.Out, true, this.layerDisplayDuration)
                .onComplete.add(function() {
                    MiniBillar.PoolState.currentInstance.hideNotificationLayer();
                }, this);
        }
        showNonSOLONotification(type, isPlayerTurn, opponentChoosingPocket) {
            const turnImageSwipeDuration = 1000 * this.notificationDurationScaleModifier;
            const turnImageDisplayDuration = 5000 * this.notificationDurationScaleModifier;
            let text = new Phaser.Text(this.game, 0, 0, "", {
                font: "30px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#EB3359",
                align: "center"
            });
            text.stroke = "#673952";
            text.strokeThickness = 5;
            text.anchor.set(0.5);
            this.add(text);
            const turnImage = new Phaser.Image(this.game, MiniBillar.GameVars.gameWidth + 100, 240, "texture_atlas_1", isPlayerTurn ? "your_turn.png" : "rivals_turn.png");
            turnImage.anchor.set(0.5);
            this.add(turnImage);
            this.game.add.tween(turnImage)
                .to({
                    x: 50
                }, turnImageSwipeDuration, Phaser.Easing.Exponential.Out, true, this.layerFadeDuration)
                .onComplete.add(function() {
                    this.game.add.tween(turnImage)
                        .to({
                            x: turnImage.x - 100
                        }, turnImageDisplayDuration, Phaser.Easing.Linear.None, true)
                        .onComplete.add(function() {
                            this.game.add.tween(turnImage).to({
                                x: -MiniBillar.GameVars.gameWidth - 100
                            }, turnImageSwipeDuration, Phaser.Easing.Exponential.In, true);
                        }, this);
                }, this);
            if (type === MiniBillar.GameConstants.NOTIFICATION_CUE_BALL_POTTED) {
                text.text = "CUE BALL POCKETED";
            } else if (type === MiniBillar.GameConstants.NOTIFICATION_NO_BALL_TOUCHED) {
                text.text = "NO BALL TOUCHED";
            } else if (type === MiniBillar.GameConstants.NOTIFICATION_TIMEOUT) {
                text.text = "OUT OF TIME";
            } else if (type === MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_POTTED) {
                text.text = "WRONG BALL POCKETED";
            } else if (type === MiniBillar.GameConstants.NOTIFICATION_WRONG_BALL_TOUCHED) {
                text.text = "WRONG BALL TOUCHED FIRST";
            } else if (type === MiniBillar.GameConstants.NOTIFICATION_NONE) {
                text.visible = false;
            }
            if (opponentChoosingPocket) {
                if (text.visible) {
                    text.text += "\n";
                } else {
                    text.visible = true;
                }
                text.text += "OPPONENT CHOOSING POCKET";
            }
            const iconFoul = new Phaser.Image(this.game, 0, text.y, "texture_atlas_1", "icon_foul.png");
            iconFoul.anchor.set(1, 0.5);
            const iconHalfWidth = iconFoul.width * 0.5;
            text.x += iconHalfWidth * 1.2;
            iconFoul.x = text.x - (text.width * 0.5);
            iconFoul.visible = text.visible;
            this.add(iconFoul);
        }
    }
    MiniBillar.NotificationLayer = NotificationLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class RewardCard extends Phaser.Group {
        constructor(game, x, y, cardId, currentPoints = -1, insideScaledObject = true, clickable = false) {
            super(game, null, "reward-card");
            if (!insideScaledObject) {
                this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }
            this.x = x;
            this.y = y;
            this.cardId = cardId;
            this.cardType = MiniBillar.RewardsManager.getCardType(this.cardId);
            this.parentRail = null;
            this.pointsToIncrement = 0;
            this.incrementPointsDt = 0;
            this.incrementPointsCounter = 0;
            if (currentPoints < 0) {
                this.points = MiniBillar.RewardsManager.getCardPoints(this.cardId);
            } else {
                this.points = currentPoints;
            }
            const cardImageNameWithExtension = this.cardId + ".png";
            this.cardMaxPoints = MiniBillar.RewardsManager.getMaxForCardType(this.cardType);
            this.cardMaxPointsLabel = "/" + this.cardMaxPoints;
            this.boxContainerImage = new Phaser.Image(this.game, 0, 0, "texture_atlas_5", cardImageNameWithExtension);
            this.boxContainerImage.anchor.set(0.5);
            if (clickable) {
                this.boxContainerImage.inputEnabled = true;
            }
            this.add(this.boxContainerImage);
            const progressBarBG = new Phaser.Graphics(this.game, 0, 0);
            progressBarBG.beginFill(0x006f4c);
            this.add(progressBarBG);
            this.progressBar = new Phaser.Image(this.game, 0, 120, "texture_atlas_1", "progress_bar.png");
            this.progressBar.scale.x *= 1.03;
            this.progressBar.scale.y *= 1.1;
            this.progressBar.anchor.set(0.5);
            this.add(this.progressBar);
            progressBarBG.drawRect(0, -this.progressBar.height / 2, this.progressBar.width, this.progressBar.height);
            progressBarBG.x = this.progressBar.x - this.progressBar.width / 2;
            progressBarBG.y = this.progressBar.y;
            this.progressMaskRectangle = new Phaser.Graphics(this.game, this.progressBar.x - this.progressBar.width / 2, this.progressBar.y);
            this.progressMaskRectangle.beginFill(0xffffff);
            this.progressMaskRectangle.drawRect(0, -this.progressBar.height / 2, this.progressBar.width, this.progressBar.height);
            this.progressMaskRectangle.endFill();
            this.progressMaskRectangle.renderable = false;
            const maskScale = Phaser.Math.clamp(currentPoints / this.cardMaxPoints, 0.01, 1);
            this.progressMaskRectangle.scale.x = maskScale;
            this.add(this.progressMaskRectangle);
            this.progressBar.mask = this.progressMaskRectangle;
            let progressText = currentPoints.toString() + this.cardMaxPointsLabel;
            this.progressLabel = new Phaser.Text(this.game, this.progressBar.x, this.progressBar.y + 3, progressText, {
                font: "20px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#E5FFFF",
                align: "center"
            });
            this.progressLabel.anchor.set(.5);
            this.add(this.progressLabel);
            this.boxContainerImage.bringToTop();
            this.equipButton = new Phaser.Button(this.game, this.progressBar.x, this.progressBar.y + 1, "texture_atlas_1");
            this.equipButton.anchor.set(.5);
            if (this.game.device.touch) {
                this.equipButton.onInputDown.add(function() {
                    this.equipButton.scale.set(this.equipButton.scale.x * 1.05, this.equipButton.scale.y * 1.05);
                }, this, 5);
            }
            this.equipButton.onInputOver.add(function() {
                this.equipButton.scale.set(this.equipButton.scale.x * 1.05, this.equipButton.scale.y * 1.05);
            }, this, 5);
            this.equipButton.onInputOut.add(function() {
                this.equipButton.scale.set(1, 1);
            }, this, 5);
            this.equipButton.events.onInputUp.add(this.onClickEquip, this, 5);
            this.equipButton.setFrames("btn_equip_pressed.png", "btn_equip.png", "btn_equip_pressed.png", "btn_equip.png");
            this.add(this.equipButton);
            this.equippedImage = new Phaser.Image(this.game, this.progressBar.x, this.progressBar.y + 1, "texture_atlas_1", "equipped.png");
            this.equippedImage.anchor.set(.5);
            this.add(this.equippedImage);
            this.equipButton.bringToTop();
            if (currentPoints === this.cardMaxPoints) {
                this.unlocked = true;
                if (MiniBillar.GameVars.gameData.playerData.equipedCue === this.cardId || MiniBillar.GameVars.gameData.equippedTable === this.cardId) {
                    this.equippedImage.visible = true;
                    this.equipButton.visible = false;
                } else {
                    this.equippedImage.visible = false;
                    this.progressLabel.visible = false;
                }
            } else {
                this.unlocked = false;
                this.equippedImage.visible = false;
                this.equipButton.visible = false;
            }
        }
        update() {
            if (this.pointsToIncrement > 0) {
                if (this.incrementPointsCounter < 0) {
                    this.incrementPointsCounter = this.incrementPointsDt;
                    this.pointsToIncrement--;
                    if (this.points >= this.cardMaxPoints) {
                        this.pointsToIncrement = 0;
                        this.points = this.cardMaxPoints;
                        this.progressLabel.text = "UNLOCKED!";
                    } else {
                        this.progressLabel.text = (this.points - this.pointsToIncrement).toString() + this.cardMaxPointsLabel;
                    }
                } else {
                    this.incrementPointsCounter -= this.game.time.physicsElapsedMS;
                }
            }
        }
        onClickEquip() {
            this.equipButton.scale.set(1, 1);
            this.equipButton.visible = false;
            this.equippedImage.visible = true;
            if (!this.parentRail) {
                return;
            }
            let oldSelected;
            if (this.cardType === "cue") {
                oldSelected = MiniBillar.GameVars.gameData.playerData.equipedCue;
            } else {
                oldSelected = MiniBillar.GameVars.gameData.equippedTable;
            }
            if (this.cardId === oldSelected || !this.unlocked) {
                return;
            } else {
                let unequipSuccessful = false;
                for (let card of this.parentRail.cardArray) {
                    if (card.cardId === oldSelected) {
                        unequipSuccessful = true;
                        card.unequip();
                        break;
                    }
                }
                if (unequipSuccessful) {
                    MiniBillar.GameManager.onItemEquiChange(this.cardType, this.cardId);
                }
            }
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
        unequip() {
            this.equipButton.visible = true;
            this.equippedImage.visible = false;
            this.progressLabel.visible = false;
        }
        animateToNewestCardPoint(incrementValue) {
            let oldProgValue = Phaser.Math.clamp((this.points - incrementValue) / this.cardMaxPoints, .01, 1);
            this.progressMaskRectangle.scale.x = oldProgValue;
            let currentProgValue = Phaser.Math.clamp(this.points / this.cardMaxPoints, .01, 1);
            this.progressLabel.text = (Math.max(0, this.points - incrementValue)).toString() + this.cardMaxPointsLabel;
            const tweenDelay = 1000;
            const tweenDuration = 1500;
            this.game.add.tween(this.progressMaskRectangle.scale)
                .to({
                    x: currentProgValue
                }, tweenDuration, Phaser.Easing.Cubic.Out, true, tweenDelay)
                .onStart.add(function() {
                    this.pointsToIncrement = incrementValue;
                    this.incrementPointsDt = tweenDuration / incrementValue * 0.8;
                    this.incrementPointsCounter = this.incrementPointsDt;
                }, this);
        }
        setParentRail(parentRail) {
            this.parentRail = parentRail;
        }
    }
    MiniBillar.RewardCard = RewardCard;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class RewardCardContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "cards-displayer");
            this.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
        }
        createAndDisplayCards(cardIds) {
            this.rewardCards = [];
            for (let i = 0; i < cardIds.length; i++) {
                let rc = new MiniBillar.RewardCard(this.game, 0, 0, cardIds[i]);
                this.rewardCards.push(rc);
                this.add(this.rewardCards[i]);
                rc.scale.x = 0.00001;
                rc.alpha = 0;
                this.game.add.tween(rc.scale)
                    .to({
                        x: 1
                    }, 600, Phaser.Easing.Bounce.Out, true, i * 250)
                    .onStart.add(function() {
                        MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.GIFT_CARD_SWISH);
                    }, this);
                this.game.add.tween(rc)
                    .to({
                        alpha: 1
                    }, 600, Phaser.Easing.Cubic.Out, true, i * 250);
            }
            let cardXPos = -256;
            const intervalX = 256;
            if (this.rewardCards.length === 2) {
                cardXPos = -128;
            } else if (this.rewardCards.length === 1) {
                cardXPos = 0;
            }
            for (let i = 0; i < this.rewardCards.length; i++) {
                this.rewardCards[i].x = cardXPos;
                cardXPos += intervalX;
            }
        }
        animateCardPointsIncrementation(incrementValues) {
            for (let i = 0; i < this.rewardCards.length; i++) {
                const card = this.rewardCards[i];
                card.animateToNewestCardPoint(incrementValues[i]);
            }
        }
    }
    MiniBillar.RewardCardContainer = RewardCardContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PreloadBar extends Phaser.Group {
        constructor(game) {
            super(game, null, "preloadbar");
            this.x = MiniBillar.GameVars.gameWidth / 2;
            this.y = 395;
            this.f = 0;
            this.scale.x = MiniBillar.GameVars.scaleXMult;
            this.scale.y = MiniBillar.GameVars.scaleYMult;
            this.preloadCue = new Phaser.Image(this.game, -PreloadBar.RECT_WIDTH / 2, 0, "preload_cue");
            this.preloadCue.anchor.set(1, .5);
            this.add(this.preloadCue);
            this.preloadCueBall = new Phaser.Image(this.game, PreloadBar.RECT_WIDTH / 2 + 22, 0, "preload_cue_ball");
            this.preloadCueBall.anchor.set(.5);
            this.add(this.preloadCueBall);
            const graphics = new Phaser.Graphics(this.game);
            graphics.lineStyle(2, 0xFFFFFF);
            graphics.drawRoundedRect(-PreloadBar.RECT_WIDTH / 2, -PreloadBar.RECT_HEIGTH / 2, PreloadBar.RECT_WIDTH, PreloadBar.RECT_HEIGTH, 10);
            this.add(graphics);
            this.percentageLabel = new Phaser.Text(this.game, 0, 52, "0%", {
                font: "34px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#FFFFFF"
            });
            this.percentageLabel.anchor.set(.5);
            this.percentageLabel.visible = false;
            this.add(this.percentageLabel);
        }
        update() {
            super.update();
            this.f++;
            if (this.f === 10) {
                this.percentageLabel.visible = true;
            }
        }
        updateLoadedPercentage(loadProgress) {
            this.percentageLabel.text = loadProgress + "%";
            this.preloadCue.x = -PreloadBar.RECT_WIDTH / 2 + loadProgress / 100 * (PreloadBar.RECT_WIDTH + 6);
            if (loadProgress === 100) {
                this.game.add.tween(this.preloadCue)
                    .to({
                        x: this.preloadCue.x - 36
                    }, 300, Phaser.Easing.Cubic.Out, true)
                    .onComplete.add(function() {
                        this.game.add.tween(this.preloadCue)
                            .to({
                                x: this.preloadCue.x + 40
                            }, 100, Phaser.Easing.Cubic.Out, true)
                            .onComplete.add(function() {
                                this.game.add.tween(this.preloadCueBall)
                                    .to({
                                        x: (MiniBillar.GameVars.gameWidth / 2 + 50) * MiniBillar.GameVars.scaleXMultInverse
                                    }, 250, Phaser.Easing.Cubic.Out, true)
                                    .onComplete.add(function() {
                                        MiniBillar.PreLoader.currentInstance.cueBallDisappeared();
                                    }, this);
                            }, this);
                    }, this);
            }
        }
    }
    PreloadBar.RECT_WIDTH = 290;
    PreloadBar.RECT_HEIGTH = 30;
    MiniBillar.PreloadBar = PreloadBar;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PreLoader extends Phaser.State {
        init() {
            PreLoader.currentInstance = this;
        }
        preload() {
            Phaser.Canvas.setBackgroundColor(this.game.canvas, "#000000");
            this.generateBitmapData();
            this.composeScene();
            this.loadAssets();
        }
        create() {}
        cueBallDisappeared() {
            this.game.time.events.add(MiniBillar.GameConstants.DEVELOPMENT ? 50 : 350, function() {
                MiniBillar.GameManager.onGameAssetsLoaded();
            }, this);
        }
        shutdown() {
            PreLoader.currentInstance = this;
            super.shutdown();
        }
        updateLoadedPercentage() {
            this.preloadBar.updateLoadedPercentage(this.load.progress);
        }
        generateBitmapData() {
            let bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BLACK_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#000000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BLACK_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#000000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.WHITE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FFFFFF";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.RED_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FF0000";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.ORANGE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FF9900";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.YELLOW_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#FFFF00";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.GREEN_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#00FF00";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BLUE_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#0f1726";
            bmd.ctx.fill();
            bmd = this.game.add.bitmapData(MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.GREY_SQUARE, true);
            bmd.ctx.beginPath();
            bmd.ctx.rect(0, 0, MiniBillar.GameConstants.BITMAP_SIZE, MiniBillar.GameConstants.BITMAP_SIZE);
            bmd.ctx.fillStyle = "#2F3237";
            bmd.ctx.fill();
        }
        composeScene() {
            this.add.text(MiniBillar.GameVars.gameWidth * .5, MiniBillar.GameVars.gameHeight * .5, "ABCDEFG", {
                font: "30px Oswald-DemiBold",
                fontWeight: "400",
                fill: "#542200",
                align: "center"
            });
            this.add.text(MiniBillar.GameVars.gameWidth * .5, MiniBillar.GameVars.gameHeight * .5, "ABCDEFG", {
                font: "30px Oswald-Medium",
                fontWeight: "400",
                fill: "#542200",
                align: "center"
            });
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "preload_background");
            background.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            background.anchor.set(.5);
            this.preloadBar = new MiniBillar.PreloadBar(this.game);
            this.add.existing(this.preloadBar);
        }
        loadAssets() {
            if (MiniBillar.GameConstants.DEVELOPMENT) {
                this.load.atlasJSONArray("texture_atlas_0", "/texture_atlas_0.png", "/texture_atlas_0.json");
            }
            this.load.atlasJSONArray("texture_atlas_1", "/texture_atlas_1.png", "/texture_atlas_1.json");
            this.load.atlasJSONArray("texture_atlas_3", "/texture_atlas_3.png", "/texture_atlas_3.json");
            this.load.atlasJSONArray("texture_atlas_2", "/texture_atlas_2.jpg", "/texture_atlas_2.json");
            this.load.atlasJSONArray("texture_atlas_4", "/texture_atlas_4.png", "/texture_atlas_4.json");
            this.load.atlasJSONArray("texture_atlas_5", "/texture_atlas_5.png", "/texture_atlas_5.json");
            this.load.image("more-games", "/neon_pool_io.png");
            this.load.audiosprite("audio-sprite", ["/audio/audiosprite.mp3", "/audio/audiosprite.ogg"], "/audio/audiosprite.json");
            this.load.json("card-data", "/config/card_data.json");
            this.load.onFileComplete.add(this.updateLoadedPercentage, this);
        }
    }
    MiniBillar.PreLoader = PreLoader;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class PlayerAvatarContainer extends Phaser.Group {
        constructor(game) {
            super(game, null, "player-avatar-container");
            this.scale.x = MiniBillar.GameVars.scaleXMult;
            const background = new Phaser.Image(this.game, -48, -53, "texture_atlas_1", "avatar_container_background.png");
            this.add(background);
            const avatar = new Phaser.Image(this.game, 0, 0, "texture_atlas_5", MiniBillar.GameVars.gameData.playerData.avatar + ".png");
            avatar.inputEnabled = true;
            avatar.events.onInputUp.add(this.onClickAvatarEdit, this);
            avatar.anchor.set(.5, .325);
            avatar.scale.set(.45);
            this.add(avatar);
            const mask = new Phaser.Graphics(this.game);
            mask.beginFill(0xffffff);
            mask.drawCircle(0, 0, 83);
            this.add(mask);
            avatar.mask = mask;
            let shownNick = MiniBillar.GameVars.gameData.playerData.nick;
            shownNick = MiniBillar.Utils.truncateName(shownNick);
            const nickLabel = new Phaser.Text(this.game, 55, -22, shownNick, {
                font: "22px Oswald-DemiBold",
                fill: "#E5FFFF"
            });
            this.add(nickLabel);
            const currentCue = new Phaser.Image(this.game, 210, 32, "texture_atlas_5", MiniBillar.GameVars.gameData.playerData.equipedCue + "_sprite_0.png");
            currentCue.anchor.y = .5;
            currentCue.angle = 180;
            currentCue.scale.set(.46);
            this.add(currentCue);
            const nameEditButton = new Phaser.Button(this.game, 201, -10.5, "texture_atlas_1");
            nameEditButton.setFrames("btn_edit_avatar_on.png", "btn_edit_avatar_off.png", "btn_edit_avatar_on.png", "btn_edit_avatar_off.png");
            nameEditButton.anchor.set(.5);
            if (this.game.device.touch) {
                nameEditButton.onInputDown.add(function() {
                    nameEditButton.scale.set(nameEditButton.scale.x * 1.1, nameEditButton.scale.y * 1.1);
                }, this);
            }
            nameEditButton.onInputOver.add(function() {
                nameEditButton.scale.set(nameEditButton.scale.x * 1.1, nameEditButton.scale.y * 1.1);
            }, this);
            nameEditButton.onInputOut.add(function() {
                nameEditButton.scale.set(1);
            }, this);
            nameEditButton.events.onInputUp.add(function() {
                MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
                nameEditButton.scale.set(1);
                MiniBillar.GameManager.enterPortraitSelectionScreen();
            }, this);
            this.add(nameEditButton);
        }
        onClickAvatarEdit() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.enterPortraitSelectionScreen();
        }
    }
    MiniBillar.PlayerAvatarContainer = PlayerAvatarContainer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class SettingsLayer extends Phaser.Group {
        constructor(game) {
            super(game, null, "settings-layer");
            SettingsLayer.currentInstance = this;
            const transparentBackground = new Phaser.Sprite(this.game, 0, 0, this.game.cache.getBitmapData(MiniBillar.GameConstants.BLUE_SQUARE));
            transparentBackground.scale.set(MiniBillar.GameVars.gameWidth / 64, MiniBillar.GameVars.gameHeight / 64);
            transparentBackground.alpha = .96;
            transparentBackground.inputEnabled = true;
            transparentBackground.events.onInputDown.add(this.onDownTransparentLayer, this);
            this.add(transparentBackground);
            const buttonBack = new Phaser.Button(this.game, 38 * MiniBillar.GameVars.scaleXMult, 38 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickExit, this);
            buttonBack.setFrames("btn_back_on.png", "btn_back_off.png", "btn_back_on.png");
            buttonBack.anchor.set(.5);
            buttonBack.forceOut = true;
            if (this.game.device.touch) {
                buttonBack.onInputDown.add(function() {
                    buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
                }, this);
            }
            buttonBack.onInputOver.add(function() {
                buttonBack.scale.set(buttonBack.scale.x * 1.1, buttonBack.scale.y * 1.1);
            }, this);
            buttonBack.onInputOut.add(function() {
                buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonBack.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(buttonBack);
            const titleLabel = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth / 2, 40, "SETTINGS", {
                font: "56px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8"
            });
            titleLabel.anchor.x = .5;
            titleLabel.stroke = "#2f3237";
            titleLabel.strokeThickness = 5;
            titleLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(titleLabel);
            const scaledItemsContainer = new Phaser.Group(this.game);
            scaledItemsContainer.x = MiniBillar.GameVars.gameWidth / 2;
            scaledItemsContainer.y = MiniBillar.GameVars.gameHeight / 2;
            scaledItemsContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(scaledItemsContainer);
            const audioSwitchButton = new MiniBillar.SwitchButton(this.game, !MiniBillar.GameVars.gameData.musicMuted, MiniBillar.SwitchButton.MUSIC);
            audioSwitchButton.x = 30;
            audioSwitchButton.y = -100;
            scaledItemsContainer.add(audioSwitchButton);
            const audioLabel = new Phaser.Text(this.game, -24, audioSwitchButton.y + 2, "AUDIO", {
                font: "24px Oswald-DemiBold",
                fontWeight: "600",
                fill: "#e7f6f8",
                align: "center",
                stroke: "#2f3237",
                strokeThickness: 3
            });
            audioLabel.anchor.set(1, .5);
            scaledItemsContainer.add(audioLabel);
            if (this.game.device.touch) {
                const switchStartingState = MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.RIGHT;
                const powerSwitchButton = new MiniBillar.SwitchButton(this.game, switchStartingState, MiniBillar.SwitchButton.POWER);
                powerSwitchButton.x = 30;
                powerSwitchButton.y = -160;
                scaledItemsContainer.add(powerSwitchButton);
                const powerTextLeft = "POWER BAR: LEFT";
                const powerTextRight = "POWER BAR: RIGHT";
                this.powerLabel = new Phaser.Text(this.game, -24, powerSwitchButton.y + 2, powerTextLeft, {
                    font: "24px Oswald-DemiBold",
                    fontWeight: "600",
                    fill: "#e7f6f8",
                    align: "center",
                    stroke: "#2f3237",
                    strokeThickness: 3
                });
                this.powerLabel.anchor.set(1, .5);
                scaledItemsContainer.add(this.powerLabel);
                if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.RIGHT) {
                    this.powerLabel.text = powerTextRight;
                }
                if (MiniBillar.GameVars.gameMode !== MiniBillar.GameConstants.SOLO_MODE) {
                    scaledItemsContainer.y += 100;
                }
            }
            if (MiniBillar.GameConstants.DEVELOPMENT) {
                const buttonBot = new Phaser.Button(this.game, 10 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight - 10 * MiniBillar.GameVars.scaleYMult, "texture_atlas_0", this.onClickBot, this);
                buttonBot.anchor.set(0, 1);
                buttonBot.setFrames("btn_bot_pressed.png", "btn_bot.png", "btn_bot_pressed.png", "btn_bot.png");
                buttonBot.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                this.add(buttonBot);
            }
            const copyrightLabel = new Phaser.Text(this.game, MiniBillar.GameVars.gameWidth * 0.5, MiniBillar.GameVars.gameHeight - 46, "developed by RavalMatic", {
                font: "28px Oswald-DemiBold",
                fill: "#E5FFFF"
            });
            copyrightLabel.anchor.x = .5;
            copyrightLabel.alpha = .75;
            copyrightLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(copyrightLabel);
            const versionLabel = new Phaser.Text(this.game, 30, MiniBillar.GameVars.gameHeight - 26, "v" + MiniBillar.GameConstants.VERSION, {
                font: "16px Arial",
                fill: "#E5FFFF"
            });
            versionLabel.anchor.x = .5;
            versionLabel.alpha = .75;
            versionLabel.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add(versionLabel);
            this.alpha = 0;
            this.game.add.tween(this)
                .to({
                    alpha: 1
                }, 400, Phaser.Easing.Cubic.Out, true);
        }
        changePower() {
            const powerTextLeft = "POWER BAR: LEFT";
            const powerTextRight = "POWER BAR: RIGHT";
            if (MiniBillar.GameVars.gameData.powerBarSide === MiniBillar.GameConstants.LEFT) {
                this.powerLabel.text = powerTextLeft;
            } else {
                this.powerLabel.text = powerTextRight;
            }
        }
        destroy() {
            MiniBillar.PauseLayer.currentInstance = null;
            super.destroy();
        }
        onClickExit(b) {
            b.clearFrames();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.SplashState.currentInstance.hideSettingsLayer();
        }
        onClickBot(b) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            b.clearFrames();
            MiniBillar.GameManager.setupBotMatchData();
            MiniBillar.GameManager.enterPVBotGame();
        }
        onDownTransparentLayer() {}
    }
    MiniBillar.SettingsLayer = SettingsLayer;
})(MiniBillar || (MiniBillar = {}));
var MiniBillar;
(function(MiniBillar) {
    class SplashState extends Phaser.State {
        init() {
            SplashState.currentInstance = this;
            this.portraitButton = null;
            this.nameLabel = null;
            this.settingsLayer = null;
        }
        create() {
            const background = this.add.image(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2, "texture_atlas_2", "splash.png");
            background.anchor.set(.5);
            background.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight / background.height);
            this.scaledItemsContainer = this.add.group();
            this.scaledItemsContainer.position.set(MiniBillar.GameVars.gameWidth / 2, MiniBillar.GameVars.gameHeight / 2);
            this.scaledItemsContainer.scale.x = MiniBillar.GameVars.scaleXMult;
            this.scaledItemsContainer.scale.y = MiniBillar.GameVars.scaleYMult;
            this.gameLogo = new Phaser.Image(this.game, MiniBillar.GameVars.gameWidth / 2, 135, "texture_atlas_1", "game_logo.png");
            this.gameLogo.anchor.set(.5);
            this.gameLogo.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.add.existing(this.gameLogo);
            this.gameLogoShine = new Phaser.Sprite(this.game, this.gameLogo.x - 11, this.gameLogo.y - 18, "texture_atlas_1");
            this.gameLogoShine.visible = false;
            const gameLogoShineFrames = MiniBillar.Utils.createAnimFramesArr("game_logo_shine", 19);
            this.gameLogoShine.animations.add("shine", gameLogoShineFrames, 24);
            this.gameLogoShine.frameName = gameLogoShineFrames[0];
            this.gameLogoShine.anchor.set(.5);
            this.gameLogoShine.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.gameLogoShineCounter = this.game.rnd.integerInRange(4, 8);
            this.add.existing(this.gameLogoShine);
            this.playerAvatarContainer = new MiniBillar.PlayerAvatarContainer(this.game);
            this.playerAvatarContainer.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.playerAvatarContainer.x = 55;
            this.playerAvatarContainer.y = 55;
            this.add.existing(this.playerAvatarContainer);
            if (!MiniBillar.GameVars.gameData.statistics.rewards.allUnlocked) {
                const animStarBox = new MiniBillar.AnimatedStarBox(this.game, true);
                animStarBox.x = 120 * MiniBillar.GameVars.scaleXMult;
                animStarBox.y = MiniBillar.GameVars.gameHeight - 35 * MiniBillar.GameVars.scaleYMult;
                for (let i = 0; i < MiniBillar.RewardsManager.getCurrentStarProgress(); i++) {
                    animStarBox.setStarActive(i);
                }
                this.add.existing(animStarBox);
            }
            this.settingsButton = this.add.button(MiniBillar.GameVars.gameWidth - 45 * MiniBillar.GameVars.scaleXMult, 45, "texture_atlas_1", this.showSettingsLayer, this);
            this.settingsButton.setFrames("btn_settings_on.png", "btn_settings_off.png", "btn_settings_on.png", "btn_settings_off.png");
            this.settingsButton.anchor.set(.5);
            if (this.game.device.touch) {
                this.settingsButton.onInputDown.add(function() {
                    this.settingsButton.scale.set(this.settingsButton.scale.x * 1.1, this.settingsButton.scale.y * 1.1);
                }, this);
            }
            this.settingsButton.onInputOver.add(function() {
                this.settingsButton.scale.set(this.settingsButton.scale.x * 1.1, this.settingsButton.scale.y * 1.1);
            }, this);
            this.settingsButton.onInputOut.add(function() {
                this.settingsButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            this.settingsButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            if (!this.game.device.cordova && gameConfig.GameVersion !== "yandex") {
                const googlePlayButton = this.add.button(MiniBillar.GameVars.gameWidth - 45 * MiniBillar.GameVars.scaleXMult, 116, "texture_atlas_1", this.onStoreButtonClicked, this);
                googlePlayButton.setFrames("btn_google_on.png", "btn_google_off.png", "btn_google_on.png", "btn_google_off.png");
                googlePlayButton.anchor.set(.5);
                googlePlayButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                googlePlayButton.name = MiniBillar.GameConstants.ANDROID;
                const appStoreButton = this.add.button(MiniBillar.GameVars.gameWidth - 45 * MiniBillar.GameVars.scaleXMult, 192, "texture_atlas_1", this.onStoreButtonClicked, this);
                appStoreButton.setFrames("btn_apple_on.png", "btn_apple_off.png", "btn_apple_on.png", "btn_apple_off.png");
                appStoreButton.anchor.set(.5);
                appStoreButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
                appStoreButton.name = MiniBillar.GameConstants.APPLE;
            }
            this.moreGames = new Phaser.Image(this.game, 52, -30, "more-games");
            this.moreGames.anchor.set(.5);
            this.moreGames.inputEnabled = true;
            this.moreGames.events.onInputOver.add(function() {
                this.moreGames.scale.set(1.05);
            }, this);
            this.moreGames.events.onInputOut.add(function() {
                this.moreGames.scale.set(1);
            }, this);
            this.moreGames.events.onInputDown.add(function() {
                let targetUrl = "https://mnj.gs/more-pool";
                if (typeof gameConfig.GameVersion !== "undefined" && gameConfig.GameVersion === "yandex") {
                    targetUrl = "https://yandex.ru/games/";
                }
                const win = window.open(targetUrl);
                win.focus();
            }, this);
            this.scaledItemsContainer.add(this.moreGames);
            const pvpButton = new Phaser.Button(this.game, -175, 235 * MiniBillar.GameVars.scaleYMultInverse, "texture_atlas_1", this.onClickPVP, this);
            pvpButton.setFrames("btn_pvp_on.png", "btn_pvp_off.png", "btn_pvp_on.png");
            if (this.game.device.touch) {
                pvpButton.onInputDown.add(function() {
                    pvpButton.scale.set(pvpButton.scale.x * 1.1, pvpButton.scale.y * 1.1);
                }, this);
            }
            pvpButton.onInputOver.add(function() {
                pvpButton.scale.set(pvpButton.scale.x * 1.1, pvpButton.scale.y * 1.1);
            }, this);
            pvpButton.onInputOut.add(function() {
                pvpButton.scale.set(1);
            }, this);
            pvpButton.anchor.set(.5);
            this.scaledItemsContainer.add(pvpButton);
            const soloButton = new Phaser.Button(this.game, 175, 235 * MiniBillar.GameVars.scaleYMultInverse, "texture_atlas_1", this.onClickSolo);
            soloButton.setFrames("btn_solo_on.png", "btn_solo_off.png", "btn_solo_on.png");
            if (this.game.device.touch) {
                soloButton.onInputDown.add(function() {
                    soloButton.scale.set(soloButton.scale.x * 1.1, soloButton.scale.y * 1.1);
                }, this);
            }
            soloButton.onInputOver.add(function() {
                soloButton.scale.set(soloButton.scale.x * 1.1, soloButton.scale.y * 1.1);
            }, this);
            soloButton.onInputOut.add(function() {
                soloButton.scale.set(1);
            }, this);
            soloButton.anchor.set(.5);
            this.scaledItemsContainer.add(soloButton);
            const buttonEquipment = this.add.button(MiniBillar.GameVars.gameWidth - 61 * MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.gameHeight - 74 * MiniBillar.GameVars.scaleYMult, "texture_atlas_1", this.onClickEquipment, this);
            buttonEquipment.setFrames("btn_equipment_on.png", "btn_equipment_off.png", "btn_equipment_on.png", "btn_equipment_off.png");
            if (this.game.device.touch) {
                buttonEquipment.onInputDown.add(function() {
                    buttonEquipment.scale.set(buttonEquipment.scale.x * 1.1, buttonEquipment.scale.y * 1.1);
                }, this);
            }
            buttonEquipment.onInputOver.add(function() {
                buttonEquipment.scale.set(buttonEquipment.scale.x * 1.1, buttonEquipment.scale.y * 1.1);
            }, this);
            buttonEquipment.onInputOut.add(function() {
                buttonEquipment.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            }, this);
            buttonEquipment.anchor.set(0.5);
            buttonEquipment.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            MiniBillar.AudioManager.playMusic(MiniBillar.AudioManager.MUSIC_MINIBILLARD, true);
            this.game.camera.flash(0x000000, 350, false);
        }
        shutdown() {
            SplashState.currentInstance = null;
            super.shutdown();
        }
        update() {
            if (MiniBillar.GameVars.goDirectlyToLobby) {
                MiniBillar.GameVars.goDirectlyToLobby = false;
                MiniBillar.GameManager.enterPVPGame();
            }
            if (this.gameLogoShineCounter < 0) {
                this.gameLogoShine.visible = true;
                this.gameLogoShine.play("shine");
                this.game.add.tween(this.gameLogoShine.scale).to({
                    x: this.gameLogoShine.scale.x * 1.05,
                    y: this.gameLogoShine.scale.y * 1.05
                }, 250, Phaser.Easing.Cubic.Out, true, 150, 0, true);
                this.game.add.tween(this.gameLogo.scale).to({
                    x: this.gameLogo.scale.x * 1.05,
                    y: this.gameLogo.scale.y * 1.05
                }, 250, Phaser.Easing.Cubic.Out, true, 150, 0, true);
                this.gameLogoShineCounter = this.game.rnd.integerInRange(4, 8);
            } else {
                this.gameLogoShineCounter -= this.game.time.physicsElapsed;
            }
        }
        refreshPortraitAndName(doWriteGameData) {
            this.portraitButton.setFrames(MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameData.playerData.avatar, MiniBillar.GameVars.gameData.playerData.avatar);
            this.nameLabel.text = MiniBillar.GameVars.gameData.playerData.nick;
            if (doWriteGameData) {
                MiniBillar.GameManager.writeGameData();
            }
        }
        hideSettingsLayer() {
            this.settingsLayer.destroy();
        }
        showSettingsLayer() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            this.settingsButton.scale.set(MiniBillar.GameVars.scaleXMult, MiniBillar.GameVars.scaleYMult);
            this.settingsLayer = new MiniBillar.SettingsLayer(this.game);
            this.add.existing(this.settingsLayer);
        }
        onClickSolo() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.enterSoloGame(true);
        }
        onClickPVP() {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.enterPVPGame();
        }
        onClickEquipment(b) {
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
            MiniBillar.GameManager.enterEquipment();
        }
        onStoreButtonClicked(b) {
            let win;
            if (b.name === MiniBillar.GameConstants.APPLE) {
                win = window.open("https://mnj.gs/minipool-ios");
            } else {
                win = window.open("https://mnj.gs/minipool-android");
            }
            win.focus();
            MiniBillar.AudioManager.playEffect(MiniBillar.AudioManager.BTN_NORMAL);
        }
    }
    MiniBillar.SplashState = SplashState;
})(MiniBillar || (MiniBillar = {}));
var PhaserCachebuster;
(function(PhaserCachebuster) {
    class CacheBuster extends Phaser.Plugin {
        constructor(game, parent) {
            super(game, parent);
            this.patchLoader();
        }
        patchLoader() {
            Object.defineProperty(Phaser.Loader, "cacheBuster", {
                value: null
            });
            Phaser.Loader.prototype.transformUrl = function(url, file) {
                if (!url) {
                    return "";
                }
                if (this.cacheBuster !== null && null === url.match(/^(data:)/)) {
                    url += "?v=" + this.cacheBuster;
                }
                if (url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/)) {
                    return url;
                } else {
                    return this.baseURL + file.path + url;
                }
            };
        }
    }
    PhaserCachebuster.CacheBuster = CacheBuster;
})(PhaserCachebuster || (PhaserCachebuster = {}));
var MiniBillar;
(function(MiniBillar) {
    class Utils {
        static colourRulesText(rulesText) {
            const rulesColorOffset = Utils.getNumberOfDigitsInNumber(MiniBillar.GameConstants.MIN_PTS_TO_GET_REWARD);
            Utils.colourText(rulesText, 115, rulesColorOffset + 50, "#fff562", "#1D2836");
        }
        static getRandomUsernameList() {
            return [
                "AllyCookie",
                "Branstoqu",
                "Bur_gizer",
                "Chatomadli",
                "ChoneKnotLou",
                "Conceme41",
                "CoooooopsFree",
                "Darklessra",
                "Garioney",
                "GrabsDrummer",
                "IamaBloom",
                "1k1nt1cs",
                "Issueinters",
                "Knottownce",
                "LightN_inja",
                "Multing",
                "Ravag3rma",
                "RockerPersonal",
                "Slip_korks",
                "Sportswaba",
                "Stori3sDas",
                "TagzBall",
                "0Th3reCoverag3",
                "UnowPlus",
                "Fistro",
                "CountOfMor",
                "Mistery2005",
                "KineticForce",
                "M. Rajoy",
                "ChumbaWumba",
                "PlayerTotal",
                "Barcelono",
                "BrainDamage",
                "LobotomyHero",
                "MiniRock",
                "LettuceJuice",
                "Camaleon",
                "Bloom",
                "buTTer",
                "tenderGlobe",
                "ColdFeet",
                "LovelLove",
                "StronGGGG",
                "PoopSY",
                "kidd_2005",
                "thunderblade",
                "Priapus",
                "koksy"
            ];
        }
        static getRandomAvatarImageList() {
            return [
                "billar_m01",
                "billar_m02",
                "billar_m03",
                "billar_m04",
                "billar_m05",
                "billar_m06",
                "billar_m07",
                "billar_m08",
                "billar_w01",
                "billar_w02",
                "billar_w03",
                "billar_w04",
                "billar_w05",
                "billar_w06",
                "billar_w07",
                "billar_w08"
            ];
        }
        static colourText(rulesText, startIndex, charCount, textColour, strokeColour) {
            const oldFill = rulesText.fill;
            const oldStroke = rulesText.stroke;
            rulesText.addColor(textColour, startIndex);
            rulesText.addColor(oldFill, startIndex + charCount);
            if (strokeColour) {
                rulesText.addStrokeColor(strokeColour, startIndex);
                rulesText.addStrokeColor(oldStroke, startIndex + charCount);
            }
        }
        static truncateName(name, limit = 10) {
            if (name.length > limit) {
                name = name.substr(0, limit);
                name += "...";
            }
            return name;
        }
        static validNumber(x) {
            return x.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        static getNumberOfDigitsInNumber(num) {
            if (num < 0) {
                throw "Invalid. Number must be larger than 0";
            }
            let digits = 1;
            let m = 10;
            while (m <= num) {
                digits++;
                m *= 10;
            }
            return digits;
        }
        static timeToString(time) {
            let minutes = Math.floor(time / 60);
            let seconds = time - (minutes * 60);
            if (minutes < 10) {
                minutes = "0" + minutes;
            }
            if (seconds < 10) {
                seconds = "0" + seconds;
            }
            return minutes + ":" + seconds;
        }
        static shuffle(array, prng) {
            let currentIndex = array.length,
                temporaryValue, randomIndex;
            while (0 !== currentIndex) {
                randomIndex = Math.floor(prng.frac() * currentIndex);
                currentIndex -= 1;
                temporaryValue = array[currentIndex];
                array[currentIndex] = array[randomIndex];
                array[randomIndex] = temporaryValue;
            }
            return array;
        }
        static centerPoint(array) {
            let x = 0;
            let y = 0;
            for (let i = 0; i < array.length; i++) {
                x += array[i].x;
                y += array[i].y;
            }
            return {
                x: x / array.length,
                y: y / array.length
            };
        }
        static parseString(json) {
            json = json.replace(/id:/g, '"id":');
            json = json.replace(/active/g, '"active"');
            json = json.replace(/x:/g, '"x":');
            json = json.replace(/y:/g, '"y":');
            json = json.replace(/ballsData/g, '"ballsData"');
            json = json.replace(/english/g, '"english"');
            json = json.replace(/deltaScrewX/g, '"deltaScrewX"');
            json = json.replace(/deltaScrewY/g, '"deltaScrewY"');
            json = json.replace(/playerId/g, '"playerId"');
            return JSON.parse(json);
        }
        static stringify(object) {
            let str = JSON.stringify(object);
            return str.replace(/\"([^(\")"]+)\":/g, "$1:");
        }
        static createAnimFramesArr(filename, framesCount, reverse = false, timesToRepeatFinalFrame = 0, blankBufferBeforeAnim = 0) {
            let frames = [];
            for (let i = 0; i < framesCount; i++) {
                if (i === 0 && blankBufferBeforeAnim > 0) {
                    for (let j = 0; j < blankBufferBeforeAnim; j++) {
                        frames.push("blank.png");
                    }
                }
                frames.push(filename + "_" + (reverse ? (framesCount - 1 - i) : i).toString() + ".png");
                if (i === framesCount - 1 && timesToRepeatFinalFrame > 0) {
                    for (let j = 0; j < timesToRepeatFinalFrame; j++) {
                        frames.push(filename + "_" + (reverse ? (framesCount - 1 - i) : i).toString() + ".png");
                    }
                }
            }
            return frames;
        }
        static hash(str) {
            let hash = 5381;
            let i = str.length;
            while (i) {
                hash = (hash * 33) ^ str.charCodeAt(--i);
            }
            return hash >>> 0;
        }
    }
    MiniBillar.Utils = Utils;
})(MiniBillar || (MiniBillar = {}));
//# sourceMappingURL=mini-billar.min.js.map