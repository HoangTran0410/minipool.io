var Billiard;
! function(P) {
    var t = function() {
        function B() {}
        return B.log = function(t) {
            B.VERBOSE && console.log(t)
        }, B.init = function(t, e, i, n, l, o, a, r, s, u, c) {
            B.angleSteps = 7 < (B.skillFactor = c || 10) ? 30 : 4 < B.skillFactor ? 20 : 15;
            for (var p = JSON.parse(r), y = [], d = 0; d < p.length; d++) y.push({
                name: p[d].name,
                direction: new P.Vector2D(p[d].direction.x, p[d].direction.y),
                normal: new P.Vector2D(p[d].normal.x, p[d].normal.y),
                p1: new P.Vector2D(p[d].p1.x, p[d].p1.y),
                p2: new P.Vector2D(p[d].p2.x, p[d].p2.y),
                p3: new P.Vector2D(p[d].p3.x, p[d].p3.y),
                p4: new P.Vector2D(p[d].p4.x, p[d].p4.y),
                p5: new P.Vector2D(p[d].p5.x, p[d].p5.y),
                p6: new P.Vector2D(p[d].p6.x, p[d].p6.y)
            });
            var h = JSON.parse(s),
                g = [];
            for (d = 0; d < h.length; d++) g.push({
                name: h[d].name,
                position: new P.Vector2D(h[d].position.x, h[d].position.y)
            });
            var x = JSON.parse(u),
                f = [];
            for (d = 0; d < x.length; d++) f.push({
                id: x[d].id,
                position: new P.Vector2D(x[d].position.x, x[d].position.y),
                dropPosition: new P.Vector2D(x[d].dropPosition.x, x[d].dropPosition.y)
            });
            (B.billiardEngine = new P.Engine(B.onContact, null, y, g, f)).friction = t, B.billiardEngine.ballRadius = e, B.billiardEngine.pocketRadius = i, B.billiardEngine.physScale = n, B.billiardEngine.minVelocity = l, B.billiardEngine.cushionRestitution = o, B.billiardEngine.ballRestitution = a
        }, B.getCueBallPosition = function(t, e) {
            B.assignedBalls = e;
            for (var i, n, l = B.getBallArray(t), o = [], a = 0; a < 20;) i = 8e4 * Math.random() - 4e4, n = 36e3 * Math.random() - 18e3, B.isProposedCueBallPositionValid(i, n, l) && (a++, o.push({
                x: i,
                y: n
            }));
            var r = B.getValidBalls(l),
                s = [];
            for (a = 0; a < o.length; a++) {
                l[0].position.x = o[a].x, l[0].position.y = o[a].y;
                var u = B.getCueBaseAngle(r, l);
                s.push(u)
            }
            var c = 0,
                p = null;
            for (a = 0; a < s.length; a++) s[a].length > c && (c = s[a].length, p = a);
            if (null !== p) i = o[p].x, n = o[p].y;
            else
                for (i = -21e3, n = 0; !B.isProposedCueBallPositionValid(i, n, l);) n -= .5 * B.billiardEngine.ballRadius;
            return {
                x: i,
                y: n
            }
        }, B.getShot = function(t, e, i, n) {
            var l, o = B.getBallArray(t),
                a = P.Maths.fixNumber(600 + 1300 * Math.random());
            B.shots = e, B.assignedBalls = i, B.timeLimit = n, B.timeIterationsStarted = Date.now(), B.ballsHitVertex = [], B.ballsThatCollidedWithSelectedBall = [];
            var r = null,
                s = null,
                u = null;
            if ((B.iterations = 0) === B.shots) {
                s = {
                    angle: 0,
                    impulse: a = 1900,
                    hitsBorder: 0,
                    pocketedBalls: null,
                    pocket8Ball: B.getAnyPocketForBall8(),
                    finalBallsPositionArrayStr: null,
                    shotData: null
                }, B.selectedBall_id = null;
                for (var c = 90 / B.angleSteps, p = !1, y = 0; y < B.angleSteps; y++) {
                    var d = c * y - 45,
                        h = new P.Vector2D(Math.cos(d * Math.PI / 180), Math.sin(d * Math.PI / 180));
                    if (B.ballsHitVertex.length = 0, l = B.runSimulation(o, h, 1900), !B.breakSimulation && 0 < B.pocketedBalls.length && 3 < B.ballsHitVertex.length) {
                        s.angle = d, s.impulse = 1900, s.finalBallsPositionArrayStr = l, p = !0;
                        break
                    }
                    var g = Date.now();
                    if (B.timeLimit < g - B.timeIterationsStarted) {
                        p = !1, B.log("TIME OUT, BREAKING LOOP:" + (g - B.timeIterationsStarted).toString());
                        break
                    }
                }
                p || (s.finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(1, 0), a))
            } else {
                B.pocketBall8 = B.checkBall8(o);
                var x = B.getValidBalls(o);
                if (0 === (r = B.getCueBaseAngle(x, o)).length)(s = {
                    angle: 0,
                    impulse: a,
                    hitsBorder: 0,
                    pocketedBalls: null,
                    pocket8Ball: B.getAnyPocketForBall8(),
                    finalBallsPositionArrayStr: null,
                    shotData: null
                }).finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(1, 0), a);
                else if (B.iteratingIndirectShot = !1, (u = B.iterateShotData(o, r)).timeOut && B.log("TIME OUT"), null === (s = B.getBestIterationResult(u)) && !u.timeOut) {
                    B.log("PROBANDO CON RESULTADOS INDIRECTOS"), B.iteratingIndirectShot = !0;
                    var f = B.getCueBaseAngleIndirectShot(x, o),
                        m = B.iterateShotData(o, f);
                    if (null === (s = B.getBestIterationResult(m)))
                        if (0 < f.length) B.log("SE PROBARON INDIRECTOS Y SE TIRA HACIA UN BORDE"), (s = {
                            angle: d = B.getDefaultAngleFromShotData(f[0], !0),
                            impulse: a,
                            hitsBorder: 0,
                            pocketedBalls: null,
                            pocket8Ball: B.getAnyPocketForBall8(),
                            finalBallsPositionArrayStr: null,
                            shotData: null
                        }).finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(Math.cos(d * Math.PI / 180), Math.sin(d * Math.PI / 180)), a);
                        else if (0 < r.length) B.log("SE PROBARON INDIRECTOS Y SE TIRA DIRECTAMENTE A UNA BOLA"), (s = s = {
                        angle: d = B.getDefaultAngleFromShotData(r[0]),
                        impulse: a,
                        hitsBorder: 0,
                        pocketedBalls: null,
                        pocket8Ball: B.getAnyPocketForBall8(),
                        finalBallsPositionArrayStr: null,
                        shotData: null
                    }).finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(Math.cos(d * Math.PI / 180), Math.sin(d * Math.PI / 180)), a);
                    else B.log("TIRANDO RECTO, YA SE PROBARON INDIRECTOS"), (s = {
                        angle: 0,
                        impulse: a,
                        hitsBorder: 0,
                        pocketedBalls: null,
                        pocket8Ball: B.getAnyPocketForBall8(),
                        finalBallsPositionArrayStr: null,
                        shotData: null
                    }).finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(1, 0), a);
                    else B.log("RESULTADOS INDIRECTOS SATISFACTORIOS:" + JSON.stringify(r))
                }
            }
            if (B.log("TOTAL ITERACIONES:" + B.iterations.toString()), null === s) {
                var b = r[0];
                (s = {
                    angle: d = (b.angle1 + b.angle2) / 2,
                    impulse: a,
                    hitsBorder: 0,
                    pocketedBalls: null,
                    pocket8Ball: B.getAnyPocketForBall8(),
                    finalBallsPositionArrayStr: null,
                    shotData: b
                }).finalBallsPositionArrayStr = B.runSimulation(o, new P.Vector2D(Math.cos(d * Math.PI / 180), Math.sin(d * Math.PI / 180)), a)
            }
            var v = B.getVelocityConsideringSkill(s);
            return {
                velocity: {
                    x: v.x,
                    y: v.y
                },
                screw: 0,
                verticalSpin: 0,
                english: 0,
                pocket8Ball: s.pocket8Ball,
                finalBallsPositionArrayStr: s.finalBallsPositionArrayStr
            }
        }, B.iterateShotData = function(t, e) {
            for (var i = !1, n = null, l = [], o = [], a = [], r = 0; r < e.length; r++) {
                var s = e[r].angle1;
                B.selectedBall_id = e[r].selectedBall;
                var u = void 0;
                u = B.iteratingIndirectShot || B.pocketBall8 ? B.angleSteps : Math.round(.65 * B.angleSteps);
                for (var c = (e[r].angle2 - e[r].angle1) / u, p = void 0, y = 0; y < 3; y++) {
                    for (var d = 0; d < u + 1; d++) {
                        B.selectedBallsHitsWithBordersCounter = 0, B.ballsThatCollidedWithSelectedBall = [];
                        var h = s + c * d,
                            g = new P.Vector2D(Math.cos(h * Math.PI / 180), Math.sin(h * Math.PI / 180)),
                            x = 500 + 700 * y;
                        if (p = B.runSimulation(t, g, x), !B.breakSimulation) {
                            var f = B.checkPocketedBallsInSimulation();
                            if (f.excelentResult)
                                if (0 === B.ballsThatCollidedWithSelectedBall.length) {
                                    if (0 === B.selectedBallsHitsWithBordersCounter) {
                                        n = {
                                            angle: h,
                                            impulse: x,
                                            hitsBorder: 0,
                                            pocketedBalls: B.pocketedBalls.length,
                                            pocket8Ball: B.pocket8BallInside,
                                            finalBallsPositionArrayStr: p,
                                            shotData: e[r]
                                        };
                                        break
                                    }
                                    l.push({
                                        angle: h,
                                        impulse: x,
                                        hitsBorder: B.selectedBallsHitsWithBordersCounter,
                                        pocketedBalls: B.pocketedBalls.length,
                                        pocket8Ball: B.pocket8BallInside,
                                        finalBallsPositionArrayStr: p,
                                        shotData: e[r]
                                    })
                                } else o.push({
                                    angle: h,
                                    impulse: x,
                                    hitsBorder: B.selectedBallsHitsWithBordersCounter,
                                    pocketedBalls: B.pocketedBalls.length,
                                    pocket8Ball: B.pocket8BallInside,
                                    finalBallsPositionArrayStr: p,
                                    shotData: e[r]
                                });
                            else f.goodResult && a.push({
                                angle: h,
                                impulse: x,
                                hitsBorder: 0,
                                pocketedBalls: B.pocketedBalls.length,
                                pocket8Ball: B.pocket8BallInside,
                                finalBallsPositionArrayStr: p,
                                shotData: e[r]
                            })
                        }
                        var m = Date.now();
                        if (B.timeLimit < m - B.timeIterationsStarted) {
                            i = !0;
                            break
                        }
                    }
                    if (null !== n || i) break
                }
                if (null !== n || i) break
            }
            return {
                timeOut: i,
                topResultDirect: n,
                topResults: l,
                excelentResults: o,
                goodResults: a
            }
        }, B.onContact = function(t) {
            if (0 === B.shots) t.collisionType !== P.Engine.VERTEX && t.collisionType !== P.Engine.LINE || -1 === B.ballsHitVertex.indexOf(t.ball.id) && B.ballsHitVertex.push(t.ball.id);
            else if (t.collisionType !== P.Engine.VERTEX && t.collisionType !== P.Engine.LINE || B.selectedBall_id === t.ball.id && B.selectedBallsHitsWithBordersCounter++, t.collisionType === P.Engine.BALL && (B.firstContact || 0 !== t.ball.id && (B.firstContact = !0, B.selectedBall_id && B.selectedBall_id !== t.ball.id && (B.breakSimulation = !0)), B.selectedBall_id === t.ball.id)) {
                var e = t.target.id;
                0 !== e && -1 === B.ballsThatCollidedWithSelectedBall.indexOf(e) && B.ballsThatCollidedWithSelectedBall.push(e)
            }
            if (t.collisionType === P.Engine.POCKET) {
                var i = t.ball;
                i.active = !1, B.pocketedBalls.push(i.id), B.pocketBall8 && 8 === i.id && (B.pocket8BallInside = t.target.id), B.isPocketedBallNotValid(i.id) && (B.breakSimulation = !0)
            }
        }, B.checkPocketedBallsInSimulation = function() {
            if (0 === B.pocketedBalls.length) return {
                goodResult: !1,
                excelentResult: !1
            };
            var t = !0,
                e = !1;
            return B.pocketBall8 ? -1 !== B.pocketedBalls.indexOf(8) && (e = t = !0) : ("ball striped" === B.assignedBalls ? -1 === B.pocketedBalls.indexOf(1) && -1 === B.pocketedBalls.indexOf(2) && -1 === B.pocketedBalls.indexOf(3) && -1 === B.pocketedBalls.indexOf(4) && -1 === B.pocketedBalls.indexOf(5) && -1 === B.pocketedBalls.indexOf(6) && -1 === B.pocketedBalls.indexOf(7) || (t = !1) : "ball solid" === B.assignedBalls ? -1 === B.pocketedBalls.indexOf(9) && -1 === B.pocketedBalls.indexOf(10) && -1 === B.pocketedBalls.indexOf(11) && -1 === B.pocketedBalls.indexOf(12) && -1 === B.pocketedBalls.indexOf(13) && -1 === B.pocketedBalls.indexOf(14) && -1 === B.pocketedBalls.indexOf(15) || (t = !1) : -1 === B.pocketedBalls.indexOf(0) && -1 === B.pocketedBalls.indexOf(8) || (t = !1), t && -1 !== B.pocketedBalls.indexOf(B.selectedBall_id) && (e = !0)), {
                goodResult: t,
                excelentResult: e
            }
        }, B.runSimulation = function(t, e, i) {
            B.billiardEngine.ballArray = [];
            for (var n = 0; n < t.length; n++) B.billiardEngine.ballArray.push({
                id: t[n].id,
                active: t[n].active,
                position: new P.Vector2D(t[n].position.x, t[n].position.y),
                velocity: new P.Vector2D(t[n].velocity.x, t[n].velocity.y),
                firstContact: t[n].firstContact,
                contactArray: t[n].contactArray,
                lastCollisionObject: t[n].lastCollisionObject,
                screw: t[n].screw,
                english: t[n].english,
                deltaScrew: t[n].deltaScrew ? new P.Vector2D(t[n].deltaScrew.x, t[n].deltaScrew.y) : null,
                grip: t[n].grip,
                ySpin: t[n].ySpin
            });
            var l;
            B.pocketedBalls = [], B.breakSimulation = !1, B.firstContact = !1, B.billiardEngine.ballArray[0].velocity = e.times(i);
            do {
                B.iterations++, B.billiardEngine.update(), l = !1;
                n = 0;
                for (var o = B.billiardEngine.ballArray.length; n < o; n++)
                    if (B.billiardEngine.ballArray[n].active && 0 < B.billiardEngine.ballArray[n].velocity.magnitudeSquared) {
                        l = !0;
                        break
                    }
            } while (l && !B.breakSimulation);
            if (B.breakSimulation) return null;
            var a = [];
            for (n = 0; n < B.billiardEngine.ballArray.length; n++) a.push({
                id: B.billiardEngine.ballArray[n].id,
                active: B.billiardEngine.ballArray[n].active,
                position: {
                    x: B.billiardEngine.ballArray[n].position.x,
                    y: B.billiardEngine.ballArray[n].position.y
                }
            });
            return JSON.stringify(a)
        }, B.getCueBaseAngle = function(t, e) {
            var i = [];
            if (0 < t.length)
                for (var n = 0; n < t.length; n++) {
                    var l = B.checkTangents(e, t[n].id);
                    (l.tangent1Free || l.tangent2Free) && i.push({
                        angle1: l.angle1,
                        angle2: l.angle2,
                        selectedBall: t[n].id
                    })
                }
            return 0 === i.length ? (B.log("NO SE PUEDE HACER DISPARO DIRECTO. MIRANDO REBOTES"), B.getCueBaseAngleIndirectShot(t, e)) : i
        }, B.getMinSquaredDistanceToPocket = function(t, e) {
            for (var i, n = 1e11, l = B.billiardEngine.pocketArray, o = 1, a = t.length; o < a; o++)
                if (t[o].id === e) {
                    i = t[o];
                    break
                }
            for (o = 1, a = l.length; o < a; o++) {
                var r = (l[o].position.x - i.position.x) * (l[o].position.x - i.position.x) + (l[o].position.y - i.position.y) * (l[o].position.y - i.position.y);
                r < n && (n = r)
            }
            return n
        }, B.getCueBaseAngleIndirectShot = function(t, e) {
            for (var i, n, l, o, a = [], r = e[0], s = 0; s < t.length; s++) {
                var u = t[s],
                    c = 42e3 - u.position.x,
                    p = r.position.y - u.position.y,
                    y = 42e3 - r.position.x,
                    d = c * p / (y * (c / y + 1)),
                    h = 42e3,
                    g = u.position.y + d;
                l = B.isLineFree(new P.Point(r.position.x, r.position.y), new P.Point(h, g), e, u.id), o = B.isLineFree(new P.Point(u.position.x, u.position.y), new P.Point(h, g), e, u.id), l && o && (i = P.Maths.findBearing(h - r.position.x, g - r.position.y), n = r.position.y < u.position.y ? -10 : 10, a.push({
                    angle1: i,
                    angle2: i + n,
                    selectedBall: u.id
                })), d = (c = 21e3 - u.position.y) * (p = r.position.x - u.position.x) / ((y = 21e3 - r.position.y) * (c / y + 1)), h = u.position.x + d, g = 21e3, l = B.isLineFree(new P.Point(r.position.x, r.position.y), new P.Point(h, g), e, u.id), o = B.isLineFree(new P.Point(u.position.x, u.position.y), new P.Point(h, g), e, u.id), l && o && (i = P.Maths.findBearing(h - r.position.x, g - r.position.y), n = r.position.x < u.position.x ? 15 : -15, a.push({
                    angle1: i,
                    angle2: i + n,
                    selectedBall: u.id
                })), d = (c = -21e3 - u.position.y) * (p = r.position.x - u.position.x) / ((y = -21e3 - r.position.y) * (c / y + 1)), h = u.position.x + d, g = -21e3, l = B.isLineFree(new P.Point(r.position.x, r.position.y), new P.Point(h, g), e, u.id), o = B.isLineFree(new P.Point(u.position.x, u.position.y), new P.Point(h, g), e, u.id), l && o && (i = P.Maths.findBearing(h - r.position.x, g - r.position.y), n = r.position.x < u.position.x ? -15 : 15, a.push({
                    angle1: i,
                    angle2: i + n,
                    selectedBall: u.id
                })), d = (c = -42e3 - u.position.x) * (p = r.position.y - u.position.y) / ((y = -42e3 - r.position.x) * (c / y + 1)), h = -42e3, g = u.position.y + d, l = B.isLineFree(new P.Point(r.position.x, r.position.y), new P.Point(h, g), e, u.id), o = B.isLineFree(new P.Point(u.position.x, u.position.y), new P.Point(h, g), e, u.id), l && o && (i = P.Maths.findBearing(h - r.position.x, g - r.position.y), n = r.position.y < u.position.y ? 10 : -10, a.push({
                    angle1: i,
                    angle2: i + n,
                    selectedBall: u.id
                }))
            }
            return a
        }, B.checkTangents = function(t, e) {
            var i = 0,
                n = 0,
                l = !0,
                o = !0,
                a = t[0],
                r = new P.Point(a.position.x, a.position.y),
                s = new P.Point(t[e].position.x, t[e].position.y),
                u = B.billiardEngine.ballRadius,
                c = P.Maths.getTangents(r, u, s, u),
                p = c.internTangent1.p1,
                y = c.internTangent1.p2,
                d = c.internTangent2.p1,
                h = c.internTangent2.p2;
            i = P.Maths.findBearing(y.x - p.x, y.y - p.y), n = P.Maths.findBearing(h.x - d.x, h.y - d.y), 90 < Math.abs(i) && 90 < Math.abs(n) && (i < 0 && 0 < n ? i = 360 + i : 0 < i && n < 0 && (n = 360 + n));
            for (var g = 1, x = t.length; g < x; g++) {
                var f = t[g];
                if (f.id !== e) {
                    var m = new P.Point(f.position.x, f.position.y);
                    if (P.Maths.lineIntersectCircle(p, y, m, u).intersects && (l = !1), P.Maths.lineIntersectCircle(d, h, m, u).intersects && (o = !1), !l && !o) break
                }
            }
            return B.pocketBall8 || (i += .5 < Math.random() ? .1 : -1, n += .5 < Math.random() ? .1 : -1), {
                angle1: i,
                angle2: n,
                tangent1Free: l,
                tangent2Free: o
            }
        }, B.getSquaredDistanceToPocket = function(t) {
            for (var e = B.billiardEngine.pocketArray, i = e[0].position.x, n = e[0].position.y, l = t.x, o = t.y, a = (i - l) * (i - l) + (n - o) * (n - o), r = 1; r < e.length; r++) {
                var s = ((i = e[r].position.x) - l) * (i - l) + ((n = e[r].position.y) - o) * (n - o);
                s < a && (a = s)
            }
            return a
        }, B.checkBall8 = function(t) {
            var e = !0;
            if ("" === B.assignedBalls) e = !1;
            else
                for (var i = 1, n = t.length; i < n; i++) {
                    var l = t[i];
                    if (l.active)
                        if ("ball striped" === B.assignedBalls) {
                            if (8 < l.id) {
                                e = !1;
                                break
                            }
                        } else if ("ball solid" === B.assignedBalls && l.id < 8) {
                        e = !1;
                        break
                    }
                }
            return e
        }, B.isProposedCueBallPositionValid = function(t, e, i) {
            for (var n = !0, l = 1, o = i.length; l < o; l++) {
                var a = i[l];
                if (Math.sqrt((t - a.position.x) * (t - a.position.x) + (e - a.position.y) * (e - a.position.y)) < 2 * B.billiardEngine.ballRadius) {
                    n = !1;
                    break
                }
            }
            return n
        }, B.getDefaultAngleFromShotData = function(t, e) {
            var i;
            if (null !== t.angle1 && null !== t.angle2) {
                var n = t.angle2 - t.angle1;
                i = e ? t.angle1 + .15 * n : t.angle1 + .5 * n
            } else i = null === t.angle1 ? t.angle2 : t.angle1;
            return i
        }, B.getAnyPocketForBall8 = function(t) {
            return Math.floor(6 * Math.random())
        }, B.isLineFree = function(t, e, i, n) {
            for (var l = !0, o = 1, a = i.length; o < a; o++)
                if (i[o].active && i[o].id !== n) {
                    var r = new P.Point(i[o].position.x, i[o].position.y);
                    if (P.Maths.lineIntersectCircle(t, e, r, B.billiardEngine.ballRadius).intersects) {
                        l = !1;
                        break
                    }
                }
            return l
        }, B.getBallArray = function(t) {
            for (var e = [], i = JSON.parse(t), n = 0, l = i.length; n < l; n++) e.push({
                id: i[n].id,
                active: i[n].active,
                position: new P.Vector2D(i[n].position.x, i[n].position.y),
                velocity: new P.Vector2D(0, 0),
                firstContact: !1,
                contactArray: [],
                lastCollisionObject: null,
                screw: 0,
                english: 0,
                deltaScrew: new P.Vector2D(0, 0),
                grip: 1,
                ySpin: 0
            });
            return e.sort(function(t, e) {
                return t.id - e.id
            }), e
        }, B.getBestIterationResult = function(t) {
            var e = t.topResultDirect,
                i = t.topResults,
                n = t.excelentResults,
                l = t.goodResults,
                o = null;
            if (null !== e) o = e, B.log("TOP RESULT DIRECTO. iteraciones:" + B.iterations + " toques bordes:" + B.selectedBallsHitsWithBordersCounter);
            else if (0 < i.length) o = i[0], B.log("TOP RESULT. iteraciones:" + B.iterations);
            else if (0 < n.length) o = n[0], B.log("EXCELLENT RESULT. iteraciones:" + B.iterations);
            else if (0 < l.length) {
                var a = void 0;
                for (a = 0; a < l.length && !(1 < l[a].pocketedBalls); a++);
                a === l.length ? (o = l[0], B.log("GOOD RESULT. iteraciones:" + B.iterations + " RESULTADO ALTERNATIVOS:" + l.length)) : (o = t.goodResults[a], B.log("GOOD RESULT. iteraciones:" + B.iterations + " RESULTADO ALTERNATIVOS:" + l.length + " pocketed balls:" + l[a].pocketedBalls))
            } else B.log("LAS ITERACIONES SE HAN AGOTADO " + B.iterations), o = null;
            return o
        }, B.isPocketedBallNotValid = function(t) {
            var e = !1;
            return 0 === t ? e = !0 : 8 === t ? B.pocketBall8 || (e = !0) : ("ball striped" === B.assignedBalls && t < 8 && (e = !0), "ball solid" === B.assignedBalls && 8 < t && (e = !0)), e
        }, B.getValidBalls = function(t) {
            var e = [];
            if (B.pocketBall8) e.push(t[8]);
            else
                for (var i = 1; i < t.length; i++) {
                    var n = t[i];
                    n.active && ("" === B.assignedBalls ? 8 !== n.id && e.push(n) : "ball striped" === B.assignedBalls ? 8 < n.id && e.push(n) : n.id < 8 && e.push(n))
                }
            return e
        }, B.getVelocityConsideringSkill = function(t) {
            var e;
            if (10 * Math.random() < B.skillFactor || 0 === B.shots) e = new P.Vector2D(Math.cos(t.angle * Math.PI / 180), Math.sin(t.angle * Math.PI / 180)).times(t.impulse);
            else {
                var i = void 0;
                if (null === t.shotData) i = 0;
                else {
                    var n = void 0,
                        l = void 0;
                    .5 < Math.random() ? (n = Math.max(t.angle, t.shotData.angle2), l = Math.min(t.angle, t.shotData.angle2)) : (n = Math.max(t.shotData.angle1, t.angle), l = Math.min(t.shotData.angle1, t.angle)), i = Math.random() * (n - l) + l
                }
                e = new P.Vector2D(Math.cos(i * Math.PI / 180), Math.sin(i * Math.PI / 180)).times(.85 * t.impulse)
            }
            return e
        }, B.VERBOSE = !1, B
    }();
    P.Bot = t
}(Billiard || (Billiard = {})),
function(yt) {
    var t = function() {
        function pt(t, e, i, n, l) {
            this.omissionArray = [], this.ballArray = e, this.lineArray = i, this.vertexArray = n, this.pocketArray = l, this.contactCallback = t
        }
        return pt.prototype.update = function() {
            this.predictCollisions(), this.updateFriction()
        }, pt.prototype.predictCollisions = function() {
            var t = 0,
                e = 0,
                i = [];
            do {
                var n = void 0,
                    l = 1;
                i.length = 0;
                for (var o = yt.Maths.fixNumber(1 - t), a = 0, r = this.ballArray.length; a < r; a++) {
                    var s = this.ballArray[a];
                    if (s.active) {
                        for (var u = s.position.plus(s.velocity.times(o)), c = a + 1, p = this.ballArray.length; c < p; c++) {
                            var y = this.ballArray[c];
                            if ((0 < s.velocity.magnitudeSquared || 0 < y.velocity.magnitudeSquared) && y.active && yt.Maths.checkObjectsConverging(s.position, y.position, s.velocity, y.velocity)) {
                                var d = s.velocity.minus(y.velocity),
                                    h = s.position.plus(d.times(o)),
                                    g = new yt.Point(s.position.x, s.position.y),
                                    x = new yt.Point(h.x, h.y),
                                    f = new yt.Point(y.position.x, y.position.y),
                                    m = yt.Maths.lineIntersectCircle(g, x, f, 2 * this.ballRadius);
                                if (m.intersects || m.inside) {
                                    var b = void 0;
                                    null !== m.exit && (b = m.exit), null !== m.enter && (b = m.enter);
                                    var v = void 0,
                                        B = void 0;
                                    if (m.intersects) {
                                        v = new yt.Vector2D(b.x, b.y);
                                        var P = yt.Maths.createVectorFrom2Points(g, x),
                                            V = yt.Maths.createVectorFrom2Points(g, b);
                                        B = yt.Maths.fixNumber(t + V.magnitude / P.magnitude * o)
                                    }
                                    if (m.inside) {
                                        var S = s.position.minus(y.position).normalize();
                                        v = y.position.plus(S.times(2 * this.ballRadius)), B = t
                                    }
                                    B < l ? (l = B, (n = {
                                        type: null,
                                        object: null,
                                        target: null,
                                        time: null,
                                        objectIntersectPoint: null,
                                        targetIntersectPoint: null
                                    }).type = pt.BALL, n.object = s, n.time = l, m.intersects && (n.objectIntersectPoint = s.position.plus(s.velocity.times(l - t)), n.targetIntersectPoint = y.position.plus(y.velocity.times(l - t))), m.inside && (n.objectIntersectPoint = v, n.targetIntersectPoint = y.position), n.target = y, (i = []).push(n)) : B === l && 1 !== B && (l = B, (n = {
                                        type: null,
                                        object: null,
                                        target: null,
                                        time: null,
                                        objectIntersectPoint: null,
                                        targetIntersectPoint: null
                                    }).type = pt.BALL, n.object = s, n.time = l, n.objectIntersectPoint = s.position.plus(s.velocity.times(l - t)), n.target = y, n.targetIntersectPoint = y.position.plus(y.velocity.times(l - t)), m.inside && (n.objectIntersectPoint = v, n.targetIntersectPoint = y.position), i.push(n))
                                }
                            }
                        }
                        if (0 < s.velocity.magnitudeSquared) {
                            for (var w = 0, M = this.lineArray.length; w < M; w++) {
                                var I = this.lineArray[w],
                                    k = yt.Maths.lineIntersectLine(new yt.Point(s.position.x, s.position.y), new yt.Point(u.x, u.y), new yt.Point(I.p3.x, I.p3.y), new yt.Point(I.p4.x, I.p4.y));
                                if (null === k)
                                    if (null !== (k = yt.Maths.lineIntersectLine(new yt.Point(s.position.x, s.position.y), new yt.Point(u.x, u.y), new yt.Point(I.p5.x, I.p5.y), new yt.Point(I.p6.x, I.p6.y)))) {
                                        var A = new yt.Vector2D(k.x, k.y),
                                            E = I.normal.times(.475 * this.ballRadius),
                                            D = A.plus(E);
                                        k = new yt.Point(D.x, D.y)
                                    } else "VW" === I.name && s.position.x < I.p3.x && s.position.y < I.p3.y && s.position.y > I.p4.y ? k = new yt.Point(I.p3.x, s.position.y) : "JK" === I.name && s.position.x > I.p3.x && s.position.y > I.p3.y && s.position.y < I.p4.y ? k = new yt.Point(I.p3.x, s.position.y) : "BC" === I.name && s.position.y < I.p3.y && s.position.x > I.p3.x && s.position.x < I.p4.x ? k = new yt.Point(s.position.x, I.p3.y) : "FG" === I.name && s.position.y < I.p3.y && s.position.x > I.p3.x && s.position.x < I.p4.x ? k = new yt.Point(s.position.x, I.p3.y) : "NO" === I.name && s.position.y > I.p3.y && s.position.x < I.p3.x && s.position.x > I.p4.x ? k = new yt.Point(s.position.x, I.p3.y) : "RS" === I.name && s.position.y > I.p3.y && s.position.x < I.p3.x && s.position.x > I.p4.x && (k = new yt.Point(s.position.x, I.p3.y));
                                if (null !== k) {
                                    var O = new yt.Vector2D(k.x, k.y),
                                        N = yt.Maths.createVectorFrom2Points(s.position, u),
                                        R = yt.Maths.createVectorFrom2Points(s.position, O);
                                    (G = yt.Maths.fixNumber(t + R.magnitude / N.magnitude * o)) < 0 ? (i = []).push(n = {
                                        type: pt.LINE,
                                        object: s,
                                        target: I,
                                        time: l = G,
                                        objectIntersectPoint: O,
                                        targetIntersectPoint: null
                                    }) : 1 !== G && (n = {
                                        type: pt.LINE,
                                        object: s,
                                        target: I,
                                        time: l = G,
                                        objectIntersectPoint: O,
                                        targetIntersectPoint: null
                                    }, i.push(n))
                                }
                            }
                            for (var C = 0, T = this.vertexArray.length; C < T; C++) {
                                var j = this.vertexArray[C];
                                if (Math.abs(s.position.x - j.position.x) < 8e3 && Math.abs(s.position.y - j.position.y) < 8e3) {
                                    var L = new yt.Point(s.position.x, s.position.y),
                                        F = new yt.Point(u.x, u.y),
                                        _ = new yt.Point(j.position.x, j.position.y),
                                        q = yt.Maths.lineIntersectCircle(L, F, _, this.ballRadius);
                                    if (q.intersects || q.inside) {
                                        var H = void 0;
                                        null !== q.enter && (H = q.enter), null !== q.exit && (H = q.exit), null !== q.enter && null !== q.exit && (H = q.enter), null === q.enter && q.exit;
                                        var U = void 0,
                                            W = void 0;
                                        if (q.intersects) {
                                            U = new yt.Vector2D(H.x, H.y);
                                            var z = yt.Maths.createVectorFrom2Points(L, F),
                                                K = yt.Maths.createVectorFrom2Points(L, H);
                                            W = yt.Maths.fixNumber(t + K.magnitude / z.magnitude * o)
                                        }
                                        if (q.inside) {
                                            var X = s.position.plus(s.velocity.normalize().times(2 * -this.ballRadius)),
                                                J = new yt.Point(X.x, X.y);
                                            H = yt.Maths.lineIntersectCircle(L, J, _, this.ballRadius).exit, U = new yt.Vector2D(H.x, H.y), W = t
                                        }
                                        W < l ? (l = W, (n = {
                                            type: null,
                                            object: null,
                                            target: null,
                                            time: null,
                                            objectIntersectPoint: null,
                                            targetIntersectPoint: null
                                        }).type = pt.VERTEX, n.object = s, n.time = l, n.objectIntersectPoint = U, n.target = j, (i = []).push(n)) : W === l && 1 !== W && (l = W, (n = {
                                            type: null,
                                            object: null,
                                            target: null,
                                            time: null,
                                            objectIntersectPoint: null,
                                            targetIntersectPoint: null
                                        }).type = pt.VERTEX, n.object = s, n.time = l, q.intersects && (n.objectIntersectPoint = new yt.Vector2D(H.x, H.y)), q.inside && (n.objectIntersectPoint = U), n.target = j, i.push(n))
                                    }
                                }
                            }
                            for (var G = 0, Y = this.pocketArray.length; G < Y; G++) {
                                var Q = this.pocketArray[G],
                                    Z = !1;
                                Math.abs(s.position.x - Q.position.x) < 8e3 && Math.abs(s.position.y - Q.position.y) < 8e3 && (Z = !0);
                                var $ = !1;
                                if (Z) {
                                    var tt = Q.position.minus(s.position).normalize();
                                    0 < s.velocity.dot(tt) && ($ = !0)
                                }
                                if (Z && $) {
                                    g = new yt.Point(s.position.x, s.position.y);
                                    var et = new yt.Point(u.x, u.y),
                                        it = new yt.Point(Q.position.x, Q.position.y),
                                        nt = yt.Maths.lineIntersectCircle(g, et, it, this.pocketRadius);
                                    if (nt.intersects || nt.inside) {
                                        var lt = void 0;
                                        null !== nt.enter && (lt = nt.enter), null !== nt.exit && (lt = nt.exit);
                                        var ot = void 0,
                                            at = void 0;
                                        if (nt.intersects) {
                                            ot = new yt.Vector2D(lt.x, lt.y);
                                            var rt = yt.Maths.createVectorFrom2Points(g, et),
                                                st = yt.Maths.createVectorFrom2Points(g, lt);
                                            at = yt.Maths.fixNumber(t + st.magnitude / rt.magnitude * o)
                                        }
                                        if (nt.inside) {
                                            var ut = yt.Maths.createVectorFrom2Points(it, g).normalize();
                                            ot = new yt.Vector2D(it.x, it.y).plus(ut.times(this.pocketRadius)), at = t
                                        }
                                        if (at < l) {
                                            l = at, (n = {
                                                type: null,
                                                object: null,
                                                target: null,
                                                time: null,
                                                objectIntersectPoint: null,
                                                targetIntersectPoint: null
                                            }).type = pt.POCKET, n.object = s, n.time = l, nt.intersects && (n.objectIntersectPoint = new yt.Vector2D(lt.x, lt.y)), nt.inside && (n.objectIntersectPoint = ot), n.target = Q, (i = []).push(n);
                                            break
                                        }
                                        if (at === l && 1 !== at) {
                                            (n = {
                                                type: null,
                                                object: null,
                                                target: null,
                                                time: null,
                                                objectIntersectPoint: null,
                                                targetIntersectPoint: null
                                            }).type = pt.POCKET, n.object = s, n.time = l, nt.intersects && (n.objectIntersectPoint = new yt.Vector2D(lt.x, lt.y)), nt.inside && (n.objectIntersectPoint = ot), n.target = Q, i.push(n);
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                0 < i.length && this.resolveCollision(i);
                var ct = yt.Maths.fixNumber(l - t);
                this.moveBalls(ct), t = l, e++
            } while (0 < i.length && e < 20)
        }, pt.prototype.resolveCollision = function(t) {
            for (var e = this.omissionArray.length = 0, i = t.length; e < i; e++) {
                var n = t[e],
                    l = void 0,
                    o = void 0,
                    a = void 0,
                    r = void 0;
                if (n.type === pt.BALL) {
                    (l = n.object).position = n.objectIntersectPoint;
                    var s = (o = n.target).position.minus(l.position).normalize(),
                        u = (f = new yt.Vector2D(s.x, s.y)).getRightNormal();
                    a = f.times(l.velocity.dot(f));
                    var c = u.times(l.velocity.dot(u)),
                        p = f.times(o.velocity.dot(f)),
                        y = u.times(o.velocity.dot(u));
                    Math.abs(o.ySpin) < Math.abs(l.ySpin) && (o.ySpin = -.5 * l.ySpin), 0 !== l.id || l.firstContact || (l.firstContact = !0);
                    var d = p.times(this.ballRestitution).plus(a.times(1 - this.ballRestitution)),
                        h = a.times(this.ballRestitution).plus(p.times(1 - this.ballRestitution));
                    l.velocity = c.plus(d), o.velocity = y.plus(h), 450 < h.magnitude && (o.grip = 0), (l.lastCollisionObject = o).lastCollisionObject = l
                }
                if (n.type === pt.LINE) {
                    (l = n.object).position = n.objectIntersectPoint;
                    var g = n.target;
                    this.omissionArray.push(l), l.ySpin += -l.velocity.dot(g.direction) / 300, 20 < l.ySpin && (l.ySpin = 20), l.ySpin < -20 && (l.ySpin = -20), a = g.normal.times(l.velocity.dot(g.normal));
                    c = g.direction.times(l.velocity.dot(g.direction));
                    0 === l.id && (c = c.plus(g.direction.times(yt.Maths.fixNumber(.1 * l.english * l.velocity.magnitude))), l.english = yt.Maths.fixNumber(.45 * l.english), -.1 < l.english && l.english < .1 && (l.english = 0), l.deltaScrew = l.deltaScrew.times(.75)), l.velocity = a.times(-this.cushionRestitution).plus(c), 700 < a.magnitude && (l.grip = 0), l.lastCollisionObject = g, l.position = l.position.plus(g.normal.times(200))
                }
                if (n.type === pt.VERTEX) {
                    (l = n.object).position = n.objectIntersectPoint;
                    var x = n.target;
                    this.omissionArray.push(l);
                    var f;
                    s = x.position.minus(l.position).normalize(), u = (f = new yt.Vector2D(s.x, s.y)).getRightNormal();
                    a = f.times(l.velocity.dot(f));
                    c = u.times(l.velocity.dot(u));
                    l.velocity = a.times(-this.cushionRestitution).plus(c), l.position = l.position.minus(f.times(200)), l.lastCollisionObject = x, l.lastVertex = x.name, 0 === l.id && (l.deltaScrew = new yt.Vector2D(0, 0))
                }
                n.type === pt.POCKET && ((l = n.object).position = n.objectIntersectPoint, this.omissionArray.push(l), r = l.velocity.magnitude), this.sendContactEvent(n, l, a, r, o)
            }
        }, pt.prototype.sendContactEvent = function(t, e, i, n, l) {
            var o = {
                collisionType: null,
                ball: null,
                target: null,
                ballVelocity: null,
                targetVelocity: null,
                normalVelocity: null,
                deltaScrew: null,
                speed: null
            };
            o.collisionType = t.type, o.ball = e, o.target = t.target, o.ballVelocity = e.velocity, t.type === pt.BALL && (o.targetVelocity = l.velocity, 0 === e.id && (o.deltaScrew = t.target.deltaScrew)), t.type !== pt.LINE && t.type !== pt.VERTEX || (o.normalVelocity = i), t.type === pt.POCKET && (o.speed = n), this.contactCallback(o), t.type === pt.BALL && ((o = {
                collisionType: null,
                ball: null,
                target: null,
                ballVelocity: null,
                targetVelocity: null,
                normalVelocity: null,
                deltaScrew: null,
                speed: null
            }).collisionType = t.type, o.ball = t.target, o.target = e, o.ballVelocity = t.target.velocity, o.targetVelocity = e.velocity, 0 === l.id && (o.deltaScrew = t.target.deltaScrew), this.contactCallback(o))
        }, pt.prototype.moveBalls = function(t) {
            for (var e = 0, i = this.ballArray.length; e < i; e++) {
                var n = this.ballArray[e];
                (0 !== this.omissionArray.length && -1 !== this.omissionArray.indexOf(n) || n.active) && (n.position = n.position.plus(n.velocity.times(t)))
            }
            this.omissionArray.length = 0
        }, pt.prototype.updateFriction = function() {
            for (var t = 0, e = this.ballArray.length; t < e; t++) {
                var i = this.ballArray[t];
                if (i.active) {
                    0 === i.id && 0 < i.deltaScrew.magnitudeSquared && (i.deltaScrew = i.deltaScrew.times(.95), i.firstContact && (i.velocity = i.velocity.plus(i.deltaScrew)), i.deltaScrew.magnitudeSquared < 1 && (i.deltaScrew = new yt.Vector2D(0, 0)));
                    var n = i.velocity.magnitude;
                    n -= this.friction;
                    var l = i.velocity.normalize();
                    if (i.velocity = l.times(n), i.velocity.magnitude < this.minVelocity && (i.velocity = new yt.Vector2D(0, 0)), i.grip < 1 && (i.grip += .03), .2 <= i.ySpin && (i.ySpin -= .2), i.ySpin <= -.2 && (i.ySpin += .2), -.2 <= i.ySpin && i.ySpin <= .2 && (i.ySpin = 0), 0 !== i.ySpin) {
                        var o = i.velocity.getLeftNormal().normalize().times(.5 * i.ySpin * i.velocity.magnitude / 500);
                        i.velocity = i.velocity.plus(o)
                    }
                }
            }
        }, pt.VERSION = "0.2", pt.BALL = "ball", pt.LINE = "line", pt.POCKET = "pocket", pt.VERTEX = "vertex", pt
    }();
    yt.Engine = t
}(Billiard || (Billiard = {})),
function(B) {
    var t = function() {
        function y() {}
        return y.fixNumber = function(t) {
            return isNaN(t) ? 0 : Math.round(1e5 * t) / 1e5
        }, y.getTangents = function(t, e, i, n) {
            var l = t.x,
                o = t.y,
                a = i.x,
                r = i.y,
                s = (l - a) * (l - a) + (o - r) * (o - r);
            if (s <= (e - n) * (e - n)) return null;
            for (var u = Math.sqrt(s), c = (a - l) / u, p = (r - o) / u, y = [
                    [],
                    [],
                    [],
                    []
                ], d = 0, h = 1; - 1 <= h; h -= 2) {
                var g = (e - h * n) / u;
                if (g * g <= 1)
                    for (var x = Math.sqrt(Math.max(0, 1 - g * g)), f = 1; - 1 <= f; f -= 2) {
                        var m = c * g - f * x * p,
                            b = p * g + f * x * c,
                            v = y[d++];
                        v[0] = l + e * m, v[1] = o + e * b, v[2] = a + h * n * m, v[3] = r + h * n * b
                    }
            }
            return {
                externTangent1: {
                    p1: new B.Point(y[0][0], y[0][1]),
                    p2: new B.Point(y[0][2], y[0][3])
                },
                externTangent2: {
                    p1: new B.Point(y[1][0], y[1][1]),
                    p2: new B.Point(y[1][2], y[1][3])
                },
                internTangent1: {
                    p1: new B.Point(y[2][0], y[2][1]),
                    p2: new B.Point(y[2][2], y[2][3])
                },
                internTangent2: {
                    p1: new B.Point(y[3][0], y[3][1]),
                    p2: new B.Point(y[3][2], y[3][3])
                }
            }
        }, y.lineIntersectLine = function(t, e, i, n) {
            var l = e.y - t.y,
                o = t.x - e.x,
                a = e.x * t.y - t.x * e.y,
                r = n.y - i.y,
                s = i.x - n.x,
                u = n.x * i.y - i.x * n.y,
                c = l * s - r * o;
            if (0 === c) return null;
            var p = new B.Point((o * u - s * a) / c, (r * a - l * u) / c);
            return p.x = y.fixNumber(p.x), p.y = y.fixNumber(p.y), 0 < (p.x - t.x) * (p.x - e.x) || 0 < (p.y - t.y) * (p.y - e.y) || 0 < (p.x - i.x) * (p.x - n.x) || 0 < (p.y - i.y) * (p.y - n.y) ? null : p
        }, y.lineIntersectCircle = function(t, e, i, n) {
            var l = {
                    inside: !1,
                    tangent: !1,
                    intersects: !1,
                    enter: null,
                    exit: null
                },
                o = (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y),
                a = 2 * ((e.x - t.x) * (t.x - i.x) + (e.y - t.y) * (t.y - i.y)),
                r = i.x * i.x + i.y * i.y + t.x * t.x + t.y * t.y - 2 * (i.x * t.x + i.y * t.y) - n * n,
                s = y.fixNumber(a * a - 4 * o * r);
            if (s <= 0) l.inside = !1;
            else {
                var u = y.fixNumber(Math.sqrt(s)),
                    c = y.fixNumber((-a + u) / (2 * o)),
                    p = y.fixNumber((-a - u) / (2 * o));
                (c < 0 || 1 < c) && (p < 0 || 1 < p) ? l.inside = !(c < 0 && p < 0 || 1 < c && 1 < p): (0 <= p && p <= 1 && (l.enter = B.Point.interpolate(t, e, p), l.enter = new B.Point(y.fixNumber(l.enter.x), y.fixNumber(l.enter.y))), 0 <= c && c <= 1 && (l.exit = B.Point.interpolate(t, e, c), l.exit = new B.Point(y.fixNumber(l.exit.x), y.fixNumber(l.exit.y))), l.intersects = !0, null !== l.exit && null !== l.enter && l.exit.equals(l.enter) && (l.tangent = !0))
            }
            return l
        }, y.findBearing = function(t, e) {
            var i = y._180_DIV_PI * Math.atan2(e, t);
            return y.fixNumber(i)
        }, y.angleDiff = function(t, e) {
            var i = y.wrapValue(t + 180 - e) - 180;
            return y.fixNumber(i)
        }, y.wrapValue = function(t) {
            return 360 < t && (t -= 360), t < 0 && (t += 360), t
        }, y.createVectorFrom2Points = function(t, e) {
            return new B.Vector2D(e.x - t.x, e.y - t.y)
        }, y.checkObjectsConverging = function(t, e, i, n) {
            var l = e.minus(t).normalize();
            return n.minus(i).angleBetween(l) > y.PI_2
        }, y._180_DIV_PI = 57.29578, y.PI_DIV_180 = .01745329, y.PI_2 = 1.570796, y
    }();
    B.Maths = t
}(Billiard || (Billiard = {})),
function(l) {
    var t = function() {
        function n(t, e) {
            this.x = t || 0, this.y = e || 0
        }
        return n.interpolate = function(t, e, i) {
            return new n(l.Maths.fixNumber((1 - i) * t.x + i * e.x), l.Maths.fixNumber((1 - i) * t.y + i * e.y))
        }, n.prototype.equals = function(t) {
            return this.x === t.x && this.y === t.y
        }, n
    }();
    l.Point = t
}(Billiard || (Billiard = {})),
function(o) {
    var t = function() {
        function l(t, e) {
            this.xValue = o.Maths.fixNumber(t), this.yValue = o.Maths.fixNumber(e)
        }
        return l.prototype.plus = function(t) {
            var e = new l(this.xValue, this.yValue);
            return e.xValue = o.Maths.fixNumber(e.xValue + t.xValue), e.yValue = o.Maths.fixNumber(e.yValue + t.yValue), e
        }, l.prototype.minus = function(t) {
            var e = new l(this.xValue, this.yValue);
            return e.xValue = o.Maths.fixNumber(e.xValue - t.xValue), e.yValue = o.Maths.fixNumber(e.yValue - t.yValue), e
        }, l.prototype.times = function(t) {
            var e = new l(this.xValue, this.yValue);
            return t instanceof l ? (e.xValue *= t.xValue, e.yValue *= t.yValue) : (e.xValue *= t, e.yValue *= t), e.xValue = o.Maths.fixNumber(e.xValue), e.yValue = o.Maths.fixNumber(e.yValue), e
        }, l.prototype.rotate = function(t) {
            var e = new l(this.xValue, this.yValue);
            if (isNaN(t)) return e;
            var i = Math.sqrt(e.xValue * e.xValue + e.yValue * e.yValue),
                n = Math.atan2(e.yValue, e.xValue) + t * o.Maths.PI_DIV_180;
            return e.xValue = o.Maths.fixNumber(i * Math.cos(n)), e.yValue = o.Maths.fixNumber(i * Math.sin(n)), e
        }, l.prototype.invert = function() {
            var t = new l(this.xValue, this.yValue);
            return t.xValue *= -1, t.yValue *= -1, t
        }, l.prototype.normalize = function() {
            var t = new l(this.xValue, this.yValue);
            return t = t.times(1 / t.magnitude)
        }, l.prototype.dot = function(t) {
            return o.Maths.fixNumber(this.xValue * t.xValue + this.yValue * t.yValue)
        }, l.prototype.cross = function(t) {
            return Math.abs(o.Maths.fixNumber(this.xValue * t.yValue - this.yValue * t.xValue))
        }, l.prototype.angleBetween = function(t) {
            return o.Maths.fixNumber(Math.acos(this.dot(t) / (this.magnitude * t.magnitude)))
        }, l.prototype.getRightNormal = function() {
            return new l(this.yValue, -this.xValue)
        }, l.prototype.getLeftNormal = function() {
            return new l(-this.yValue, this.xValue)
        }, Object.defineProperty(l.prototype, "x", {
            get: function() {
                return this.xValue
            },
            set: function(t) {
                this.xValue = o.Maths.fixNumber(t)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "y", {
            get: function() {
                return this.yValue
            },
            set: function(t) {
                this.yValue = o.Maths.fixNumber(t)
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "angle", {
            get: function() {
                return o.Maths.fixNumber(Math.atan2(this.yValue, this.xValue) * o.Maths._180_DIV_PI)
            },
            set: function(t) {
                var e;
                e = isNaN(t) ? 0 : t * (Math.PI / 180);
                var i = Math.sqrt(this.xValue * this.xValue + this.yValue * this.yValue);
                this.xValue = o.Maths.fixNumber(i * Math.cos(e)), this.yValue = o.Maths.fixNumber(i * Math.sin(e))
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "magnitude", {
            get: function() {
                return o.Maths.fixNumber(Math.sqrt(this.xValue * this.xValue + this.yValue * this.yValue))
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(l.prototype, "magnitudeSquared", {
            get: function() {
                return o.Maths.fixNumber(this.xValue * this.xValue + this.yValue * this.yValue)
            },
            enumerable: !0,
            configurable: !0
        }), l
    }();
    o.Vector2D = t
}(Billiard || (Billiard = {}));